<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:id="cloudservices">
  <title>Cloud Services</title>
  <section>
    <title>1. Congress Works With All Services</title>
    <para>Congress will work with any cloud service, as long as Congress can
                represent the service’s state in <emphasis>table</emphasis> format.  A table is a
                collection of rows, where each row is a collection of columns, and
                each row-column entry contains a string or a number.</para>
    <para>For example, Neutron contains a mapping between IP addresses and the
                ports they are assigned to; neutron represents this state as the
                following table.:</para>
    <screen>====================================== ==========
ID                                     IP
====================================== ==========
"66dafde0-a49c-11e3-be40-425861b86ab6" "10.0.0.1"
"66dafde0-a49c-11e3-be40-425861b86ab6" "10.0.0.2"
"73e31d4c-a49c-11e3-be40-425861b86ab6" "10.0.0.3"
====================================== ==========</screen>
  </section>
  <section>
    <title>2. Drivers</title>
    <para>To plug a new service into Congress, you write a small piece of code,
                called a <emphasis>driver</emphasis>, that queries the new service (usually through API calls)
                and translates the service state into tables of data.  Out of the box
                Congress includes drivers for a number of common services (see below).</para>
    <para>For example, the driver for Neutron invokes the Neutron API calls that list
                networks, ports, security groups, and routers.  The driver translates each of
                the JSON objects that the API calls return into tables (where in Python a table
                is a list of tuples).  The Neutron driver is implemented here:</para>
    <screen>congress/datasources/neutronv2_driver.py</screen>
    <para>Once the driver is available, you install it into Congress,
                you configure it (such as with an IP address/port/username), and you
                write policy that references the tables populated by that driver.</para>
    <section>
      <title>2.1 Driver installation</title>
      <para>To install a new driver, you must add its location to the Congress
                    configuration file and restart the server.  Congress has a single
                    configuration parameter (called <literal>drivers</literal>) that is a list of all the
                    installed drivers.  To install a new driver, simply add to this list
                    and restart.</para>
      <para>For example, to install the Neutron driver, you add the following to the
                    list of drivers in the configuration file:</para>
      <screen>congress.datasources.neutronv2_driver.NeutronV2Driver</screen>
      <para>If you have Nova and Neutron installed, you configure Congress as:</para>
      <screen><?dbsuse-fo font-size="8pt"?>drivers = congress.datasources.neutronv2_driver.NeutronV2Driver,congress.datasources.nova_driver.NovaDriver</screen>
    </section>
    <section>
      <title>2.2 Driver configuration (DEPRECATED) and writing policy</title>
      <para>Once the driver code is in place, you can use it to create a <literal>datasource</literal> whose
                    data is available to Congress policies.  To create a datasource, you use the API and
                    provide a unique name (the name you will use in policy to refer to the service), the
                    name of the datasource driver you want to use, and additional connection details
                    needed by your service (such as an IP and a username/password).</para>
      <para>For example, using the Congress CLI, you can create a datasource named ‘neutron_test’ using the
                    ‘neutronv2’ driver:</para>
      <screen>$ openstack congress datasource create &lt;driver_name&gt; &lt;datasource_name&gt;
   --config username=&lt;username&gt;
   --config password=&lt;password&gt;
   --config tenant_name=&lt;tenant&gt;
   --config auth_url=&lt;url_authentication&gt;

$ openstack congress datasource create neutronv2 neutron_test
  --config username=neutron
  --config password=password
  --config tenant_name=cloudservices
  --config auth_url=http://10.10.10.10:5000/v2.0</screen>
      <para>And if you had a second instance of Neutron running to manage
                    your production network, you could create a second datasource (named say ‘neutron_prod’)
                    using the neutronv2 driver so that you could write policy over both instances of Neutron.</para>
      <para>When you write policy, you would use the name ‘neutron_test:ports’ to reference the ‘ports’
                    table generated by the ‘neutron_test’ datasource, and you use ‘neutron_test:networks’ to
                    reference the ‘networks’ table generated by the ‘neutron_test’ datasource.  Similarly,
                    you use ‘neutron_prod:ports’ and ‘neutron_prod:networks’ to reference the
                    tables populated by the ‘neutron_prod’ datasource.
                    (More details about writing policy can be found in the
                    <xref linkend="policy"/> section.)</para>
    </section>
  </section>
  <section>
    <title>3. Currently Supported Drivers</title>
    <para>Congress currently has drivers for each of the following services.  Each driver
                has a differing degree of coverage for the available API calls.</para>
    <itemizedlist>
      <listitem>
        <para>OpenStack Aodh</para>
      </listitem>
      <listitem>
        <para>OpenStack Ceilometer</para>
      </listitem>
      <listitem>
        <para>OpenStack Cinder</para>
      </listitem>
      <listitem>
        <para>OpenStack Glance (v2)</para>
      </listitem>
      <listitem>
        <para>OpenStack Heat</para>
      </listitem>
      <listitem>
        <para>OpenStack Ironic</para>
      </listitem>
      <listitem>
        <para>OpenStack Keystone (v2 &amp; v3)</para>
      </listitem>
      <listitem>
        <para>OpenStack Monasca</para>
      </listitem>
      <listitem>
        <para>OpenStack Murano</para>
      </listitem>
      <listitem>
        <para>OpenStack Neutron (v2)</para>
      </listitem>
      <listitem>
        <para>OpenStack Nova</para>
      </listitem>
      <listitem>
        <para>OpenStack Swift</para>
      </listitem>
      <listitem>
        <para>Cloud Foundry</para>
      </listitem>
      <listitem>
        <para>Plexxi</para>
      </listitem>
      <listitem>
        <para>vCenter</para>
      </listitem>
      <listitem>
        <para>OPNFV Doctor</para>
      </listitem>
    </itemizedlist>
    <para>Using the API or CLI, you can review the list of tables and columns that a driver supports.
                Roughly, you can think of each table as a collection of objects (like networks or servers),
                and the columns of that table as the attributes of those objects (like name, status, or ID).
                The value of each row-column entry is a (Python) string or number. If
                the attribute as returned by the API call is a complex object, that object
                is flattened into its own table (or tables).</para>
    <para>For example:</para>
    <screen>$ openstack congress datasource schema show nova
+--------------+------------------------------------------------+
| table        | columns                                        |
+--------------+------------------------------------------------+
| flavors      | {'name': 'id', 'description': 'None'},         |
|              | {'name': 'name', 'description': 'None'},       |
|              | {'name': 'vcpus', 'description': 'None'},      |
|              | {'name': 'ram', 'description': 'None'},        |
|              | {'name': 'disk', 'description': 'None'},       |
|              | {'name': 'ephemeral', 'description': 'None'},  |
|              | {'name': 'rxtx_factor', 'description': 'None'} |
|              |                                                |
| hosts        | {'name': 'host_name', 'description': 'None'},  |
|              | {'name': 'service', 'description': 'None'},    |
|              | {'name': 'zone', 'description': 'None'}        |
|              |                                                |
| floating_IPs | {'name': 'fixed_ip', 'description': 'None'},   |
|              | {'name': 'id', 'description': 'None'},         |
|              | {'name': 'ip', 'description': 'None'},         |
|              | {'name': 'host_id', 'description': 'None'},    |
|              | {'name': 'pool', 'description': 'None'}        |
|              |                                                |
| servers      | {'name': 'id', 'description': 'None'},         |
|              | {'name': 'name', 'description': 'None'},       |
|              | {'name': 'host_id', 'description': 'None'},    |
|              | {'name': 'status', 'description': 'None'},     |
|              | {'name': 'tenant_id', 'description': 'None'},  |
|              | {'name': 'user_id', 'description': 'None'},    |
|              | {'name': 'image_id', 'description': 'None'},   |
|              | {'name': 'flavor_id', 'description': 'None'}   |
|              |                                                |
+--------------+------------------------------------------------+</screen>
  </section>
  <section>
    <title>4. Writing a Datasource Driver</title>
    <para>This section is a tutorial for those of you interested in writing your own
                datasource driver.  It can be safely skipped otherwise.</para>
    <section>
      <title>4.1 Implementing a Datasource Driver</title>
      <para>All the Datasource drivers extend the code found in:</para>
      <screen>congress/datasources/datasource_driver.py</screen>
      <para>Typically, you will create a subclass of
                    <literal>datasource_driver.PollingDataSourceDriver</literal> or
                    <literal>datasource_driver.PushedDataSourceDriver</literal> depending on the type of your
                    datasource driver. Each instance of that class will correspond to a different
                    service using that driver.</para>
      <para>The following steps detail how to implement a polling datasource driver.</para>
      <procedure>
        <step>
          <para>Create a new Python module <literal>congress/datasources/new_driver.py</literal></para>
        </step>
        <step>
          <para>Create a subclass of :code: <literal>PollingDataSourceDriver</literal>.</para>
        </step>
      </procedure>
      <para>
        <literal>from congress.datasources.datasource_driver import PollingDataSourceDriver</literal>
      </para>
      <para>
        <literal>class MyDriver(PollingDataSourceDriver)</literal>
      </para>
      <procedure>
        <step>
          <para>Implement the constructor <literal>MyDriver.__init__()</literal></para>
        </step>
      </procedure>
      <para>
        <literal>def __init__(name, args)</literal>
      </para>
      <para>You must call the DataSourceDriver’s constructor.</para>
      <para>
        <literal>super(MyDriver, self).__init__(name, args)</literal>
      </para>
      <procedure>
        <step>
          <para>Implement the function <literal>MyDriver.update_from_datasource()</literal></para>
        </step>
      </procedure>
      <para>
        <literal>def update_from_datasource(self)</literal>
      </para>
      <para>This function is called to update <literal>self.state</literal> to reflect the new
                        state of the service.  <literal>self.state</literal> is a dictionary that maps a
                        tablename (as a string) to a set of tuples (to a collection of tables).
                        Each tuple element must be either a number or string.  This function
                        implements the polling logic for the service.</para>
      <para>5. By convention, it is useful for debugging purposes to include a
                    <literal>main</literal> that calls update_from_datasource, and prints out the raw
                    API results along with the tables that were generated.</para>
      <para>To install and test the newly written driver, please follow the new driver
                    installation procedure mentioned in :ref: <literal>Driver installation &lt;driver-installation&gt;</literal>
                    section.</para>
    </section>
    <section>
      <title>4.2 Converting API results into Tables</title>
      <para>Since Congress requires the state of each dataservice to be represented as
                    tables, we must convert the results of each API call (which may be comprised
                    of dictionaries, lists, dictionaries embedded within lists, etc.) into tables.</para>
      <section>
        <title>4.2.1 Convenience translators</title>
        <para>Congress provides a translation method to make the translation from API
                        results into tables convenient.  The translation method takes a description of
                        the API data structure, and converts objects of that structure into rows of
                        one or more tables (depending on the data structure).  For example, this is a
                        partial snippet from the Neutron driver:</para>
        <screen>networks_translator = {
    'translation-type': 'HDICT',
    'table-name': 'networks',
    'selector-type': 'DICT_SELECTOR',
    'field-translators':
        ({'fieldname': 'id', 'translator': value_trans},
         {'fieldname': 'name', 'translator': value_trans},
         {'fieldname': 'tenant_id', 'translator': value_trans},
         {'fieldname': 'subnets', 'col': 'subnet_group_id',
          'translator': {'translation-type': 'LIST',
                         'table-name': 'networks.subnets',
                         'id-col': 'subnet_group_id',
                         'val-col': 'subnet',
                         'translator': value_trans}})}</screen>
        <para>This networks_translator describes a python dictionary data structure that
                        contains four keys: id, name, tenant_id, and subnets.  The value for the
                        subnets key is a list of subnet_group_ids each of which is a number.  For
                        example:</para>
        <variablelist>
          <varlistentry>
            <term>{ “id”: 1234,</term>
            <listitem>
              <para>“name”: “Network Foo”,
                                        “tenant_id”: 5678,
                                        “subnets”: [ 100, 101 ] }</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>Given the networks_translator description, the translator creates two tables.
                        The first table is named “networks” with a column for name, subnets,
                        tenant_id, and id.  The second table will be named “networks.subnet” and will
                        contain two columns, one containing the subnet_group_id, and the second
                        containing an ID that associates the row in the network to the rows in the
                        networks.subnets table.</para>
        <para>To use the translation methods, the driver defines a translator such as
                        networks_translator and then passes the API response objects to
                        translate_objs() which is defined in congress/datasources/datasource_driver.py
                        See congress/datasources/neutron_driver.py as an example.</para>
      </section>
      <section>
        <title>4.2.2 Custom data conversion</title>
        <para>The convenience translators may be insufficient in some cases, for example,
                        the data source may provide data in an unusual format, the convenience
                        translators may be inefficient, or the fixed translation method may result in
                        an unsuitable table schema.  In such cases, a driver may need to implement its
                        own translation.  In those cases, we have a few recommendations.</para>
        <para><emphasis role="bold">Recommendation 1: Row = object.</emphasis> Typically an API call will return a
                        collection of objects (e.g. networks, virtual machines, disks).  Conceptually
                        it is convenient to represent each object with a row in a table.  The columns
                        of that row are the attributes of each object.  For example, a table of all
                        virtual machines will have columns for memory, disk, flavor, and image.</para>
        <para>Table: virtual_machine</para>
        <informaltable>
          <tgroup cols="5">
            <colspec colname="c1" colwidth="41.8*"/>
            <colspec colname="c2" colwidth="6.6*"/>
            <colspec colname="c3" colwidth="4.4*"/>
            <colspec colname="c4" colwidth="6.6*"/>
            <colspec colname="c5" colwidth="40.7*"/>
            <thead>
              <row>
                <entry>
                  <para>ID</para>
                </entry>
                <entry>
                  <para>Memory</para>
                </entry>
                <entry>
                  <para>Disk</para>
                </entry>
                <entry>
                  <para>Flavor</para>
                </entry>
                <entry>
                  <para>Image</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>66dafde0-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>256GB</para>
                </entry>
                <entry>
                  <para>1TB</para>
                </entry>
                <entry>
                  <para>1</para>
                </entry>
                <entry>
                  <para>83e31d4c-a49c-11e3-be40-425861b86ab6</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>73e31d4c-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>10GB</para>
                </entry>
                <entry>
                  <para>2TB</para>
                </entry>
                <entry>
                  <para>2</para>
                </entry>
                <entry>
                  <para>93e31d4c-a49c-11e3-be40-425861b86ab6</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para><emphasis role="bold">Recommendation 2. Avoid wide tables.</emphasis>  Wide tables (i.e. tables with many
                        columns) are hard to use for a policy-writer.  Breaking such tables up into
                        smaller ones is often a good idea.  In the above example, we could create 4
                        tables with 2 columns instead of 1 table with 5 columns.</para>
        <para>Table: virtual_machine.memory</para>
        <informaltable>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="86.4*"/>
            <colspec colname="c2" colwidth="13.6*"/>
            <thead>
              <row>
                <entry>
                  <para>ID</para>
                </entry>
                <entry>
                  <para>Memory</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>66dafde0-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>256GB</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>73e31d4c-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>10GB</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>Table: virtual_machine.disk</para>
        <informaltable>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="86.4*"/>
            <colspec colname="c2" colwidth="13.6*"/>
            <thead>
              <row>
                <entry>
                  <para>ID</para>
                </entry>
                <entry>
                  <para>Disk</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>66dafde0-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>1TB</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>73e31d4c-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>2TB</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>Table: virtual_machine.flavor</para>
        <informaltable>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="86.4*"/>
            <colspec colname="c2" colwidth="13.6*"/>
            <thead>
              <row>
                <entry>
                  <para>ID</para>
                </entry>
                <entry>
                  <para>Flavor</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>66dafde0-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>1</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>73e31d4c-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>2</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>Table: virtual_machine.image</para>
        <informaltable>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50.7*"/>
            <colspec colname="c2" colwidth="49.3*"/>
            <thead>
              <row>
                <entry>
                  <para>ID</para>
                </entry>
                <entry>
                  <para>Image</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>66dafde0-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>83e31d4c-a49c-11e3-be40-425861b86ab6</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>73e31d4c-a49c-11e3-be40-425861b86ab6</para>
                </entry>
                <entry>
                  <para>93e31d4c-a49c-11e3-be40-425861b86ab6</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para><emphasis role="bold">Recommendation 3. Try these design patterns.</emphasis> Below we give a few design
                        patterns.  Notice that when an object has an attribute whose value is a
                        structured object itself (e.g. a list of dictionaries), we must recursively
                        flatten that subobject into tables.</para>
        <itemizedlist>
          <listitem>
            <para>A List of dictionary converted to tuples</para>
            <para>Original data:</para>
            <screen>[{'key1':'value1','key2':'value2'},
 {'key1':'value3','key2':'value4'}
]</screen>
            <para>Tuple:</para>
            <screen>[('value1', 'value2'),
 ('value3', 'value4')
]</screen>
          </listitem>
          <listitem>
            <para>List of Dictionary with a nested List</para>
            <para>Original data:</para>
            <screen>[{'key1':'value1','key2':['v1','v2']},
 {'key1':'value2','key2':['v3','v4']}
]</screen>
            <para>Tuple:</para>
            <screen>[('value1', 'uuid1'),
 ('value1', 'uuid2'),
 ('value2', 'uuid3'),
 ('value2', 'uuid4')
]

[('uuid1', 'v1'),
 ('uuid2', 'v2'),
 ('uuid3', 'v3'),
 ('uuid4', 'v4')
]</screen>
            <para><emphasis>Note</emphasis> : uuid* are congress generated uuids</para>
          </listitem>
          <listitem>
            <para>List of Dictionary with a nested dictionary</para>
            <para>Original data:</para>
            <screen>[{'key1':'value1','key2':{'k1':'v1'}},
 {'key1':'value2','key2':{'k1':'v2'}}
]</screen>
            <para>Tuple:</para>
            <screen>[('value1', 'uuid1'),
 ('value2', 'uuid2')
]

[('uuid1', 'k1', 'v1'),
 ('uuid2', 'k1', 'v2'),
]</screen>
            <para><emphasis>Note</emphasis> : uuid* are congress generated uuids</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
    <section>
      <title>4.3 Writing a Datasource driver test</title>
      <para>Once you’ve written a driver, you’ll want to add a unit test for it.  To help, this section describes how the unit test for the Glance driver works.  Here are the relevant files.</para>
      <itemizedlist>
        <listitem>
          <para>Driver code: congress/datasources/glance_v2driver.py</para>
        </listitem>
        <listitem>
          <para>Test code: congress/tests/datasources/test_glancev2_driver.py  (appearing in full at the end of this section)</para>
        </listitem>
      </itemizedlist>
      <para>The test code has two methods: setUp() and test_update_from_datasource().</para>
      <section>
        <title>4.3.1 Glance setup</title>
        <para>We begin our description with the setUp() method of the test.</para>
        <screen language="python">def setUp(self):</screen>
        <para>First the test creates a fake (actually a mock) Keystone.  Most clients talk to Keystone, so having a fake one seems to be necessary to make the Glance client work properly.</para>
        <screen language="python">self.keystone_client_p = mock.patch(
    "keystoneclient.v2_0.client.Client")
self.keystone_client_p.start()</screen>
        <para>Next the test creates a fake Glance client.  Glance is an OpenStack service that stores (among other things) operating system Images that you can use to create a new VM.    The Glance datasource driver makes a call to &lt;glance-client&gt;.images.list() to retrieve the list of those images, and then turns that list of images into tables.  The test creates a fake Glance client so it can control the return value of &lt;glance-client&gt;.images.list().</para>
        <screen language="python">self.glance_client_p = mock.patch("glanceclient.v2.client.Client")
self.glance_client_p.start()</screen>
        <para>Next the test instantiates the GlanceV2Driver class, which contains the code for the Glance driver.  Passing ‘poll_time’ as 0 is probably unnecessary here, but it tells the driver not to poll automatically.  Passing ‘client’ is important because it tells the GlanceV2Driver class to use a mocked version of the Glance client instead of creating its own.</para>
        <screen language="python">args = helper.datasource_openstack_args()
args['poll_time'] = 0
args['client'] = mock.MagicMock()
self.driver = glancev2_driver.GlanceV2Driver(args=args)</screen>
        <para>Next the test defines which value it wants &lt;glance-client&gt;.images.list() to return.  The test itself will check if the Glance driver code properly translates this return value into tables.  So this is the actual input to the test.   Either you can write this by hand, or you can run the heat-client and print out the results.</para>
        <screen language="python">self.mock_images = {'images': [
    {u'checksum': u'9e486c3bf76219a6a37add392e425b36',
     u'container_format': u'bare',
     u'created_at': u'2014-10-01T20:28:08Z’,
     ...</screen>
      </section>
      <section>
        <title>4.3.2 Glance test</title>
        <para>test_update_from_datasource() is the actual test, where we have the datasource driver grab the list of Glance images and translate them to tables.  The test runs the update_from_datasource() method like normal except it ensures the return value of &lt;glance-client&gt;.images.list() is self.mock_images.</para>
        <screen language="python">def test_update_from_datasource(self):</screen>
        <para>The first thing the method does is set the return value of self.driver.glance.images.list() to self.mock_images[‘images’].  Then it calls update_from_datasource() in the usual way, which translates self.mock_images[‘images’] into tables and stores the result into the driver’s self.state dictionary.</para>
        <screen language="python">with mock.patch.object(self.driver.glance.images, "list") as img_list:
    img_list.return_value = self.mock_images['images']
    self.driver.update_from_datasource()</screen>
        <para>Next the test defines the tables that update_from_datasource() should construct.  Actually, the test defines the expected value of Glance’s self.state when update_from_datasource() finishes.  Remember that self.state is a dictionary mapping a table name to the set of tuples that belong to the table.  For Glance, there’s just one table: ‘images’, and so the expected self.state is a dictionary with one key ‘images’ and one value: a set of tuples.</para>
        <screen language="python">expected = {'images': set([
    (u'6934941f-3eef-43f7-9198-9b3c188e4aab',
     u'active',
     u'cirros-0.3.2-x86_64-uec',
     u'ami',
     u'2014-10-01T20:28:06Z',
     u'2014-10-01T20:28:07Z',
     u'ami',
     u'4dfdcf14a20940799d89c7a5e7345978',
     'False',
     0,
     0,
     u'4eada48c2843d2a262c814ddc92ecf2c',
     25165824,
     u'/v2/images/6934941f-3eef-43f7-9198-9b3c188e4aab/file',
     u'15ed89b8-588d-47ad-8ee0-207ed8010569',
     u'c244d5c7-1c83-414c-a90d-af7cea1dd3b5',
     u'/v2/schemas/image',
     u'public'),
     ...</screen>
        <para>At this point in the test, update_from_datasource() has already been run, so all it does is check that the driver’s self.state has the expected value.</para>
        <screen language="python">self.assertEqual(self.driver.state, expected)</screen>
      </section>
      <section>
        <title>4.3.3 Glance test code in full</title>
        <screen language="python">import mock

from congress.datasources import glancev2_driver
from congress.tests import base
from congress.tests import helper


class TestGlanceV2Driver(base.TestCase):

    def setUp(self):
        super(TestGlanceV2Driver, self).setUp()
        self.keystone_client_p = mock.patch(
            "keystoneclient.v2_0.client.Client")
        self.keystone_client_p.start()
        self.glance_client_p = mock.patch("glanceclient.v2.client.Client")
        self.glance_client_p.start()

        args = helper.datasource_openstack_args()
        args['poll_time'] = 0
        args['client'] = mock.MagicMock()
        self.driver = glancev2_driver.GlanceV2Driver(args=args)

        self.mock_images = {'images': [
            {u'checksum': u'9e486c3bf76219a6a37add392e425b36',
             u'container_format': u'bare',
             u'created_at': u'2014-10-01T20:28:08Z',
             u'disk_format': u'qcow2',
             u'file': u'/v2/images/c42736e7-8b09-4906-abd2-d6dc8673c297/file',
             u'id': u'c42736e7-8b09-4906-abd2-d6dc8673c297',
             u'min_disk': 0,
             u'min_ram': 0,
             u'name': u'Fedora-x86_64-20-20140618-sda',
             u'owner': u'4dfdcf14a20940799d89c7a5e7345978',
             u'protected': False,
             u'schema': u'/v2/schemas/image',
             u'size': 209649664,
             u'status': u'active',
             u'tags': ['type=xen2', 'type=xen'],
             u'updated_at': u'2014-10-01T20:28:09Z',
             u'visibility': u'public'},
            {u'checksum': u'4eada48c2843d2a262c814ddc92ecf2c',
             u'container_format': u'ami',
             u'created_at': u'2014-10-01T20:28:06Z',
             u'disk_format': u'ami',
             u'file': u'/v2/images/6934941f-3eef-43f7-9198-9b3c188e4aab/file',
             u'id': u'6934941f-3eef-43f7-9198-9b3c188e4aab',
             u'kernel_id': u'15ed89b8-588d-47ad-8ee0-207ed8010569',
             u'min_disk': 0,
             u'min_ram': 0,
             u'name': u'cirros-0.3.2-x86_64-uec',
             u'owner': u'4dfdcf14a20940799d89c7a5e7345978',
             u'protected': False,
             u'ramdisk_id': u'c244d5c7-1c83-414c-a90d-af7cea1dd3b5',
             u'schema': u'/v2/schemas/image',
             u'size': 25165824,
             u'status': u'active',
             u'tags': [],
             u'updated_at': u'2014-10-01T20:28:07Z',
             u'visibility': u'public'}]}

    def test_update_from_datasource(self):
        with mock.patch.object(self.driver.glance.images, "list") as img_list:
            img_list.return_value = self.mock_images['images']
            self.driver.update_from_datasource()
        expected = {'images': set([
            (u'6934941f-3eef-43f7-9198-9b3c188e4aab',
             u'active',
             u'cirros-0.3.2-x86_64-uec',
             u'ami',
             u'2014-10-01T20:28:06Z',
             u'2014-10-01T20:28:07Z',
             u'ami',
             u'4dfdcf14a20940799d89c7a5e7345978',
             'False',
             0,
             0,
             u'4eada48c2843d2a262c814ddc92ecf2c',
             25165824,
             u'/v2/images/6934941f-3eef-43f7-9198-9b3c188e4aab/file',
             u'15ed89b8-588d-47ad-8ee0-207ed8010569',
             u'c244d5c7-1c83-414c-a90d-af7cea1dd3b5',
             u'/v2/schemas/image',
             u'public'),
            (u'c42736e7-8b09-4906-abd2-d6dc8673c297',
             u'active',
             u'Fedora-x86_64-20-20140618-sda',
             u'bare',
             u'2014-10-01T20:28:08Z',
             u'2014-10-01T20:28:09Z',
             u'qcow2',
             u'4dfdcf14a20940799d89c7a5e7345978',
             'False',
             0,
             0,
             u'9e486c3bf76219a6a37add392e425b36',
             209649664,
             u'/v2/images/c42736e7-8b09-4906-abd2-d6dc8673c297/file',
             'None',
             'None',
             u'/v2/schemas/image',
             u'public')]),
            'tags': set([
                (u'c42736e7-8b09-4906-abd2-d6dc8673c297', 'type=xen'),
                (u'c42736e7-8b09-4906-abd2-d6dc8673c297', 'type=xen2')])}
        self.assertEqual(self.driver.state, expected)</screen>
      </section>
    </section>
  </section>
</section>
