<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:id="policy">
  <title>Policy</title>
  <section>
    <title>1. What Does a Policy Look Like</title>
    <para>A policy describes how services (either individually or as a whole)
                ought to behave.  More specifically, a policy describes which
                <emphasis role="bold">states</emphasis> of the cloud are permitted and which are not.  Or a policy describes
                which <emphasis role="bold">actions</emphasis> to take in each state of the cloud, in order to
                transition the cloud to one of those permitted states.  For example
                For example,
                a policy might simply state that the minimum password length on all
                systems is eight characters, or a policy might state that if
                the minimum password length on some system is less than 8 that the
                minimum length should be reset to 8.</para>
    <para>In both cases, the policy relies on knowing the state of the cloud.
                The state of the cloud is the amalgamation of the states of all the
                services running in the cloud.  In Congress, the state of each service
                is represented as a collection of tables (see <xref linkend="cloudservices"/>).
                The policy language determines whether any violation exists given the
                content of the state tables.</para>
    <para>For example, one desirable policy is that each Neutron port has at
                most one IP address.  That means that the following table mapping port
                id to ip address with the schema “port(id, ip)” is permitted by the
                policy.</para>
    <informaltable>
      <tgroup cols="2">
        <colspec colname="c1" colwidth="79.2*"/>
        <colspec colname="c2" colwidth="20.8*"/>
        <thead>
          <row>
            <entry>
              <para>ID</para>
            </entry>
            <entry>
              <para>IP</para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>“66dafde0-a49c-11e3-be40-425861b86ab6”</para>
            </entry>
            <entry>
              <para>“10.0.0.1”</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>“73e31d4c-e89b-12d3-a456-426655440000”</para>
            </entry>
            <entry>
              <para>“10.0.0.3”</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>Whereas, the following table is a violation.</para>
    <informaltable>
      <tgroup cols="2">
        <colspec colname="c1" colwidth="79.2*"/>
        <colspec colname="c2" colwidth="20.8*"/>
        <thead>
          <row>
            <entry>
              <para>ID</para>
            </entry>
            <entry>
              <para>IP</para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>“66dafde0-a49c-11e3-be40-425861b86ab6”</para>
            </entry>
            <entry>
              <para>“10.0.0.1”</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>“66dafde0-a49c-11e3-be40-425861b86ab6”</para>
            </entry>
            <entry>
              <para>“10.0.0.2”</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>“73e31d4c-e89b-12d3-a456-426655440000”</para>
            </entry>
            <entry>
              <para>“10.0.0.3”</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>This is the policy written in Congress’s policy language:</para>
    <variablelist>
      <varlistentry>
        <term>error(port_id, ip1, ip2) :-</term>
        <listitem>
          <para>port(port_id, ip1),
                            port(port_id, ip2),
                            not equal(ip1, ip2);</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>Note that the policy above does not mention specific table content;
                instead it describes the general condition of tables.  The policy says
                that for every row in the port table, no two rows should have the same
                ID and different IPs.</para>
    <para>This example verifies a single table within Neutron, but a
                policy can use many tables as well.  Those tables
                might all come from the same cloud service (e.g. all the tables might be
                Neutron tables), or the tables may come from different cloud services (e.g.
                some tables from Neutron, others from Nova).</para>
    <para>For example, if we have the following table schemas from Nova, Neutron, and
                ActiveDirectory, we could write a policy that says every network connected to a VM must
                either be public or owned by someone in the same group as the VM owner.:</para>
    <screen>error(vm, network) :-
  nova:virtual_machine(vm)
  nova:network(vm, network)
  nova:owner(vm, vm_owner)
  neutron:owner(network, network_owner)
  not neutron:public_network(network)
  not same_group(vm_owner, network_owner)

same_group(user1, user2) :-
  ad:group(user1, group)
  ad:group(user2, group)</screen>
    <para>And if one of these errors occurs, the right solution is to disconnect
                the offending network (as opposed to deleting the VM, changing the owner,
                or any of the other feasible options):</para>
    <screen>execute[neutron:disconnectNetwork(vm, network)] :-
  error(vm, network)</screen>
    <para>The language Congress supports for expressing policy is called Datalog,
                a declarative language derived from SQL and first-order logic that has been
                the subject of research and development for decades.</para>
  </section>
  <section>
    <title>2. Datalog Policy Language</title>
    <para>As a policy writer, your goal is to define the contents of the <emphasis>error</emphasis> table, and
                in so doing to describe exactly those conditions that must be true
                when policy is being obeyed.</para>
    <para>As a policy writer, you can also describe which actions Congress should take when policy
                is being violated by using the <emphasis>execute</emphasis> operator and thinking of the action
                to be executed as if it were a table itself.</para>
    <para>Either when defining policy directly or describing the conditions under which
                actions should be executed to eliminate policy violations, it is often useful
                to use higher-level concepts than
                the cloud services provide natively.  Datalog allows us to do this by defining
                new tables (higher-level concepts) in terms of existing tables (lower-level
                concepts) by writing <emphasis>rules</emphasis>.  For example, OpenStack does not tell us directly
                which VMs are connected to the internet; rather, it provides a collection of
                lower-level API calls from which we can derive that information.  Using Datalog
                we can define a table that lists all of the VMs connected to the internet in
                terms of the tables that Nova/Neutron support directly.  As another example, if
                Keystone stores some collection of user groups and Active Directory stores a
                collection of user groups, we might want to create a new table that represents
                all the groups from either Keystone or Active Directory.</para>
    <para>Datalog has a collection of core features for manipulating tables, and it
                has a collection of more advanced features that become important when you
                go beyond toy examples.</para>
    <section>
      <title>2.1 Core Datalog Features</title>
      <para>Since Datalog is entirely concerned with tables, it’s not surprising that
                    Datalog allows us to represent concrete tables directly in the language.</para>
      <para><emphasis role="bold">Concrete tables.</emphasis>  Suppose we want to use Datalog to represent a Neutron
                    table that lists which ports have been assigned which IPs, such as the one
                    shown below.</para>
      <para>Table: neutron:port_ip</para>
      <informaltable>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="79.2*"/>
          <colspec colname="c2" colwidth="20.8*"/>
          <thead>
            <row>
              <entry>
                <para>ID</para>
              </entry>
              <entry>
                <para>IP</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>“66dafde0-a49c-11e3-be40-425861b86ab6”</para>
              </entry>
              <entry>
                <para>“10.0.0.1”</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>“66dafde0-a49c-11e3-be40-425861b86ab6”</para>
              </entry>
              <entry>
                <para>“10.0.0.2”</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>“73e31d4c-e89b-12d3-a456-426655440000”</para>
              </entry>
              <entry>
                <para>“10.0.0.3”</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>To represent this table, we write the following Datalog:</para>
      <screen>neutron:port_ip("66dafde0-a49c-11e3-be40-425861b86ab6", "10.0.0.1")
neutron:port_ip("66dafde0-a49c-11e3-be40-425861b86ab6", "10.0.0.2")
neutron:port_ip("73e31d4c-e89b-12d3-a456-426655440000", "10.0.0.3")</screen>
      <para>Each of the Datalog statements above is called a <emphasis>ground atom</emphasis> (or <emphasis>ground
                        fact</emphasis>).  A ground atom takes the form <literal>&lt;tablename&gt;(arg1, ..., argn)</literal>,
                    where each <literal>argi</literal> is either a double-quoted Python string or a Python
                    number.</para>
      <para><emphasis role="bold">Basic rules</emphasis> The real power of Datalog is that it allows you to write recipes
                    for constructing new tables out of existing tables, regardless which rows are
                    in those existing tables.</para>
      <para>To create a new table out of an existing table, we write Datalog <emphasis>rules</emphasis>.
                    A <emphasis>rule</emphasis> is a simple if-then statement, where the <emphasis>if</emphasis> part is called the
                    <emphasis>head</emphasis> and the <emphasis>then</emphasis> part is called the <emphasis>body</emphasis>.  The head is always a single
                    Datalog atom.  The body is an AND of several possibly negated Datalog atoms.
                    OR is accomplished by writing multiple rules with the same table in the head.</para>
      <para>Suppose we want to create a new table <literal>has_ip</literal> that is just a list of
                    the Neutron ports that have been assigned at least one IP address.  We want
                    our table to work regardless what IDs and IPs appear in the neutron:port_ip
                    table so we use variables in place of strings/numbers.  Variables have the
                    same meaning as in algebra: they are placeholders for any value.
                    (Syntactically, a variable is any symbol other than a number or a string.):</para>
      <screen>has_ip(x) :- neutron:port_ip(x, y)</screen>
      <para>This rule says that a port <emphasis>x</emphasis> belongs to the <emphasis>has_ip</emphasis> table if there exists
                    some IP <emphasis>y</emphasis> such that row <emphasis>&lt;x,y&gt;</emphasis> belongs to the <emphasis>neutron:port</emphasis> table.
                    Conceptually, this rule says to look at all of the ground atoms for the
                    neutron:port_ip table, and for each one assign <emphasis>x</emphasis> to the port UUID and <emphasis>y</emphasis>
                    to the IP.  Then create a row in the <emphasis>has_ip</emphasis> table for <emphasis>x</emphasis>.  This rule when
                    applied to the neutron:port_ip table shown above would generate the following
                    table:</para>
      <screen>has_ip("66dafde0-a49c-11e3-be40-425861b86ab6")
has_ip("73e31d4c-e89b-12d3-a456-426655440000")</screen>
      <para>Notice here that there are only 2 rows in <emphasis>has_ip</emphasis> despite there being 3 rows
                    in <emphasis>neutron:port_ip</emphasis>.  That happens because one of the ports in
                    neutron:port_ip has been assigned 2 distinct IPs.</para>
      <para><emphasis role="bold">AND operator</emphasis> As a slightly more complex example, we could define a table
                    <emphasis>same_ip</emphasis> that lists all the pairs of ports that are assigned the same IP.:</para>
      <screen>same_ip(port1, port2) :- neutron:port_ip(port1, ip), neutron:port_ip(port2, ip)</screen>
      <para>This rule says that the row &lt;port1, port2&gt; must be included in the
                    <emphasis>same_ip</emphasis> table if there exists some <emphasis>ip</emphasis> where both <emphasis>&lt;port1, ip&gt;</emphasis> and <emphasis>&lt;port2, ip&gt;</emphasis>
                    are rows in the <emphasis>neutron:port</emphasis> table (where notice that <emphasis>ip</emphasis> is the same in the two
                    rows).  Notice here the variable <emphasis>ip</emphasis> appears in two different places in the body,
                    thereby requiring the value assigned to that variable be the same in both cases.
                    This is called a <emphasis>join</emphasis> in the realm of relational databases and SQL.</para>
      <para><emphasis role="bold">NOT operator</emphasis> As another example, suppose we want a list of all the ports
                    that have NOT been assigned any IP address.  We can use the <emphasis>not</emphasis> operator to
                    check if a row fails to belong to a table.</para>
      <screen language="none">no_ip(port) :- neutron:port(port), not has_ip(port)</screen>
      <para>There are special restrictions that you must be aware of when using <emphasis>not</emphasis>.
                    See the next section for details.</para>
      <para><emphasis role="bold">OR operator</emphasis>. Some examples require an OR, which in Datalog means writing
                    multiple rules with the same table in the head.   Imagine we have two tables
                    representing group membership information from two different services:
                    Keystone and Active Directory.  We can create a new table <emphasis>group</emphasis> that says a
                    person is a member of a group if she is a member of that group either according
                    to Keystone or according to Active Directory.  In Datalog we create this table
                    by writing two rules.:</para>
      <screen>group(user, grp) :- ad:group(user, grp)
group(user, grp) :- keystone:group(user, grp)</screen>
      <para>These rules happen to have only one atom in each of their bodies, but there is
                    no requirement for that.</para>
    </section>
    <section>
      <title>2.2 Extended Datalog Features</title>
      <para>In addition writing basic rules with and/or/not, the version of Datalog used
                    by Congress includes the features described in this section.</para>
      <para><emphasis role="bold">Builtins</emphasis>. Often we want to write rules that are conditioned on things that
                    are difficult or impossible to define within Datalog.  For example, we might
                    want to create a table that lists all of the virtual machines that have at
                    least 100 GB of memory.  To write that rule, we would need a way to check
                    if the memory of a given machine is greater-than 100 or not.
                    Basic arithmetic, string manipulation, etc. are operations
                    that are built into Datalog, but they look as though they are just ordinary
                    tables.  Below the <emphasis>gt</emphasis> is a builtin table implementing greater-than:</para>
      <screen>plenty_of_memory(vm) :- nova:virtual_machine.memory(vm, mem), gt(mem, 100)</screen>
      <para>In a later section we include the list of available builtins.</para>
      <para><emphasis role="bold">Column references</emphasis>. Some tables have 5+ columns, and
                    when tables have that many columns writing rules can be awkward.  Typically when
                    we write a rule, we only want 1 or 2 columns, but if there are 10 columns, then
                    we end up needing to invent variable names to fill all the unneeded columns.</para>
      <para>For example, Neutron’s <emphasis>ports</emphasis> table has 10 columns.  If you want to create a
                    table that includes just the port IDs (as we used above), you would write the
                    following rule:</para>
      <screen>port(id) :-
  neutron:ports(id, tenant_id, name, network_id, mac_address, admin_state_up,
                status, device_owner, fixed_ips, security_groups)</screen>
      <para>To simplify such rules, we can write rules that reference only those columns
                    that we care about by using the column’s name.  Since the name of the first
                    column of the <emphasis>neutron:ports</emphasis> table is “ID”, we can write the rule above as
                    follows:</para>
      <screen>port(x) :- neutron:ports(id=x)</screen>
      <para>You can only use these column references for tables provided by cloud services
                    (since Congress only knows the column names for the cloud service tables).
                    Column references like these are translated automatically to the version
                    without column-references, which is something you may notice from time to
                    time.</para>
      <para><emphasis role="bold">Table hierarchy</emphasis>.   The tables in the body of rules can either be the
                    original cloud-service tables or tables that are defined by other rules
                    (with some limitations, described in the next section).  We can think of a
                    Datalog policy as a hierarchy of tables, where each table is defined in
                    terms of the tables at a lower level in the hierarchy.  At the bottom of that
                    hierarchy are the original cloud-service tables representing the state of the
                    cloud.</para>
      <para><emphasis role="bold">Order irrelevance</emphasis>.  One noteworthy feature of Datalog is that the order
                    in which rules appear is irrelevant.  The rows that belong to a table are
                    the minimal ones required by the rules if we were to compute their contents
                    starting with the cloud-service tables (whose contents are given to us) and
                    working our way up the hierarchy of tables.  For more details, search the web
                    for the term <emphasis>stratified Datalog semantics</emphasis>.</para>
      <para><emphasis role="bold">Execute modal</emphasis>.  To write a policy that tells Congress the conditions
                    under which it should execute a certain action, we write rules that utilize
                    the <emphasis>execute</emphasis> modal in the head of the rule.</para>
      <para>For example, to dictate that Congress should ask Nova to pause() all of the
                    servers whose state is ACTIVE, we would write the following policy statement:</para>
      <screen>execute[nova:servers.pause(x)] :- nova:servers(id=x, status="ACTIVE")</screen>
      <para>We discuss this modal operator in greater detail in Section 3.</para>
      <para><emphasis role="bold">Grammar</emphasis>. Here is the grammar for Datalog policies:</para>
      <screen>&lt;policy&gt; ::= &lt;rule&gt;*
&lt;rule&gt; ::= &lt;head&gt; COLONMINUS &lt;literal&gt; (COMMA &lt;literal&gt;)*
&lt;head&gt; ::= &lt;atom&gt;
&lt;head&gt; ::= EXECUTE[&lt;atom&gt;]
&lt;literal&gt; ::= &lt;atom&gt;
&lt;literal&gt; ::= NOT &lt;atom&gt;
&lt;atom&gt; ::= TABLENAME LPAREN &lt;arg&gt; (COMMA &lt;arg&gt;)* RPAREN
&lt;arg&gt; ::= &lt;term&gt;
&lt;arg&gt; ::= COLUMNNAME=&lt;term&gt;
&lt;term&gt; ::= INTEGER | FLOAT | STRING | VARIABLE</screen>
    </section>
    <section>
      <title>2.3 Datalog Syntax Restrictions</title>
      <para>There are a number of syntactic restrictions on Datalog that are, for the most
                    part, common sense.</para>
      <para><emphasis role="bold">Head Safety</emphasis>: every variable in the head of a rule must appear in the body.</para>
      <para>Head Safety is natural because if a variable appears in the head of the rule
                    but not the body, we have not given a prescription for which strings/numbers
                    to use for that variable when adding rows to the table in the head.</para>
      <para><emphasis role="bold">Body Safety</emphasis>: every variable occurring in a negated atom or in the input
                    of a built-in table must appear in a non-negated, non-builtin atom in the body.</para>
      <para>Body Safety is important for ensuring that the sizes of our tables are always
                    finite.  There are always infinitely many rows that DO NOT belong to a table,
                    and there are often infinitely many rows that DO belong to a builtin
                    (like equal).  Body safety ensures that the number of rows belonging to
                    the table in the head is always finite.</para>
      <para><emphasis role="bold">No recursion</emphasis>: You are not allowed to define a table in terms of itself.</para>
      <para>A classic example starts with a table that tells us which network nodes
                    are directly adjacent to which other nodes (by a single network hop).  Then you
                    want to write a policy about which nodes are connected to which other nodes
                    (by any number of hops).  Expressing such a policy requires recursion, which
                    is not allowed.</para>
      <para><emphasis role="bold">Modal safety</emphasis>: The <emphasis>execute</emphasis> modal may only appear in the heads of rules.</para>
      <para>The Datalog language is we have is called a condition-action language, meaning
                    that action-execution depends on conditions on the state of the cloud.  But
                    it is not an event-condition-action language, which would enable
                    action-execution to depend on the conditions of the cloud plus the action
                    that was just executed.  An event-condition-action language would allow
                    the <emphasis>execute</emphasis> modal to appear in the body of rules.</para>
      <para><emphasis role="bold">Schema consistency</emphasis>: Every time a rule references one of the cloud service
                    tables, the rule must use the same (number of) columns that the cloud service
                    provides for that table.</para>
      <para>This restriction catches mistakes in rules that use the wrong number of columns
                    or the wrong column names.</para>
    </section>
    <section>
      <title>2.4 Datalog builtins</title>
      <para>You can think of builtins as tables that are defined for you.  All builtins
                    are referenced in rules using the prefix <emphasis>builtin:</emphasis>.  For example, to check
                    if the value of x is less than the value of y, you write <emphasis>builtin:lt(x,y)</emphasis>.</para>
      <para>In previous releases, the <emphasis>builtin:</emphasis> prefix was unnecessary.  You could reference
                    builtin tables in their bare form, e.g. <emphasis>lt(x,y)</emphasis>.  As of Ocata, bare references
                    to builtins are deprecated.</para>
      <para>
        <emphasis role="bold">Bare builtin references are deprecated as of Ocata.They will be removed
                        in the Q release.</emphasis>
      </para>
      <para>Here is a list of the currently supported builtins.  A builtin that has
                    N inputs means that the leftmost N columns are the inputs, and the
                    remaining columns (if any) are the outputs. If a builtin has no outputs, it
                    return boolean value True or False, starting with comparison.</para>
      <informaltable>
        <tgroup cols="3">
          <colspec colname="c1" colwidth="51.4*"/>
          <colspec colname="c2" colwidth="9.5*"/>
          <colspec colname="c3" colwidth="39.2*"/>
          <thead>
            <row>
              <entry>
                <para>Comparison Builtin</para>
              </entry>
              <entry>
                <para>Inputs</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>lt(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x &lt; y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>lteq(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x &lt;= y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>equal(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x == y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>gt(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x &gt; y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>gteq(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x &gt;= y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>max(x, y, z)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>z = max(x, y)</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Next are the arithmetic builtins.</para>
      <informaltable>
        <tgroup cols="3">
          <colspec colname="c1" colwidth="51.4*"/>
          <colspec colname="c2" colwidth="9.5*"/>
          <colspec colname="c3" colwidth="39.2*"/>
          <thead>
            <row>
              <entry>
                <para>Arithmetic Builtin</para>
              </entry>
              <entry>
                <para>Inputs</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>plus(x, y, z)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>z = x + y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>minus(x, y, z)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>z = x - y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>mul(x, y, z)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>z = x * y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>div(x, y, z)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>z = x / y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>float(x, y)</para>
              </entry>
              <entry>
                <para>1</para>
              </entry>
              <entry>
                <para>y = float(x)</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>int(x, y)</para>
              </entry>
              <entry>
                <para>1</para>
              </entry>
              <entry>
                <para>y = int(x)</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Then are the string builtins.</para>
      <informaltable>
        <tgroup cols="3">
          <colspec colname="c1" colwidth="51.4*"/>
          <colspec colname="c2" colwidth="9.5*"/>
          <colspec colname="c3" colwidth="39.2*"/>
          <thead>
            <row>
              <entry>
                <para>String Builtin</para>
              </entry>
              <entry>
                <para>Inputs</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>concat(x, y, z)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>z = concatenate(x, y)</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>len(x, y)</para>
              </entry>
              <entry>
                <para>1</para>
              </entry>
              <entry>
                <para>y = number of characters in x</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Next are the builtins for manipulating dates and times.  These builtins
                    are based on the Python DateTime object.</para>
      <informaltable>
        <tgroup cols="3">
          <colspec colname="c1" colwidth="50.0*"/>
          <colspec colname="c2" colwidth="9.2*"/>
          <colspec colname="c3" colwidth="40.8*"/>
          <thead>
            <row>
              <entry>
                <para>Datetime Builtin</para>
              </entry>
              <entry>
                <para>Inputs</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>now(x)</para>
              </entry>
              <entry>
                <para>0</para>
              </entry>
              <entry>
                <para>The current date-time</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>unpack_date(x, year, month, day)</para>
              </entry>
              <entry>
                <para>1</para>
              </entry>
              <entry>
                <para>Extract year/month/day</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>unpack_time(x, hours, minutes, secs)</para>
              </entry>
              <entry>
                <para>1</para>
              </entry>
              <entry>
                <para>Extract hours/minutes/seconds</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>unpack_datetime(x, y, m, d, h, i, s)</para>
              </entry>
              <entry>
                <para>1</para>
              </entry>
              <entry>
                <para>Extract date and time</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>pack_time(hours, minutes, seconds, x)</para>
              </entry>
              <entry>
                <para>3</para>
              </entry>
              <entry>
                <para>Create date-time with date</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>pack_date(year, month, day, x)</para>
              </entry>
              <entry>
                <para>3</para>
              </entry>
              <entry>
                <para>Create date-time with time</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>pack_datetime(y, m, d, h, i, s, x)</para>
              </entry>
              <entry>
                <para>6</para>
              </entry>
              <entry>
                <para>Create date-time with date/time</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>extract_date(x, date)</para>
              </entry>
              <entry>
                <para>1</para>
              </entry>
              <entry>
                <para>Extract date obj from date-time</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>extract_time(x, time)</para>
              </entry>
              <entry>
                <para>1</para>
              </entry>
              <entry>
                <para>Extract time obj from date-time</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>datetime_to_seconds(x, secs)</para>
              </entry>
              <entry>
                <para>1</para>
              </entry>
              <entry>
                <para>secs from 1900 to date-time x</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>datetime_plus(x, y, z)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>z = x + y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>datetime_minus(x, y, z)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>z = x - y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>datetime_lt(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x is before y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>datetime_lteq(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x is no later than y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>datetime_gt(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x is later than y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>datetime_gteq(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x is no earlier than y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>datetime_equal(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if x == y</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Last are the builtins for handling network addresses.  These builtins
                    are based on the Python netaddr package.  Both IPv4 and IPv6 are supported.
                    For more details see the
                    <literal>netaddr documentation &lt;http://pythonhosted.org/netaddr/&gt;</literal>.</para>
      <informaltable>
        <tgroup cols="3">
          <colspec colname="c1" colwidth="32.5*"/>
          <colspec colname="c2" colwidth="9.1*"/>
          <colspec colname="c3" colwidth="58.4*"/>
          <thead>
            <row>
              <entry>
                <para>Network Address Builtins</para>
              </entry>
              <entry>
                <para>Inputs</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>ips_equal(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if IP x is equal to IP y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>ips_lt(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if IP x is less than IP y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>ips_lteq(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if IP x is less than or equal to IP y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>ips_gt(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if IP x is greater than IP y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>ips_gteq(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if IP x is greater than or equal to IP y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>networks_equal(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if network x and network y are equal</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>networks_overlap(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if the same IP is in networks x and y</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>ip_in_network(x, y)</para>
              </entry>
              <entry>
                <para>2</para>
              </entry>
              <entry>
                <para>True if IP x belongs to network y</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
  </section>
  <section>
    <title>3. Multiple Policies</title>
    <para>One of the goals of Congress is for several different people in an organization
                to collaboratively define a single, overarching policy that governs a cloud.
                The example, the compute admin might some tables that are good building blocks
                for writing policy about compute.  Similarly the network and storage admins
                might create tables that help define policy about networking and storage, respectively.
                Using those building blocks, the cloud administrator might then write
                policy about compute, storage, and networking.</para>
    <para>To make it easier for several people to collaborate (or for a single person
                to write more modular policies) Congress allows you organize your Datalog
                statements using policy modules. Each policy module is simply a collection of
                Datalog statements.  You create and delete policy modules using the API,
                and the you insert/delete Datalog statements into a particular policy module also
                using the API.</para>
    <para>The rules you insert into one policy module can reference tables defined in
                other policy modules.  To do that, you prefix the name of the table with
                the name of the policy and separate the policy module and table name with
                a colon.</para>
    <para>For example, if the policy module <emphasis>compute</emphasis> has a table that lists all the
                servers that have not been properly secured <emphasis>insecure(server)</emphasis>
                and the policy module <emphasis>network</emphasis> has a table of all devices connected to
                the internet <emphasis>connected_to_internet</emphasis>, then as a
                cloud administrator, you might write a policy that says there is an error
                whenever a server is insecure and connected to the internet.</para>
    <screen language="none">error(x) :- compute:insecure(x), network:connected_to_internet(x)</screen>
    <para>Notice that this is exactly the same syntax you use to reference tables exported
                directly by cloud services:</para>
    <screen>has_ip(x) :- neutron:port_ip(x, y)</screen>
    <para>In fact, the tables exported by cloud services are stored in a policy module
                with the same name as the service.</para>
    <para>While the term <emphasis>policy module</emphasis> is accurate, we usually abbreviate it to <emphasis>policy</emphasis>,
                and say that Congress supports multiple policies. Note, however, that supporting
                multiple policies is not the same thing as supporting multi-tenancy.
                Currently, all of
                the policies are visible to everyone using the system, and everyone using
                the system has the same view of the tables the cloud services export.  For
                true multi-tenancy, you would expect different tenants to have different
                sets of policies and potentially a different view of the data exported
                by cloud services.</para>
    <para>See section <xref linkend="api"/> for details about creating, deleting, and
                populating policies.</para>
    <section>
      <title>3.1 Syntactic Restrictions for Multiple Policies</title>
      <para>There are a couple of additional syntactic restrictions imposed when using
                    multiple policies.</para>
      <para><emphasis role="bold">No recursion across policies</emphasis>.  Just as there is no recursion permitted
                    within a single policy, there is no recursion permitted across policies.</para>
      <para>For example, the following is prohibited:</para>
      <screen># Not permitted because of recursion
Module compute:  p(x) :- storage:q(x)
Module storage:  q(x) :- compute:p(x)</screen>
      <para><emphasis role="bold">No policy name may be referenced in the head of a rule</emphasis>.  A rule may
                    not mention any policy in the head (unless the head uses the modal <emphasis>execute</emphasis>).</para>
      <para>This restriction prohibits one policy from changing the tables
                    defined within another policy.  The following example is prohibited
                    (in all policy modules, including ‘compute’):</para>
      <screen># Not permitted because 'compute' is in the head
compute:p(x) :- q(x)</screen>
      <para>The following rule is permitted, because it utilizes <emphasis>execute</emphasis> in the
                    head of the rule:</para>
      <screen># Permitted because of execute[]
execute[nova:pause(x)] :- nova:servers(id=x, status="ACTIVE")</screen>
      <para>Congress will stop you from inserting rules that violate these restrictions.</para>
    </section>
  </section>
</section>
