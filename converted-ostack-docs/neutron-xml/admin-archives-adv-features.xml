<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Advanced features through API extensions</title>
  <para>Several plug-ins implement API extensions that provide capabilities
            similar to what was available in <literal>nova-network</literal>. These plug-ins are likely
            to be of interest to the OpenStack community.</para>
  <section>
    <title>Provider networks</title>
    <para>Networks can be categorized as either project networks or provider
                networks. Project networks are created by normal users and details about
                how they are physically realized are hidden from those users. Provider
                networks are created with administrative credentials, specifying the
                details of how the network is physically realized, usually to match some
                existing network in the data center.</para>
    <para>Provider networks enable administrators to create networks that map
                directly to the physical networks in the data center.
                This is commonly used to give projects direct access to a public network
                that can be used to reach the Internet. It might also be used to
                integrate with VLANs in the network that already have a defined meaning
                (for example, enable a VM from the marketing department to be placed
                on the same VLAN as bare-metal marketing hosts in the same data center).</para>
    <para>The provider extension allows administrators to explicitly manage the
                relationship between Networking virtual networks and underlying physical
                mechanisms such as VLANs and tunnels. When this extension is supported,
                Networking client users with administrative privileges see additional
                provider attributes on all virtual networks and are able to specify
                these attributes in order to create provider networks.</para>
    <para>The provider extension is supported by the Open vSwitch and Linux Bridge
                plug-ins. Configuration of these plug-ins requires familiarity with this
                extension.</para>
    <section>
      <title>Terminology</title>
      <para>A number of terms are used in the provider extension and in the
                    configuration of plug-ins supporting the provider extension:</para>
      <table>
        <title>Provider extension terminology</title>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="30.0*"/>
          <colspec colname="c2" colwidth="70.0*"/>
          <thead>
            <row>
              <entry>
                <para>Term</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>virtual network</para>
              </entry>
              <entry>
                <para>A Networking L2 network (identified by a UUID and optional name) whose
                                        ports can be attached as vNICs to Compute instances and to various
                                        Networking agents. The Open vSwitch and Linux Bridge plug-ins each
                                        support several different mechanisms to realize virtual networks.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>physical network</para>
              </entry>
              <entry>
                <para>A network connecting virtualization hosts (such as compute nodes) with
                                        each other and with other network resources. Each physical network might
                                        support multiple virtual networks. The provider extension and the plug-in
                                        configurations identify physical networks using simple string names.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>project network</para>
              </entry>
              <entry>
                <para>A virtual network that a project or an administrator creates. The
                                        physical details of the network are not exposed to the project.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>provider network</para>
              </entry>
              <entry>
                <para>A virtual network administratively created to map to a specific network
                                        in the data center, typically to enable direct access to non-OpenStack
                                        resources on that network. Project can be given access to provider
                                        networks.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>VLAN network</para>
              </entry>
              <entry>
                <para>A virtual network implemented as packets on a specific physical network
                                        containing IEEE 802.1Q headers with a specific VID field value. VLAN
                                        networks sharing the same physical network are isolated from each other
                                        at L2 and can even have overlapping IP address spaces. Each distinct
                                        physical network supporting VLAN networks is treated as a separate VLAN
                                        trunk, with a distinct space of VID values. Valid VID values are 1
                                        through 4094.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>flat network</para>
              </entry>
              <entry>
                <para>A virtual network implemented as packets on a specific physical network
                                        containing no IEEE 802.1Q header. Each physical network can realize at
                                        most one flat network.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>local network</para>
              </entry>
              <entry>
                <para>A virtual network that allows communication within each host, but not
                                        across a network. Local networks are intended mainly for single-node test
                                        scenarios, but can have other uses.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>GRE network</para>
              </entry>
              <entry>
                <para>A virtual network implemented as network packets encapsulated using
                                        GRE. GRE networks are also referred to as <emphasis>tunnels</emphasis>. GRE tunnel packets
                                        are routed by the IP routing table for the host, so GRE networks are not
                                        associated by Networking with specific physical networks.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Virtual Extensible LAN (VXLAN) network</para>
              </entry>
              <entry>
                <para>VXLAN is a proposed encapsulation protocol for running an overlay network
                                        on existing Layer 3 infrastructure. An overlay network is a virtual
                                        network that is built on top of existing network Layer 2 and Layer 3
                                        technologies to support elastic compute architectures.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The ML2, Open vSwitch, and Linux Bridge plug-ins support VLAN networks,
                    flat networks, and local networks. Only the ML2 and Open vSwitch
                    plug-ins currently support GRE and VXLAN networks, provided that the
                    required features exist in the hosts Linux kernel, Open vSwitch, and
                    iproute2 packages.</para>
    </section>
    <section>
      <title>Provider attributes</title>
      <para>The provider extension extends the Networking network resource with
                    these attributes:</para>
      <table>
        <title>Provider network attributes</title>
        <tgroup cols="4">
          <colspec colname="c1" colwidth="12.7*"/>
          <colspec colname="c2" colwidth="12.7*"/>
          <colspec colname="c3" colwidth="12.7*"/>
          <colspec colname="c4" colwidth="62.0*"/>
          <thead>
            <row>
              <entry>
                <para>Attribute name</para>
              </entry>
              <entry>
                <para>Type</para>
              </entry>
              <entry>
                <para>Default Value</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>provider: network_type</para>
              </entry>
              <entry>
                <para>String</para>
              </entry>
              <entry>
                <para>N/A</para>
              </entry>
              <entry>
                <para>The physical mechanism by which the virtual network is implemented.
                                        Possible values are <literal>flat</literal>, <literal>vlan</literal>, <literal>local</literal>, <literal>gre</literal>, and
                                        <literal>vxlan</literal>, corresponding to flat networks, VLAN networks, local
                                        networks, GRE networks, and VXLAN networks as defined above.
                                        All types of provider networks can be created by administrators,
                                        while project networks can be implemented as <literal>vlan</literal>, <literal>gre</literal>,
                                        <literal>vxlan</literal>, or <literal>local</literal> network types depending on plug-in
                                        configuration.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>provider: physical_network</para>
              </entry>
              <entry>
                <para>String</para>
              </entry>
              <entry>
                <para>If a physical network named “default” has been configured and
                                        if provider:network_type is <literal>flat</literal> or <literal>vlan</literal>, then “default”
                                        is used.</para>
              </entry>
              <entry>
                <para>The name of the physical network over which the virtual network
                                        is implemented for flat and VLAN networks. Not applicable to the
                                        <literal>local</literal> or <literal>gre</literal> network types.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>provider:segmentation_id</para>
              </entry>
              <entry>
                <para>Integer</para>
              </entry>
              <entry>
                <para>N/A</para>
              </entry>
              <entry>
                <para>For VLAN networks, the VLAN VID on the physical network that
                                        realizes the virtual network. Valid VLAN VIDs are 1 through 4094.
                                        For GRE networks, the tunnel ID. Valid tunnel IDs are any 32 bit
                                        unsigned integer. Not applicable to the <literal>flat</literal> or <literal>local</literal>
                                        network types.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>To view or set provider extended attributes, a client must be authorized
                    for the <literal>extension:provider_network:view</literal> and
                    <literal>extension:provider_network:set</literal> actions in the Networking policy
                    configuration. The default Networking configuration authorizes both
                    actions for users with the admin role. An authorized client or an
                    administrative user can view and set the provider extended attributes
                    through Networking API calls. See the section called
                    <xref linkend="authentication-and-authorization"/> for details on policy configuration.</para>
    </section>
  </section>
  <section>
    <title>L3 routing and NAT</title>
    <para>The Networking API provides abstract L2 network segments that are
                decoupled from the technology used to implement the L2 network.
                Networking includes an API extension that provides abstract L3 routers
                that API users can dynamically provision and configure. These Networking
                routers can connect multiple L2 Networking networks and can also provide
                a gateway that connects one or more private L2 networks to a shared
                external network. For example, a public network for access to the
                Internet. See the <link xlink:href="https://docs.openstack.org/ocata/config-reference/">OpenStack Configuration Reference</link> for details on common
                models of deploying Networking L3 routers.</para>
    <para>The L3 router provides basic NAT capabilities on gateway ports that
                uplink the router to external networks. This router SNATs all traffic by
                default and supports floating IPs, which creates a static one-to-one
                mapping from a public IP on the external network to a private IP on one
                of the other subnets attached to the router. This allows a project to
                selectively expose VMs on private networks to other hosts on the
                external network (and often to all hosts on the Internet). You can
                allocate and map floating IPs from one port to another, as needed.</para>
    <section>
      <title>Basic L3 operations</title>
      <para>External networks are visible to all users. However, the default policy
                    settings enable only administrative users to create, update, and delete
                    external networks.</para>
      <para>This table shows example <command>openstack</command> commands that enable you
                    to complete basic L3 operations:</para>
      <table>
        <title>Basic L3 Operations</title>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="37.5*"/>
          <colspec colname="c2" colwidth="62.5*"/>
          <thead>
            <row>
              <entry>
                <para>Operation</para>
              </entry>
              <entry>
                <para>Command</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>Creates external networks.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network create public --external
$ openstack subnet create --network public --subnet-range 172.16.1.0/24 subnetname</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Lists external networks.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network list --external</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Creates an internal-only router that connects to multiple L2 networks privately.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network create net1
$ openstack subnet create --network net1 --subnet-range 10.0.0.0/24 subnetname1
$ openstack network create net2
$ openstack subnet create --network net2 --subnet-range 10.0.1.0/24 subnetname2
$ openstack router create router1
$ openstack router add subnet router1 subnetname1
$ openstack router add subnet router1 subnetname2</screen>
                <para>An internal router port can have only one IPv4 subnet and multiple IPv6 subnets
                                        that belong to the same network ID. When you call <literal>router-interface-add</literal> with an IPv6
                                        subnet, this operation adds the interface to an existing internal port with the same
                                        network ID. If a port with the same network ID does not exist, a new port is created.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Connects a router to an external network, which enables that router to
                                        act as a NAT gateway for external connectivity.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack router set --external-gateway EXT_NET_ID router1
$ openstack router set --route destination=172.24.4.0/24,gateway=172.24.4.1 router1</screen>
                <para>The router obtains an interface with the gateway_ip address of the
                                        subnet and this interface is attached to a port on the L2 Networking
                                        network associated with the subnet. The router also gets a gateway
                                        interface to the specified external network. This provides SNAT
                                        connectivity to the external network as well as support for floating
                                        IPs allocated on that external networks. Commonly an external network
                                        maps to a network in the provider.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Lists routers.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack router list</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Shows information for a specified router.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack router show ROUTER_ID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Shows all internal interfaces for a router.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack port list --router  ROUTER_ID
$ openstack port list --router  ROUTER_NAME</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Identifies the PORT_ID that represents the VM NIC to which the floating
                                        IP should map.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack port list -c ID -c "Fixed IP Addresses" --server INSTANCE_ID</screen>
                <para>This port must be on a Networking subnet that is attached to
                                        a router uplinked to the external network used to create the floating
                                        IP. Conceptually, this is because the router must be able to perform the
                                        Destination NAT (DNAT) rewriting of packets from the floating IP address
                                        (chosen from a subnet on the external network) to the internal fixed
                                        IP (chosen from a private subnet that is behind the router).</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Creates a floating IP address and associates it with a port.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack floating ip create EXT_NET_ID
$ openstack floating ip add port FLOATING_IP_ID --port-id INTERNAL_VM_PORT_ID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Creates a floating IP on a specific subnet in the external network.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack floating ip create EXT_NET_ID --subnet SUBNET_ID</screen>
                <para>If there are multiple subnets in the external network, you can choose a specific
                                        subnet based on quality and costs.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Creates a floating IP address and associates it with a port, in a single step.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack floating ip create --port INTERNAL_VM_PORT_ID EXT_NET_ID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Lists floating IPs</para>
              </entry>
              <entry>
                <screen language="console">$ openstack floating ip list</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Finds floating IP for a specified VM port.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack floating ip list --port INTERNAL_VM_PORT_ID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Disassociates a floating IP address.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack floating ip remove port FLOATING_IP_ID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Deletes the floating IP address.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack floating ip delete FLOATING_IP_ID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Clears the gateway.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack router unset --external-gateway router1</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Removes the interfaces from the router.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack router remove subnet router1 SUBNET_ID</screen>
                <para>If this subnet ID is the last subnet on the port, this operation deletes the port itself.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Deletes the router.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack router delete router1</screen>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>
  <section>
    <title>Security groups</title>
    <para>Security groups and security group rules allow administrators and
                projects to specify the type of traffic and direction
                (ingress/egress) that is allowed to pass through a port. A security
                group is a container for security group rules.</para>
    <para>When a port is created in Networking it is associated with a security
                group. If a security group is not specified the port is associated with
                a ‘default’ security group. By default, this group drops all ingress
                traffic and allows all egress. Rules can be added to this group in order
                to change the behavior.</para>
    <para>To use the Compute security group APIs or use Compute to orchestrate the
                creation of ports for instances on specific security groups, you must
                complete additional configuration. You must configure the
                <literal>/etc/nova/nova.conf</literal> file and set the <literal>security_group_api=neutron</literal>
                option on every node that runs nova-compute and nova-api. After you make
                this change, restart nova-api and nova-compute to pick up this change.
                Then, you can use both the Compute and OpenStack Network security group
                APIs at the same time.</para>
    <note>
      <itemizedlist>
        <listitem>
          <para>To use the Compute security group API with Networking, the
                            Networking plug-in must implement the security group API. The
                            following plug-ins currently implement this: ML2, Open vSwitch,
                            Linux Bridge, NEC, and VMware NSX.</para>
        </listitem>
        <listitem>
          <para>You must configure the correct firewall driver in the
                            <literal>securitygroup</literal> section of the plug-in/agent configuration
                            file. Some plug-ins and agents, such as Linux Bridge Agent and
                            Open vSwitch Agent, use the no-operation driver as the default,
                            which results in non-working security groups.</para>
        </listitem>
        <listitem>
          <para>When using the security group API through Compute, security
                            groups are applied to all ports on an instance. The reason for
                            this is that Compute security group APIs are instances based and
                            not port based as Networking.</para>
        </listitem>
      </itemizedlist>
    </note>
    <section>
      <title>Basic security group operations</title>
      <para>This table shows example neutron commands that enable you to complete
                    basic security group operations:</para>
      <table>
        <title>Basic security group operations</title>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="37.5*"/>
          <colspec colname="c2" colwidth="62.5*"/>
          <thead>
            <row>
              <entry>
                <para>Operation</para>
              </entry>
              <entry>
                <para>Command</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>Creates a security group for our web servers.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack security group create webservers \
 --description "security group for webservers"</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Lists security groups.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack security group list</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Creates a security group rule to allow port 80 ingress.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack security group rule create --ingress \
  --protocol tcp SECURITY_GROUP_UUID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Lists security group rules.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack security group rule list</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Deletes a security group rule.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack security group rule delete SECURITY_GROUP_RULE_UUID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Deletes a security group.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack security group delete SECURITY_GROUP_UUID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Creates a port and associates two security groups.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack port create port1 --security-group SECURITY_GROUP_ID1 \
  --security-group SECURITY_GROUP_ID2 --network NETWORK_ID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Removes security groups from a port.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack port set --no-security-group PORT_ID</screen>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>
  <section>
    <title>Basic Load-Balancer-as-a-Service operations</title>
    <note>
      <para>The Load-Balancer-as-a-Service (LBaaS) API provisions and configures
                    load balancers. The reference implementation is based on the HAProxy
                    software load balancer.</para>
    </note>
    <para>This list shows example neutron commands that enable you to complete
                basic LBaaS operations:</para>
    <itemizedlist>
      <listitem>
        <para>Creates a load balancer pool by using specific provider.</para>
        <para><literal>--provider</literal> is an optional argument. If not used, the pool is
                        created with default provider for LBaaS service. You should configure
                        the default provider in the <literal>[service_providers]</literal> section of the
                        <literal>neutron.conf</literal> file. If no default provider is specified for LBaaS,
                        the <literal>--provider</literal> parameter is required for pool creation.</para>
        <screen language="console">$ neutron lb-pool-create --lb-method ROUND_ROBIN --name mypool \
  --protocol HTTP --subnet-id SUBNET_UUID --provider PROVIDER_NAME</screen>
      </listitem>
      <listitem>
        <para>Associates two web servers with pool.</para>
        <screen language="console">$ neutron lb-member-create --address  WEBSERVER1_IP --protocol-port 80 mypool
$ neutron lb-member-create --address  WEBSERVER2_IP --protocol-port 80 mypool</screen>
      </listitem>
      <listitem>
        <para>Creates a health monitor that checks to make sure our instances are
                        still running on the specified protocol-port.</para>
        <screen language="console">$ neutron lb-healthmonitor-create --delay 3 --type HTTP --max-retries 3 \
  --timeout 3</screen>
      </listitem>
      <listitem>
        <para>Associates a health monitor with pool.</para>
        <screen language="console">$ neutron lb-healthmonitor-associate  HEALTHMONITOR_UUID mypool</screen>
      </listitem>
      <listitem>
        <para>Creates a virtual IP (VIP) address that, when accessed through the
                        load balancer, directs the requests to one of the pool members.</para>
        <screen language="console">$ neutron lb-vip-create --name myvip --protocol-port 80 --protocol \
  HTTP --subnet-id SUBNET_UUID mypool</screen>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Plug-in specific extensions</title>
    <para>Each vendor can choose to implement additional API extensions to the
                core API. This section describes the extensions for each plug-in.</para>
    <section>
      <title>VMware NSX extensions</title>
      <para>These sections explain NSX plug-in extensions.</para>
      <section>
        <title>VMware NSX QoS extension</title>
        <para>The VMware NSX QoS extension rate-limits network ports to guarantee a
                        specific amount of bandwidth for each port. This extension, by default,
                        is only accessible by a project with an admin role but is configurable
                        through the <literal>policy.json</literal> file. To use this extension, create a queue
                        and specify the min/max bandwidth rates (kbps) and optionally set the
                        QoS Marking and DSCP value (if your network fabric uses these values to
                        make forwarding decisions). Once created, you can associate a queue with
                        a network. Then, when ports are created on that network they are
                        automatically created and associated with the specific queue size that
                        was associated with the network. Because one size queue for a every port
                        on a network might not be optimal, a scaling factor from the nova flavor
                        <literal>rxtx_factor</literal> is passed in from Compute when creating the port to scale
                        the queue.</para>
        <para>Lastly, if you want to set a specific baseline QoS policy for the amount
                        of bandwidth a single port can use (unless a network queue is specified
                        with the network a port is created on) a default queue can be created in
                        Networking which then causes ports created to be associated with a queue
                        of that size times the rxtx scaling factor. Note that after a network or
                        default queue is specified, queues are added to ports that are
                        subsequently created but are not added to existing ports.</para>
        <section>
          <title>Basic VMware NSX QoS operations</title>
          <para>This table shows example neutron commands that enable you to complete
                            basic queue operations:</para>
          <table>
            <title>Basic VMware NSX QoS operations</title>
            <tgroup cols="2">
              <colspec colname="c1" colwidth="37.5*"/>
              <colspec colname="c2" colwidth="62.5*"/>
              <thead>
                <row>
                  <entry>
                    <para>Operation</para>
                  </entry>
                  <entry>
                    <para>Command</para>
                  </entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>
                    <para>Creates QoS queue (admin-only).</para>
                  </entry>
                  <entry>
                    <screen language="console">$ neutron queue-create --min 10 --max 1000 myqueue</screen>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Associates a queue with a network.</para>
                  </entry>
                  <entry>
                    <screen language="console">$ neutron net-create network --queue_id QUEUE_ID</screen>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Creates a default system queue.</para>
                  </entry>
                  <entry>
                    <screen language="console">$ neutron queue-create --default True --min 10 --max 2000 default</screen>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Lists QoS queues.</para>
                  </entry>
                  <entry>
                    <screen language="console">$ neutron queue-list</screen>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Deletes a QoS queue.</para>
                  </entry>
                  <entry>
                    <screen language="console">$ neutron queue-delete QUEUE_ID_OR_NAME</screen>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
      </section>
      <section>
        <title>VMware NSX provider networks extension</title>
        <para>Provider networks can be implemented in different ways by the underlying
                        NSX platform.</para>
        <para>The <emphasis>FLAT</emphasis> and <emphasis>VLAN</emphasis> network types use bridged transport connectors.
                        These network types enable the attachment of large number of ports. To
                        handle the increased scale, the NSX plug-in can back a single OpenStack
                        Network with a chain of NSX logical switches. You can specify the
                        maximum number of ports on each logical switch in this chain on the
                        <literal>max_lp_per_bridged_ls</literal> parameter, which has a default value of 5,000.</para>
        <para>The recommended value for this parameter varies with the NSX version
                        running in the back-end, as shown in the following table.</para>
        <para>
          <emphasis role="bold">Recommended values for max_lp_per_bridged_ls</emphasis>
        </para>
        <informaltable>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="41.7*"/>
            <colspec colname="c2" colwidth="58.3*"/>
            <thead>
              <row>
                <entry>
                  <para>NSX version</para>
                </entry>
                <entry>
                  <para>Recommended Value</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>2.x</para>
                </entry>
                <entry>
                  <para>64</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>3.0.x</para>
                </entry>
                <entry>
                  <para>5,000</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>3.1.x</para>
                </entry>
                <entry>
                  <para>5,000</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>3.2.x</para>
                </entry>
                <entry>
                  <para>10,000</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>In addition to these network types, the NSX plug-in also supports a
                        special <emphasis>l3_ext</emphasis> network type, which maps external networks to specific
                        NSX gateway services as discussed in the next section.</para>
      </section>
      <section>
        <title>VMware NSX L3 extension</title>
        <para>NSX exposes its L3 capabilities through gateway services which are
                        usually configured out of band from OpenStack. To use NSX with L3
                        capabilities, first create an L3 gateway service in the NSX Manager.
                        Next, in <literal>/etc/neutron/plugins/vmware/nsx.ini</literal> set
                        <literal>default_l3_gw_service_uuid</literal> to this value. By default, routers are
                        mapped to this gateway service.</para>
        <section>
          <title>VMware NSX L3 extension operations</title>
          <para>Create external network and map it to a specific NSX gateway service:</para>
          <screen language="console">$ openstack network create public --external --provider-network-type l3_ext \
--provider-physical-network L3_GATEWAY_SERVICE_UUID</screen>
          <para>Terminate traffic on a specific VLAN from a NSX gateway service:</para>
          <screen language="console">$ openstack network create public --external --provider-network-type l3_ext \
--provider-physical-network L3_GATEWAY_SERVICE_UUID --provider-segment VLAN_ID</screen>
        </section>
      </section>
      <section>
        <title>Operational status synchronization in the VMware NSX plug-in</title>
        <para>Starting with the Havana release, the VMware NSX plug-in provides an
                        asynchronous mechanism for retrieving the operational status for neutron
                        resources from the NSX back-end; this applies to <emphasis>network</emphasis>, <emphasis>port</emphasis>, and
                        <emphasis>router</emphasis> resources.</para>
        <para>The back-end is polled periodically and the status for every resource is
                        retrieved; then the status in the Networking database is updated only
                        for the resources for which a status change occurred. As operational
                        status is now retrieved asynchronously, performance for <literal>GET</literal>
                        operations is consistently improved.</para>
        <para>Data to retrieve from the back-end are divided in chunks in order to
                        avoid expensive API requests; this is achieved leveraging NSX APIs
                        response paging capabilities. The minimum chunk size can be specified
                        using a configuration option; the actual chunk size is then determined
                        dynamically according to: total number of resources to retrieve,
                        interval between two synchronization task runs, minimum delay between
                        two subsequent requests to the NSX back-end.</para>
        <para>The operational status synchronization can be tuned or disabled using
                        the configuration options reported in this table; it is however worth
                        noting that the default values work fine in most cases.</para>
        <table>
          <title>Configuration options for tuning operational status synchronization in the NSX plug-in</title>
          <tgroup cols="5">
            <colspec colname="c1" colwidth="13.3*"/>
            <colspec colname="c2" colwidth="13.3*"/>
            <colspec colname="c3" colwidth="13.3*"/>
            <colspec colname="c4" colwidth="13.3*"/>
            <colspec colname="c5" colwidth="46.7*"/>
            <thead>
              <row>
                <entry>
                  <para>Option name</para>
                </entry>
                <entry>
                  <para>Group</para>
                </entry>
                <entry>
                  <para>Default value</para>
                </entry>
                <entry>
                  <para>Type and constraints</para>
                </entry>
                <entry>
                  <para>Notes</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>
                    <literal>state_sync_interval</literal>
                  </para>
                </entry>
                <entry>
                  <para>
                    <literal>nsx_sync</literal>
                  </para>
                </entry>
                <entry>
                  <para>10 seconds</para>
                </entry>
                <entry>
                  <para>Integer; no constraint.</para>
                </entry>
                <entry>
                  <para>Interval in seconds between two run of the synchronization task. If the
                                            synchronization task takes more than <literal>state_sync_interval</literal> seconds to
                                            execute, a new instance of the task is started as soon as the other is
                                            completed. Setting the value for this option to 0 will disable the
                                            synchronization task.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal>max_random_sync_delay</literal>
                  </para>
                </entry>
                <entry>
                  <para>
                    <literal>nsx_sync</literal>
                  </para>
                </entry>
                <entry>
                  <para>0 seconds</para>
                </entry>
                <entry>
                  <para>Integer. Must not exceed <literal>min_sync_req_delay</literal></para>
                </entry>
                <entry>
                  <para>When different from zero, a random delay between 0 and
                                            <literal>max_random_sync_delay</literal> will be added before processing the next
                                            chunk.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal>min_sync_req_delay</literal>
                  </para>
                </entry>
                <entry>
                  <para>
                    <literal>nsx_sync</literal>
                  </para>
                </entry>
                <entry>
                  <para>1 second</para>
                </entry>
                <entry>
                  <para>Integer. Must not exceed <literal>state_sync_interval</literal>.</para>
                </entry>
                <entry>
                  <para>The value of this option can be tuned according to the observed
                                            load on the NSX controllers. Lower values will result in faster
                                            synchronization, but might increase the load on the controller cluster.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal>min_chunk_size</literal>
                  </para>
                </entry>
                <entry>
                  <para>
                    <literal>nsx_sync</literal>
                  </para>
                </entry>
                <entry>
                  <para>500 resources</para>
                </entry>
                <entry>
                  <para>Integer; no constraint.</para>
                </entry>
                <entry>
                  <para>Minimum number of resources to retrieve from the back-end for each
                                            synchronization chunk. The expected number of synchronization chunks
                                            is given by the ratio between <literal>state_sync_interval</literal> and
                                            <literal>min_sync_req_delay</literal>. This size of a chunk might increase if the
                                            total number of resources is such that more than <literal>min_chunk_size</literal>
                                            resources must be fetched in one chunk with the current number of
                                            chunks.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <literal>always_read_status</literal>
                  </para>
                </entry>
                <entry>
                  <para>
                    <literal>nsx_sync</literal>
                  </para>
                </entry>
                <entry>
                  <para>False</para>
                </entry>
                <entry>
                  <para>Boolean; no constraint.</para>
                </entry>
                <entry>
                  <para>When this option is enabled, the operational status will always be
                                            retrieved from the NSX back-end ad every <literal>GET</literal> request. In this
                                            case it is advisable to disable the synchronization task.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>When running multiple OpenStack Networking server instances, the status
                        synchronization task should not run on every node; doing so sends
                        unnecessary traffic to the NSX back-end and performs unnecessary DB
                        operations. Set the <literal>state_sync_interval</literal> configuration option to a
                        non-zero value exclusively on a node designated for back-end status
                        synchronization.</para>
        <para>The <literal>fields=status</literal> parameter in Networking API requests always
                        triggers an explicit query to the NSX back end, even when you enable
                        asynchronous state synchronization. For example, <literal>GET
/v2.0/networks/NET_ID?fields=status&amp;fields=name</literal>.</para>
      </section>
    </section>
    <section>
      <title>Big Switch plug-in extensions</title>
      <para>This section explains the Big Switch neutron plug-in-specific extension.</para>
      <section>
        <title>Big Switch router rules</title>
        <para>Big Switch allows router rules to be added to each project router. These
                        rules can be used to enforce routing policies such as denying traffic
                        between subnets or traffic to external networks. By enforcing these at
                        the router level, network segmentation policies can be enforced across
                        many VMs that have differing security groups.</para>
        <section>
          <title>Router rule attributes</title>
          <para>Each project router has a set of router rules associated with it. Each
                            router rule has the attributes in this table. Router rules and their
                            attributes can be set using the <command>neutron router-update</command> command,
                            through the horizon interface or the Networking API.</para>
          <table>
            <title>Big Switch Router rule attributes</title>
            <tgroup cols="4">
              <colspec colname="c1" colwidth="15.4*"/>
              <colspec colname="c2" colwidth="15.4*"/>
              <colspec colname="c3" colwidth="15.4*"/>
              <colspec colname="c4" colwidth="53.8*"/>
              <thead>
                <row>
                  <entry>
                    <para>Attribute name</para>
                  </entry>
                  <entry>
                    <para>Required</para>
                  </entry>
                  <entry>
                    <para>Input type</para>
                  </entry>
                  <entry>
                    <para>Description</para>
                  </entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>
                    <para>source</para>
                  </entry>
                  <entry>
                    <para>Yes</para>
                  </entry>
                  <entry>
                    <para>A valid CIDR or one of the keywords ‘any’ or ‘external’</para>
                  </entry>
                  <entry>
                    <para>The network that a packet’s source IP must match for the
                                                rule to be applied.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>destination</para>
                  </entry>
                  <entry>
                    <para>Yes</para>
                  </entry>
                  <entry>
                    <para>A valid CIDR or one of the keywords ‘any’ or ‘external’</para>
                  </entry>
                  <entry>
                    <para>The network that a packet’s destination IP must match for the rule to
                                                be applied.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>action</para>
                  </entry>
                  <entry>
                    <para>Yes</para>
                  </entry>
                  <entry>
                    <para>‘permit’ or ‘deny’</para>
                  </entry>
                  <entry>
                    <para>Determines whether or not the matched packets will allowed to cross the
                                                router.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>nexthop</para>
                  </entry>
                  <entry>
                    <para>No</para>
                  </entry>
                  <entry>
                    <para>A plus-separated (+) list of next-hop IP addresses. For example,
                                                <literal>1.1.1.1+1.1.1.2</literal>.</para>
                  </entry>
                  <entry>
                    <para>Overrides the default virtual router used to handle traffic for packets
                                                that match the rule.</para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
        <section>
          <title>Order of rule processing</title>
          <para>The order of router rules has no effect. Overlapping rules are evaluated
                            using longest prefix matching on the source and destination fields. The
                            source field is matched first so it always takes higher precedence over
                            the destination field. In other words, longest prefix matching is used
                            on the destination field only if there are multiple matching rules with
                            the same source.</para>
        </section>
        <section>
          <title>Big Switch router rules operations</title>
          <para>Router rules are configured with a router update operation in OpenStack
                            Networking. The update overrides any previous rules so all rules must be
                            provided at the same time.</para>
          <para>Update a router with rules to permit traffic by default but block
                            traffic from external networks to the 10.10.10.0/24 subnet:</para>
          <screen language="console">$ neutron router-update ROUTER_UUID --router_rules type=dict list=true \
  source=any,destination=any,action=permit \
  source=external,destination=10.10.10.0/24,action=deny</screen>
          <para>Specify alternate next-hop addresses for a specific subnet:</para>
          <screen language="console"><?dbsuse-fo font-size="8pt"?>$ neutron router-update ROUTER_UUID --router_rules type=dict list=true  \
  source=any,destination=any,action=permit \
  source=10.10.10.0/24,destination=any,action=permit,nexthops=10.10.10.254+10.10.10.253</screen>
          <para>Block traffic between two subnets while allowing everything else:</para>
          <screen language="console">$ neutron router-update ROUTER_UUID --router_rules type=dict list=true \
  source=any,destination=any,action=permit \
  source=10.10.10.0/24,destination=10.20.20.20/24,action=deny</screen>
        </section>
      </section>
    </section>
  </section>
  <section>
    <title>L3 metering</title>
    <para>The L3 metering API extension enables administrators to configure IP
                ranges and assign a specified label to them to be able to measure
                traffic that goes through a virtual router.</para>
    <para>The L3 metering extension is decoupled from the technology that
                implements the measurement. Two abstractions have been added: One is the
                metering label that can contain metering rules. Because a metering label
                is associated with a project, all virtual routers in this project are
                associated with this label.</para>
    <section>
      <title>Basic L3 metering operations</title>
      <para>Only administrators can manage the L3 metering labels and rules.</para>
      <para>This table shows example <command>neutron</command> commands that enable you to
                    complete basic L3 metering operations:</para>
      <table>
        <title>Basic L3 operations</title>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="28.6*"/>
          <colspec colname="c2" colwidth="71.4*"/>
          <thead>
            <row>
              <entry>
                <para>Operation</para>
              </entry>
              <entry>
                <para>Command</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>Creates a metering label.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network meter label create LABEL1 \
  --description "DESCRIPTION_LABEL1"</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Lists metering labels.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network meter label list</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Shows information for a specified label.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network meter label show LABEL_UUID
$ openstack network meter label show LABEL1</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Deletes a metering label.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network meter label delete LABEL_UUID
$ openstack network meter label delete LABEL1</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Creates a metering rule.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network meter label rule create LABEL_UUID \
  --remote-ip-prefix CIDR \
  --direction DIRECTION --exclude</screen>
                <para>For example:</para>
                <screen language="console">$ openstack network meter label rule create label1 \
  --remote-ip-prefix 10.0.0.0/24 --direction ingress
$ openstack network meter label rule create label1 \
  --remote-ip-prefix 20.0.0.0/24 --exclude</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Lists metering all label rules.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network meter label rule list</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Shows information for a specified label rule.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network meter label rule show RULE_UUID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Deletes a metering label rule.</para>
              </entry>
              <entry>
                <screen language="console">$ openstack network meter label rule delete RULE_UUID</screen>
              </entry>
            </row>
            <row>
              <entry>
                <para>Lists the value of created metering label rules.</para>
              </entry>
              <entry>
                <screen language="console">$ ceilometer sample-list -m SNMP_MEASUREMENT</screen>
                <para>For example:</para>
                <screen language="console">$ ceilometer sample-list -m hardware.network.bandwidth.bytes
$ ceilometer sample-list -m hardware.network.incoming.bytes
$ ceilometer sample-list -m hardware.network.outgoing.bytes
$ ceilometer sample-list -m hardware.network.outgoing.errors</screen>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>
</section>
