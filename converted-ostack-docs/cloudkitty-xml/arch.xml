<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.14 -->
<document source="/run/media/dpopov/DATAPART1/Git/openstack-docs/cloudkitty/doc/source/arch.rst">
    <section ids="cloudkitty-s-architecture" names="cloudkitty's\ architecture">
        <title>CloudKitty’s Architecture</title>
        <paragraph>CloudKitty can be cut in five big parts:</paragraph>
        <bullet_list bullet="*">
            <list_item>
                <paragraph>API</paragraph>
            </list_item>
            <list_item>
                <paragraph>Data collection (collector)</paragraph>
            </list_item>
            <list_item>
                <paragraph>Rating processing</paragraph>
            </list_item>
            <list_item>
                <paragraph>Storage</paragraph>
            </list_item>
            <list_item>
                <paragraph>Report writer</paragraph>
            </list_item>
        </bullet_list>
        <comment xml:space="preserve">Graph is outdated, and needs to be modified. Skipping it.
.. graphviz:: graph/arch.dot</comment>
        <section ids="module-loading-and-extensions" names="module\ loading\ and\ extensions">
            <title>Module loading and extensions</title>
            <paragraph>Nearly every part of CloudKitty makes use of stevedore to load extensions
                dynamically.</paragraph>
            <paragraph>Every rating module is loaded at runtime and can be enabled/disabled directly
                via CloudKitty’s API. The module is responsible of its own API to ease the
                management of its configuration.</paragraph>
            <paragraph>Collectors and storage backends are loaded with stevedore but configured in
                CloudKitty’s configuration file.</paragraph>
        </section>
        <section ids="collector" names="collector">
            <title>Collector</title>
            <paragraph><strong>Loaded with stevedore</strong></paragraph>
            <paragraph>The name of the collector to use is specified in the configuration, only one
                collector can be loaded at once.
                This part is responsible of information gathering. It consists of a python
                class that loads data from a backend and return it in a format that CloudKitty
                can handle.</paragraph>
            <paragraph>The data format of CloudKitty is the following:</paragraph>
            <literal_block highlight_args="{}" language="json" linenos="False" xml:space="preserve">{
    "myservice": [
        {
            "rating": {
                "price": 0.1
            },
            "desc": {
                "sugar": "25",
                "fiber": "10",
                "name": "apples",
            },
            "vol": {
                "qty": 1,
                "unit": "banana"
            }
        }
    ]
}</literal_block>
            <paragraph>Example code of a basic collector:</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">class MyCollector(BaseCollector):
    def __init__(self, **kwargs):
        super(MyCollector, self).__init__(**kwargs)

    def get_mydata(self, start, end=None, project_id=None, q_filter=None):
        # Do stuff
        return ck_data</literal_block>
            <paragraph>You’ll now be able to add the gathering of mydata in CloudKitty by modifying
                the configuration and specifying the new service in collect/services.</paragraph>
            <paragraph>If you need to load multiple collectors, you can use the <literal>meta</literal> collector and
                use its API to enable/disable collector loading, and set priority.</paragraph>
        </section>
        <section ids="rating" names="rating">
            <title>Rating</title>
            <paragraph><strong>Loaded with stevedore</strong></paragraph>
            <paragraph>This is where every rating calculations is done. The data gathered by the
                collector is pushed in a pipeline of rating processors. Every processor does
                its calculations and updates the data.</paragraph>
            <paragraph>Example of minimal rating module (taken from the Noop module):</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">class Noop(rating.RatingProcessorBase):

    controller = NoopController
    description = 'Dummy test module'

    @property
    def enabled(self):
        """Check if the module is enabled

        :returns: bool if module is enabled
        """
        return True

    @property
    def priority(self):
        return 1

    def reload_config(self):
        pass

    def process(self, data):
        for cur_data in data:
            cur_usage = cur_data['usage']
            for service in cur_usage:
                for entry in cur_usage[service]:
                    if 'rating' not in entry:
                        entry['rating'] = {'price': decimal.Decimal(0)}
        return data</literal_block>
        </section>
        <section ids="storage" names="storage">
            <title>Storage</title>
            <paragraph><strong>Loaded with stevedore</strong></paragraph>
            <paragraph>The storage module is responsible of storing the data in a backend. It
                implements an API on top of the storage to be able to query the data without
                the need of knowing the type of backend used.</paragraph>
            <paragraph>You can use the API to create reports on the fly for example.</paragraph>
        </section>
        <section ids="writer" names="writer">
            <title>Writer</title>
            <paragraph><strong>Loaded with stevedore</strong></paragraph>
            <paragraph>In the same way as the rating pipeline, the writing is handled with a pipeline.
                The data is pushed to write orchestrator that will store the data in a
                transient DB (in case of output file invalidation). And then to every writer in
                the pipeline which is responsible of the writing.</paragraph>
        </section>
    </section>
</document>
