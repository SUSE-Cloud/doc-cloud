<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Generalized filters</title>
  <section>
    <title>Background</title>
    <para>Cinder introduced generalized resource filters since Pike, it has the
                same purpose as <literal>query_volume_filters</literal> option, but it’s more convenient
                and can be applied to more cinder resources, administrator can control the
                allowed filter keys for <emphasis role="bold">non-admin</emphasis> user by editing the filter
                configuration file. Also since this feature, cinder will raise
                <literal>400 BadRequest</literal> if any invalid query filter is specified.</para>
  </section>
  <section>
    <title>How do I configure the filter keys?</title>
    <para><literal>resource_query_filters_file</literal> is introduced to cinder to represent the
                filter config file path, and the config file accepts the valid filter keys
                for <emphasis role="bold">non-admin</emphasis> user with json format:</para>
    <screen language="json">{
   "volume": ["name", "status", "metadata"]
}</screen>
    <para>the key <literal>volume</literal> (singular) here stands for the resource you want to apply and the value
                accepts an list which contains the allowed filters collection, once the configuration
                file is changed and API service is restarted, cinder will only recognize this filter
                keys, <emphasis role="bold">NOTE</emphasis>: the default configuration file will include all the filters we already
                enabled.</para>
  </section>
  <section>
    <title>Which filter keys are supported?</title>
    <para>Not all the attributes are supported at present, so we add this table below to
                indicate which filter keys are valid and can be used in the configuration.</para>
    <para>Since v3.34 we could use ‘~’ to indicate supporting querying resource by inexact match,
                for example, if we have a configuration file as below:</para>
    <screen language="json">{
   "volume": ["name~"]
}</screen>
    <para>User can query volume both by <literal>name=volume</literal> and <literal>name~=volume</literal>, and the volumes
                named <literal>volume123</literal> and <literal>a_volume123</literal> are both valid for second input while neither are
                valid for first. The supported APIs are marked with “*” below in the table.</para>
    <informaltable>
      <tgroup cols="2">
        <colspec colname="c1" colwidth="18.9*"/>
        <colspec colname="c2" colwidth="81.1*"/>
        <thead>
          <row>
            <entry>
              <para>API</para>
            </entry>
            <entry>
              <para>Valid filter keys</para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>list volume*</para>
            </entry>
            <entry>
              <para>id, group_id, name, status, bootable, migration_status, metadata, host,
                                    image_metadata, availability_zone, user_id, volume_type_id, project_id,
                                    size, description, replication_status, multiattach</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>list snapshot*</para>
            </entry>
            <entry>
              <para>id, volume_id, user_id, project_id, status, volume_size, name,
                                    description, volume_type_id, group_snapshot_id, metadata</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>list backup*</para>
            </entry>
            <entry>
              <para>id, name, status, container, availability_zone, description,
                                    volume_id, is_incremental, size, host, parent_id</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>list group*</para>
            </entry>
            <entry>
              <para>id, user_id, status, availability_zone, group_type, name, description,
                                    host</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>list g-snapshot*</para>
            </entry>
            <entry>
              <para>id, name, description, group_id, group_type_id, status</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>list attachment*</para>
            </entry>
            <entry>
              <para>id, volume_id, instance_id, attach_status, attach_mode,
                                    connection_info, mountpoint, attached_host</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>list message*</para>
            </entry>
            <entry>
              <para>id, event_id, resource_uuid, resource_type, request_id, message_level,
                                    project_id</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>get pools</para>
            </entry>
            <entry>
              <para>name, volume_type</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </section>
</section>
