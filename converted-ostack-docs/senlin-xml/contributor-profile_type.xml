<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Profile Types</title>
  <para>In Senlin, each node is associated with a physical object created by
            instantiating a . Profiles themselves are objects
            instantiated from “profile types”. In other words, a profile type provides the
            specification for creating profiles while a profile can be used to create
            multiple homogeneous objects.</para>
  <para>Profile type implementations are managed as plugins. Users can use the
            built-in profile types directly and they can provide their own implementation
            of new profile types. The plan is to have Senlin engine support dynamical
            loading of plugins. Currently, this can be done by adding new
            <literal>senlin.profiles</literal> entry in the <literal>entry_points</literal> section in the <literal>setup.cfg</literal>
            file followed by a reinstall (i.e. <literal>pip install</literal>) operation.</para>
  <section>
    <title>The Base Class ‘Profile’</title>
    <para>The base class <literal>Profile</literal> provides some common logics regarding the following
                operations:</para>
    <itemizedlist>
      <listitem>
        <para>the initialization of the <literal>spec_data</literal> based on the <literal>spec_schema</literal>
                        property and the <literal>spec</literal> input.</para>
      </listitem>
      <listitem>
        <para>the initialization of a basic request context using the Senlin service
                        credentials.</para>
      </listitem>
      <listitem>
        <para>the serialization and deserialization of profile object into/from database.</para>
      </listitem>
      <listitem>
        <para>the validation of data provided through <literal>spec</literal> field of the profile;</para>
      </listitem>
      <listitem>
        <para>the north bound APIs that are provided as class methods, including:</para>
        <itemizedlist>
          <listitem>
            <para><literal>create_object()</literal>: create an object using logic from the profile type
                                implementation, with data from the profile object as inputs;</para>
          </listitem>
          <listitem>
            <para><literal>delete_object()</literal>: delete an object using the profile type
                                implementation;</para>
          </listitem>
          <listitem>
            <para><literal>update_object()</literal>: update an object by invoking operation provided by a
                                profile type implementation, with data from a different profile object as
                                inputs;</para>
          </listitem>
          <listitem>
            <para><literal>get_details()</literal>: retrieve object details into a dictionary by invoking
                                the corresponding method provided by a profile type implementation;</para>
          </listitem>
          <listitem>
            <para><literal>join_cluster()</literal>: a hook API that will be invoked when an object is made
                                into a member of a cluster; the purpose is to give the profile type
                                implementation a chance to make changes to the object accordingly;</para>
          </listitem>
          <listitem>
            <para><literal>leave_cluster()</literal>: a hook API that will be invoked when an object is
                                removed from its current cluster; the purpose is to give the profile type
                                implementation a chance to make changes to the object accordingly;</para>
          </listitem>
          <listitem>
            <para><literal>recover_object()</literal>: recover an object with operation given by inputs from
                                the profile object. By default, <literal>recreate</literal> is used if no operation is
                                provided to delete firstly then create the object.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
    <section>
      <title>Abstract Methods</title>
      <para>In addition to the above logics, the base class <literal>Profile</literal> also defines some
                    abstract methods for a profile type implementation to implement. When invoked,
                    these methods by default return <literal>NotImplemented</literal>, a special value that
                    indicates the method is not implemented.</para>
      <itemizedlist>
        <listitem>
          <para><literal>do_create(obj)</literal>: an object creation method for a profile type
                            implementation to override;</para>
        </listitem>
        <listitem>
          <para><literal>do_delete(obj)</literal>: an object deletion method for a profile type
                            implementation to override;</para>
        </listitem>
        <listitem>
          <para><literal>do_update(obj, new_profile)</literal>: an object update method for a profile type
                            implementation to override;</para>
        </listitem>
        <listitem>
          <para><literal>do_check(obj)</literal>: a method that is meant to do a health check over the
                            provided object;</para>
        </listitem>
        <listitem>
          <para><literal>do_get_details(obj)</literal>: a method that can be overridden so that the caller
                            can get a dict that contains properties specific to the object;</para>
        </listitem>
        <listitem>
          <para><literal>do_join(obj)</literal>: a method for implementation to override so that profile
                            type specific changes can be made to the object when object joins a cluster.</para>
        </listitem>
        <listitem>
          <para><literal>do_leave(obj)</literal>: a method for implementation to override so that profile
                            type specific changes can be made to the object when object leaves its
                            cluster.</para>
        </listitem>
        <listitem>
          <para><literal>do_recover(obj)</literal>: an object recover method for a profile type
                            implementation to override. Nova server, for example, overrides the recover
                            operation by <literal>REBUILD</literal>.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>The <literal>VERSIONS</literal> Property</title>
      <para>Each profile type class has a <literal>VERSIONS</literal> class property that documents the
                    changes to the profile type. This information is returned when users request
                    to list all profile types supported.</para>
      <para>The <literal>VERSIONS</literal> property is a dict with version numbers as keys. For each
                    specific version, the value is list of support status changes made to the
                    profile type. Each change record contains a <literal>status</literal> key whose value is one
                    of <literal>EXPERIMENTAL</literal>, <literal>SUPPORTED</literal>, <literal>DEPRECATED</literal> or <literal>UNSUPPORTED</literal>, and a
                    <literal>since</literal> key whose value is of format <literal>yyyy.mm</literal> where <literal>yyyy</literal> and <literal>mm</literal>
                    are the year and month of the release that bears the change to the support
                    status. For example, the following record indicates that the specific profile
                    type was introduced in April, 2016 (i.e. version 1.0 release of Senlin) as
                    an experimental feature; later, in October, 2016 (i.e. version 2.0 release of
                    Senlin) it has graduated into a mature feature supported by the developer
                    team.</para>
      <screen><?dbsuse-fo font-size="8pt"?>VERSIONS={'1.0':[{"status":"EXPERIMENTAL","since":"2016.04"},{"status":"SUPPORTED","since":"2016.10"}]}</screen>
    </section>
    <section>
      <title>The <literal>context</literal> Property</title>
      <para>In the <literal>Profile</literal> class, there is a special property named <literal>context</literal>. This
                    is the data structure containing all necessary information needed when the
                    profile type implementation wants to authenticate with a cloud platform.
                    Refer to , Senlin makes use of the trust
                    mechanism provided by the OpenStack Keystone service.</para>
      <para>The dictionary in this <literal>context</literal> property by default contains the credentials
                    for the Senlin service account. Using the trust built between the requesting
                    user and the service account, a profile type implementation can authenticate
                    itself with the backend Keystone service and then interact with the supporting
                    service like Nova, Heat etc.</para>
      <para>All profile type implementations can include a <literal>context</literal> key in their spec,
                    the default value is an empty dictionary. A user may customize the contents
                    when creating a profile object by specifying a <literal>region_name</literal>, for example,
                    to enable a multi-region cluster deployment. They could even specify a
                    different <literal>auth_url</literal> so that a cluster can be built across OpenStack clouds.</para>
    </section>
  </section>
  <section>
    <title>Providing New Profile Types</title>
    <para>When released, Senlin provides some built-in profile types. However,
                developing new profile types for Senlin is not a difficult task.</para>
    <section>
      <title>Develop a New Profile Type</title>
      <para>The first step is to create a new file containing a subclass of <literal>Profile</literal>.
                    Then you will define the spec schema for the new profile which is a python
                    dictionary named <literal>spec_schema</literal>, with property names as keys. For each
                    property, you will specify its value to be an object of one of the schema
                    types listed below:</para>
      <itemizedlist>
        <listitem>
          <para><literal>String</literal>: A string property.</para>
        </listitem>
        <listitem>
          <para><literal>Boolean</literal>: A boolean property.</para>
        </listitem>
        <listitem>
          <para><literal>Integer</literal>: An integer property.</para>
        </listitem>
        <listitem>
          <para><literal>List</literal>: A property containing a list of values.</para>
        </listitem>
        <listitem>
          <para><literal>Map</literal>: A property containing a map of key-value pairs.</para>
        </listitem>
      </itemizedlist>
      <para>For example:</para>
      <screen><?dbsuse-fo font-size="8pt"?>spec_schema={'name':schema.String('name of object'),'capacity':schema.Integer('capacity of object',default=10),'shared':schema.Boolean('whether object is shared',default=True)}</screen>
      <para>If a profile property is a <literal>List</literal>, you can further define the type of
                    elements in the list, which can be a <literal>String</literal>, a <literal>Boolean</literal>, an
                    <literal>Integer</literal> or a <literal>Map</literal>. For example:</para>
      <screen><?dbsuse-fo font-size="8pt"?>spec_schema={...'addresses':schema.List('address of object on each network',schema=schema.String('address on a network')),...}</screen>
      <para>If a profile property is a <literal>Map</literal>, you can further define the “schema” of that
                    map, which itself is another Python dictionary containing property
                    definitions. For example:</para>
      <screen><?dbsuse-fo font-size="8pt"?>spec_schema={...'dimension':schema.Map('dimension of object',schema={'length':schema.Integer('length of object'),'width':schema.Integer('width of object')})...}</screen>
      <para>By default, a property is not required. If a property has to be provided, you
                    can specify <literal>required=True</literal> in the property type constructor. For example:</para>
      <screen>spec_schema={...'name_length':schema.Integer('length of name',required=True)...}</screen>
      <para>A property can have a default value when no value is specified. If a property
                    has a default value, you don’t need to specify it is required. For example:</para>
      <screen>spec_schema={...'min_size':schema.Integer('minimum size of object',default=0)...}</screen>
      <para>After the properties are defined, you can continue to work on overriding the
                    abstract methods inherited from the base <literal>Profile</literal> type as appropriate.</para>
    </section>
    <section>
      <title>Registering a New Profile Type</title>
      <para>For Senlin to make use of the new profile type you have just developed, you
                    will register it to Senlin service. Currently, this is done through a manual
                    process. In future, Senlin will provide dynamical loading support to profile
                    type plugins.</para>
      <para>To register a new profile type, you will add a line to the <literal>setup.cfg</literal> file
                    that can be found at the root directory of Senlin code base. For example:</para>
      <screen>[entry_points]
senlin.profiles =
    os.heat.stack-1.0 = senlin.profiles.os.heat.stack:StackProfile
    os.nova.server-1.0 = senlin.profiles.os.nova.server:ServerProfile
    my.cool.profile-1.0 = &lt;path to the profile module&gt;:&lt;profile class name&gt;</screen>
      <para>Finally, save that file and do a reinstall of the Senlin service, followed by
                    a restart of the <literal>senlin-engine</literal> process.</para>
      <screen>$ sudo pip install -e .</screen>
      <para>Now, when you do a <command>openstack cluster profile type list</command>, you will
                    see your profile type listed along with other existing profile types.</para>
    </section>
  </section>
</section>
