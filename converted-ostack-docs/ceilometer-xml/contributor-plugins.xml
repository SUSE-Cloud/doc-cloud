<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Writing Agent Plugins</title>
  <para>This documentation gives you some clues on how to write a new agent or
            plugin for Ceilometer if you wish to instrument a measurement which
            has not yet been covered by an existing plugin.</para>
  <section>
    <title>Agents</title>
    <para>Polling agent might be run either on central cloud management nodes or on the
                compute nodes (where direct hypervisor polling is quite logical).</para>
    <para>The agent running on each compute node polls for compute resources
                usage. Each meter collected is tagged with the resource ID (such as
                an instance) and the owner, including tenant and user IDs. The meters
                are then reported to the collector via the message bus. More detailed
                information follows.</para>
    <para>The agent running on the cloud central management node polls other types of
                resources from a management server (usually using OpenStack services API to
                collect this data).</para>
    <para>The polling agent is implemented in <literal>ceilometer/agent/manager.py</literal>. As
                you will see in the manager, the agent loads all plugins defined in
                the namespace <literal>ceilometer.poll.agent</literal>, then periodically calls their
                <literal>get_samples()</literal> method.</para>
  </section>
  <section>
    <title>Plugins</title>
    <para>A polling agent can support multiple plugins to retrieve different
                information and send them to the collector. As stated above, an agent
                will automatically activate all possible plugins if no additional information
                about what to poll was passed. Previously we had separated compute and
                central agents with different namespaces with plugins (pollsters) defined
                within. Currently we keep separated namespaces - <literal>ceilometer.poll.compute</literal>
                and <literal>ceilometer.poll.central</literal> for quick separation of what to poll depending
                on where is polling agent running.  This will load, among others, the
                <literal>ceilometer.compute.pollsters.cpu.CPUPollster</literal>, which is defined in
                the folder <literal>ceilometer/compute/pollsters</literal>.</para>
    <para>Notifications mechanism uses plugins as well, for instance
                <literal>ceilometer.telemetry.notifications.TelemetryApiPost</literal> plugin
                which is defined in the <literal>ceilometer/telemetry/notifications</literal> folder, Though
                in most cases, this is not needed. A meter definition can be directly added
                to <literal>ceilometer/data/meters.d/meters.yaml</literal> to match the event type. For
                more information, see the <xref linkend="meter-definitions"/> page.</para>
    <para>We are using these two existing plugins as examples as the first one provides
                an example of how to interact when you need to retrieve information from an
                external system (pollster) and the second one is an example of how to forward
                an existing event notification on the standard OpenStack queue to ceilometer.</para>
    <section>
      <title>Pollster</title>
      <para>Compute plugins are defined as subclasses of the
                    <literal>ceilometer.compute.pollsters.BaseComputePollster</literal> class as defined in
                    the <literal>ceilometer/compute/pollsters/__init__.py</literal> file. Pollsters must
                    implement one method: <literal>get_samples(self, manager, cache, resources)</literal>, which
                    returns a sequence of <literal>Sample</literal> objects as defined in the
                    <literal>ceilometer/sample.py</literal> file.</para>
      <para>In the <literal>CPUPollster</literal> plugin, the <literal>get_samples</literal> method is implemented as a
                    loop which, for each instances running on the local host, retrieves the
                    cpu_time from the hypervisor and sends back two <literal>Sample</literal> objects.  The first
                    one, named <literal>cpu</literal>, is of type “cumulative”, meaning that between two polls,
                    its value is not reset while the instance remains active, or in other words
                    that the CPU value is always provided as a duration that continuously increases
                    since the creation of the instance. The second one, named <literal>cpu_util</literal>, is of
                    type “gauge”, meaning that its value is the percentage of cpu utilization.</para>
      <para>Note that the <literal>LOG</literal> method is only used as a debugging tool and does not
                    participate in the actual metering activity.</para>
      <para>There is the way to specify either namespace(s) with pollsters or just
                    list of concrete pollsters to use, or even both of these parameters on the
                    polling agent start via CLI parameter:</para>
      <screen>ceilometer-polling --polling-namespaces central compute</screen>
      <para>This command will basically make polling agent to load all plugins from the
                    central and compute namespaces and poll everything it can. If you need to load
                    only some of the pollsters, you can use <literal>pollster-list</literal> option:</para>
      <screen>ceilometer-polling --pollster-list image image.size storage.*</screen>
      <para>If both of these options are passed, the polling agent will load only those
                    pollsters specified in the pollster list, that can be loaded from the selected
                    namespaces.</para>
      <note>
        <para>Agents coordination cannot be used in case of pollster-list option usage.
                        This allows to avoid both samples duplication and their lost.</para>
      </note>
    </section>
    <section>
      <title>Notifications</title>
      <note>
        <para>This should only be needed for cases where a complex arithmetic or
                        non-primitive data types are used. In most cases, adding a meter
                        definition to the <literal>ceilometer/data/meters.d/meters.yaml</literal> should
                        suffice.</para>
      </note>
      <para>Notifications are defined as subclass of the
                    <literal>ceilometer.agent.plugin_base.NotificationBase</literal> meta class.
                    Notifications must implement:</para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>event_types</literal>
          </term>
          <listitem>
            <para>A sequence of strings defining the event types to be given to the plugin</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>process_notification(self, message)</literal>
          </term>
          <listitem>
            <para>Receives an event message from the list provided to <literal>event_types</literal> and
                                returns a sequence of <literal>Sample</literal> objects as defined in the
                                <literal>ceilometer/sample.py</literal> file.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>In the <literal>InstanceNotifications</literal> plugin, it listens to three events:</para>
      <itemizedlist>
        <listitem>
          <para>compute.instance.create.end</para>
        </listitem>
        <listitem>
          <para>compute.instance.exists</para>
        </listitem>
        <listitem>
          <para>compute.instance.delete.start</para>
        </listitem>
      </itemizedlist>
      <para>Using the <literal>get_event_type</literal> method and subsequently the method
                    <literal>process_notification</literal> will be invoked each time such events are happening which
                    generates the appropriate sample objects to be sent to the collector.</para>
    </section>
    <section>
      <title>Adding new plugins</title>
      <para>Although we have described a list of the meters Ceilometer should
                    collect, we cannot predict all of the ways deployers will want to
                    measure the resources their customers use. This means that Ceilometer
                    needs to be easy to extend and configure so it can be tuned for each
                    installation. A plugin system based on <link xlink:href="http://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins">setuptools entry points</link>
                    makes it easy to add new monitors in the agents.  In particular,
                    Ceilometer now uses <link xlink:href="https://docs.openstack.org/stevedore/latest/">Stevedore</link>, and you should put your entry point
                    definitions in the <literal>entry_points.txt</literal> file of your Ceilometer egg.</para>
      <para>Installing a plugin automatically activates it the next time the
                    ceilometer daemon starts. Rather than running and reporting errors or
                    simply consuming cycles for no-ops, plugins may disable themselves at
                    runtime based on configuration settings defined by other components (for
                    example, the plugin for polling libvirt does not run if it sees that the system
                    is configured using some other virtualization tool). Additionally, if no
                    valid resources can be discovered the plugin will be disabled.</para>
    </section>
  </section>
  <section>
    <title>Tests</title>
    <para>Any new plugin or agent contribution will only be accepted into the project if
                provided together with unit tests.  Those are defined for the compute agent
                plugins in the directory <literal>tests/unit/compute</literal> and for the agent itself in
                <literal>tests/unit/agent</literal>. Unit tests are run in a continuous integration process for
                each commit made to the project, thus ensuring as best as possible that a given
                patch has no side effect to the rest of the project.</para>
  </section>
</section>
