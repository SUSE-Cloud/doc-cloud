<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>System Architecture</title>
  <section>
    <title>High-Level Architecture</title>
    <figure>
      <title>An overall summary of Ceilometer’s logical architecture.</title>
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="ceilo-arch.png" width="100%"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="ceilo-arch.png" width="100%"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Each of Ceilometer’s services are designed to scale horizontally. Additional
                workers and nodes can be added depending on the expected load. Ceilometer
                offers two core services:</para>
    <procedure>
      <step>
        <para>polling agent - daemon designed to poll OpenStack services and build Meters.</para>
      </step>
      <step>
        <para>notification agent - daemon designed to listen to notifications on message queue,
                        convert them to Events and Samples, and apply pipeline actions.</para>
      </step>
    </procedure>
    <para>Data normalised and collected by Ceilometer can be sent to various targets.
                <link xlink:href="http://gnocchi.xyz/">Gnocchi</link> was developed to capture measurement data in a time series format to
                optimise storage and querying. Gnocchi is intended to replace the existing
                metering database interface. Additionally, <link xlink:href="https://docs.openstack.org/aodh/latest/">Aodh</link> is the alarming service which
                can send alerts when user defined rules are broken. Lastly, <link xlink:href="https://docs.openstack.org/panko/latest/">Panko</link> is the event
                storage project designed to capture document-oriented data such as logs and
                system event actions.</para>
  </section>
  <section>
    <title>Gathering the data</title>
    <section>
      <title>How is data collected?</title>
      <figure>
        <title>This is a representation of how the collectors and agents gather data from
                        multiple sources.</title>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="1-agents.png" width="100%"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="1-agents.png" width="100%"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The Ceilometer project created 2 methods to collect data:</para>
      <procedure>
        <step>
          <para><xref linkend="term-notification-agent"/> which takes messages generated on the
                            notification bus and transforms them into Ceilometer samples or events.</para>
        </step>
        <step>
          <para><xref linkend="term-polling-agent"/>, will poll some API or other tool to collect
                            information at a regular interval. The polling approach may impose
                            significant on the API services so should only be used on optimised
                            endpoints.</para>
        </step>
      </procedure>
      <para>The first method is supported by the ceilometer-notification agent, which
                    monitors the message queues for notifications. Polling agents can be configured
                    either to poll the local hypervisor or remote APIs (public REST APIs exposed by
                    services and host-level SNMP/IPMI daemons).</para>
    </section>
    <section>
      <title>Notification Agents: Listening for data</title>
      <figure>
        <title>Notification agents consuming messages from services.</title>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="2-1-collection-notification.png" width="100%"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="2-1-collection-notification.png" width="100%"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The heart of the system is the notification daemon (agent-notification)
                    which monitors the message queue for data sent by other OpenStack
                    components such as Nova, Glance, Cinder, Neutron, Swift, Keystone, and Heat,
                    as well as Ceilometer internal communication.</para>
      <para>The notification daemon loads one or more <emphasis>listener</emphasis> plugins, using the
                    namespace <literal>ceilometer.notification</literal>. Each plugin can listen to any topic,
                    but by default, will listen to <literal>notifications.info</literal>,
                    <literal>notifications.sample</literal>, and <literal>notifications.error</literal>. The listeners grab
                    messages off the configured topics and redistributes them to the appropriate
                    plugins(endpoints) to be processed into Events and Samples.</para>
      <para>Sample-oriented plugins provide a method to list the event types they’re interested
                    in and a callback for processing messages accordingly. The registered name of the
                    callback is used to enable or disable it using the pipeline of the notification
                    daemon. The incoming messages are filtered based on their event type value before
                    being passed to the callback so the plugin only receives events it has
                    expressed an interest in seeing.</para>
    </section>
    <section>
      <title>Polling Agents: Asking for data</title>
      <figure>
        <title>Polling agents querying services for data.</title>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="2-2-collection-poll.png" width="100%"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="2-2-collection-poll.png" width="100%"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Polling for compute resources is handled by a polling agent running
                    on the compute node (where communication with the hypervisor is more
                    efficient), often referred to as the compute-agent. Polling via
                    service APIs for non-compute resources is handled by an agent running
                    on a cloud controller node, often referred to the central-agent.
                    A single agent can fulfill both roles in an all-in-one deployment.
                    Conversely, multiple instances of an agent may be deployed, in
                    which case the workload is shared. The polling agent
                    daemon is configured to run one or more <emphasis>pollster</emphasis> plugins using any
                    combination of <literal>ceilometer.poll.compute</literal>, <literal>ceilometer.poll.central</literal>, and
                    <literal>ceilometer.poll.ipmi</literal> namespaces</para>
      <para>The frequency of polling is controlled via the polling configuration. See
                    <xref linkend="polling-configuration"/> for details. The agent framework then passes the
                    generated samples to the notification agent for processing.</para>
    </section>
  </section>
  <section>
    <title>Processing the data</title>
    <section>
      <title>Pipeline Manager</title>
      <figure>
        <title>The assembly of components making the Ceilometer pipeline.</title>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="3-Pipeline.png" width="100%"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="3-Pipeline.png" width="100%"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Ceilometer offers the ability to take data gathered by the agents, manipulate
                    it, and publish it in various combinations via multiple pipelines. This
                    functionality is handled by the notification agents.</para>
    </section>
    <section>
      <title>Transforming the data</title>
      <figure>
        <title>Example of aggregation of multiple cpu time usage samples in a single
                        cpu percentage sample.</title>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="4-Transformer.png" width="100%"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="4-Transformer.png" width="100%"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The data gathered from the polling and notifications agents contains a wealth
                    of data and if combined with historical or temporal context, can be used to
                    derive even more data. Ceilometer offers various transformers which can be used
                    to manipulate data in the pipeline.</para>
      <note>
        <para>The equivalent functionality can be handled more stably by storage
                        drivers such as Gnocchi.</para>
      </note>
    </section>
    <section>
      <title>Publishing the data</title>
      <figure>
        <title>This figure shows how a sample can be published to multiple destinations.</title>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="5-multi-publish.png" width="100%"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="5-multi-publish.png" width="100%"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Currently, processed data can be published using 7 different transports:</para>
      <procedure>
        <step>
          <para>gnocchi, which publishes samples/events to Gnocchi API;</para>
        </step>
        <step>
          <para>notifier, a notification based publisher which pushes samples to a message queue
                            which can be consumed by an external system;</para>
        </step>
        <step>
          <para>udp, which publishes samples using UDP packets;</para>
        </step>
        <step>
          <para>http, which targets a REST interface;</para>
        </step>
        <step>
          <para>file, which publishes samples to a file with specified name and location;</para>
        </step>
      </procedure>
    </section>
  </section>
  <section>
    <title>Storing/Accessing the data</title>
    <para>Ceilometer is designed solely to generate and normalise cloud data. The data
                created by Ceilometer can be pushed to any number of target using publishers
                mentioned in pipeline-publishers section. The recommended workflow is to
                push data to <link xlink:href="http://gnocchi.xyz/">Gnocchi</link> for efficient time-series storage and resource lifecycle
                tracking.</para>
  </section>
</section>
