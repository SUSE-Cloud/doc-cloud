<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Federated Identity</title>
  <para>Keystone’s one-stop-shop for all federated identity documentation.</para>
  <section>
    <title>Configuring Keystone for Federation</title>
    <section>
      <title>Definitions</title>
      <itemizedlist>
        <listitem>
          <para><literal>Service Provider (SP)</literal>: provides a service to an end-user.</para>
        </listitem>
        <listitem>
          <para><literal>Identity Provider (IdP)</literal>: service that stores information about users and
                            groups.</para>
        </listitem>
        <listitem>
          <para><literal>SAML assertion</literal>: contains information about a user as provided by an IdP.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Keystone as a Service Provider (SP)</title>
      <note>
        <para>This feature is considered stable and supported as of the Juno release.</para>
      </note>
      <section>
        <title>Prerequisites</title>
        <para>This approach to federation supports keystone as a Service Provider, consuming
                        identity properties issued by an external Identity Provider, such as SAML
                        assertions or OpenID Connect claims, or by using
                        <xref linkend="keystone-as-an-identity-provider-idp"/>.</para>
        <para>Federated users are not mirrored in the keystone identity backend
                        (for example, using the SQL driver). The external Identity Provider is
                        responsible for authenticating users, and communicates the result of
                        authentication to keystone using identity properties. Keystone maps these
                        values to keystone user groups and assignments created in keystone.</para>
        <para>The following configuration steps were performed on a machine running
                        Ubuntu 14.04 and Apache 2.4.7.</para>
        <para>To enable federation, you’ll need to:</para>
        <procedure>
          <step>
            <para><link xlink:href="../apache-httpd.html">Run keystone under Apache</link>, rather than using uwsgi command.</para>
          </step>
          <step>
            <para><xref linkend="configure-apache-to-use-a-federation-capable-authentication-method"/>.</para>
          </step>
          <step>
            <para><xref linkend="configure-federation-in-keystone"/>.</para>
          </step>
        </procedure>
        <section xml:id="configure-apache-to-use-a-federation-capable-authentication-method">
          <title>Configure Apache to use a federation capable authentication method</title>
          <para>There is currently support for two major federation protocols:</para>
          <itemizedlist>
            <listitem>
              <para>SAML - Keystone supports the following implementations:</para>
              <itemizedlist>
                <listitem>
                  <para>Shibboleth - see <link xlink:href="shibboleth.html">Setup Shibboleth</link>.</para>
                </listitem>
                <listitem>
                  <para>Mellon - see <link xlink:href="mellon.html">Setup Mellon</link>.</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>OpenID Connect - see <link xlink:href="openidc.html">Setup OpenID Connect</link>.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section>
          <title>Configure keystone and Horizon for Single Sign-On</title>
          <itemizedlist>
            <listitem>
              <para>To configure horizon to access a federated keystone,
                                    follow the steps outlined at: <link xlink:href="websso.html">Keystone Federation and Horizon</link>.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
      <section xml:id="configure-federation-in-keystone">
        <title>Configure Federation in Keystone</title>
        <para>Now that the Identity Provider and keystone are communicating we can start to
                        configure <literal>federation</literal>.</para>
        <procedure>
          <step>
            <para>
              <link xlink:href="federated_identity.html#configure-authentication-drivers-in-keystone-conf">Configure authentication drivers in keystone.conf</link>
            </para>
          </step>
          <step>
            <para>
              <xref linkend="create-keystone-groups-and-assign-roles"/>
            </para>
          </step>
          <step>
            <para>
              <xref linkend="add-identity-provider-s-mapping-s-and-protocol-s"/>
            </para>
          </step>
        </procedure>
        <section>
          <title>Configure authentication drivers in keystone.conf</title>
          <para>Add the authentication methods to the <literal>[auth]</literal> section in <literal>keystone.conf</literal>.
                            Names should be equal to protocol names added via Identity API v3. Here we use
                            examples <literal>mapped</literal> and <literal>openid</literal>.</para>
          <screen language="bash">[auth]
methods = external,password,token,mapped,openid</screen>
        </section>
        <section xml:id="create-keystone-groups-and-assign-roles">
          <title>Create keystone groups and assign roles</title>
          <para>As mentioned earlier, no new users will be added to the Identity backend, but
                            the Identity Service requires group-based role assignments to authorize
                            federated users. The federation mapping function will map the user into local
                            Identity Service groups objects, and hence to local role assignments.</para>
          <para>Thus, it is required to create the necessary Identity Service groups that
                            correspond to the Identity Provider’s groups; additionally, these groups should
                            be assigned roles on one or more projects or domains.</para>
          <para>You may be interested in more information on <link xlink:href="https://developer.openstack.org/api-ref/identity/v3/#create-group">group management</link>
                            and <link xlink:href="https://developer.openstack.org/api-ref/identity/v3/#assign-role-to-group-on-project">role assignments</link>,
                            both of which are exposed to the CLI via <link xlink:href="https://pypi.python.org/pypi/python-openstackclient/">python-openstackclient</link>.</para>
          <para>For example, create a new domain and project like this:</para>
          <screen language="bash">$ openstack domain create federated_domain
$ openstack project create federated_project --domain federated_domain</screen>
          <para>And a new group like this:</para>
          <screen language="bash">$ openstack group create federated_users</screen>
          <para>Add the group to the domain and project:</para>
          <screen language="bash">$ openstack role add --group federated_users --domain federated_domain Member
$ openstack role add --group federated_users --project federated_project Member</screen>
          <para>We’ll later add a mapping that makes all federated users a part of this group
                            and therefore members of the new domain.</para>
        </section>
        <section xml:id="add-identity-provider-s-mapping-s-and-protocol-s">
          <title>Add Identity Provider(s), Mapping(s), and Protocol(s)</title>
          <para>To utilize federation the following must be created in the Identity Service:</para>
          <itemizedlist>
            <listitem>
              <para>
                <xref linkend="identity-provider"/>
              </para>
            </listitem>
            <listitem>
              <para>
                <link xlink:href="configure_federation.html#mapping">Mapping</link>
              </para>
            </listitem>
            <listitem>
              <para>
                <xref linkend="protocol"/>
              </para>
            </listitem>
          </itemizedlist>
          <para>Read more about <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#os-federation-api">federation in keystone</link>.</para>
          <section xml:id="identity-provider">
            <title>Identity Provider</title>
            <para>Create an Identity Provider object in keystone, which represents the Identity
                                Provider we will use to authenticate end users:</para>
            <screen language="bash"><?dbsuse-fo font-size="8pt"?>$ openstack identity provider create --remote-id https://myidp.example.com/v3/OS-FEDERATION/saml2/idp myidp</screen>
            <para>The value for the <literal>remote-id</literal> option is the unique identifier provided by the
                                IdP. For a SAML IdP it can found as the EntityDescriptor entityID in the IdP’s
                                provided metadata. If the IdP is a keystone IdP, it is the value set in that
                                keystone’s <literal>[saml]/idp_entity_id</literal> option. For an OpenID Connect IdP, it is
                                the IdP’s Issuer Identifier. It will usually appear as a URI but there is no
                                requirement for it to resolve to anything and may be arbitrarily decided by the
                                administrator of the IdP. The local name, here called ‘myidp’, is decided by
                                you and will be used by the mapping and protocol, and later for authentication.</para>
            <para>A keystone identity provider may have multiple <literal>remote_ids</literal> specified, this
                                allows the same <emphasis>keystone</emphasis> identity provider resource to be used with multiple
                                external identity providers. For example, an identity provider resource
                                <literal>university-idp</literal>, may have the following <literal>remote_ids</literal>:
                                <literal>['university-x', 'university-y', 'university-z']</literal>.
                                This removes the need to configure N identity providers in keystone.</para>
            <note>
              <para>Remote IDs are globally unique. Two identity providers cannot be
                                    associated with the same remote ID. Once authenticated with the external
                                    identity provider, keystone will determine which identity provider
                                    and mapping to use based on the protocol and the value returned from the
                                    <literal>remote_id_attribute</literal> key.</para>
              <para>For example, if our identity provider is <literal>google</literal>, the mapping used is
                                    <literal>google_mapping</literal> and the protocol is <literal>openid</literal>. The identity provider’s
                                    remote IDs  would be: [<literal>https://accounts.google.com</literal>].
                                    The <literal>remote_id_attribute</literal> value may be set to <literal>HTTP_OIDC_ISS</literal>, since
                                    this value will always be <literal>https://accounts.google.com</literal>.</para>
              <para>The motivation for this approach is that there will always be some data
                                    sent by the identity provider (in the assertion or claim) that uniquely
                                    identifies the identity provider. This removes the requirement for horizon
                                    to list all the identity providers that are trusted by keystone.</para>
            </note>
            <para>Read more about <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#identity-providers">identity providers</link>.</para>
          </section>
          <section>
            <title>Mapping</title>
            <para>A mapping is a list of rules. The only Identity API objects that will support mapping are groups
                                and users.</para>
            <para>Mapping adds a set of rules to map federation protocol attributes to Identity API objects.
                                There are many different ways to setup as well as combine these rules. More information on
                                rules can be found on the  page.</para>
            <para>An Identity Provider has exactly one mapping specified per protocol.
                                Mapping objects can be used multiple times by different combinations of Identity Provider and Protocol.</para>
            <para>As a simple example, if keystone is your IdP, you can map a few known remote
                                users to the group you already created:</para>
            <screen language="bash">$ cat &gt; rules.json &lt;&lt;EOF
[
    {
        "local": [
            {
                "user": {
                    "name": "{0}"
                },
                "group": {
                    "domain": {
                        "name": "Default"
                    },
                    "name": "federated_users"
                }
            }
        ],
        "remote": [
            {
                "type": "openstack_user",
                "any_one_of": [
                    "demo",
                    "alt_demo"
                ]
            }
        ]
    }
]
EOF
$ openstack mapping create --rules rules.json myidp_mapping</screen>
            <para>As another example, if Shibboleth is your IdP, the remote section should use REMOTE_USER as the remote type:</para>
            <screen language="bash">$ cat &gt; rules.json &lt;&lt;EOF
[
    {
        "local": [
            {
                "user": {
                    "name": "{0}"
                },
                "group": {
                    "domain": {
                        "name": "Default"
                    },
                    "name": "federated_users"
                }
            }
        ],
        "remote": [
            {
                "type": "REMOTE_USER"
            }
        ]
    }
]
EOF
$ openstack mapping create --rules rules.json myidp_mapping</screen>
            <para>Read more about <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#mappings">mapping</link>.</para>
          </section>
          <section xml:id="protocol">
            <title>Protocol</title>
            <para>A protocol contains information that dictates which Mapping rules to use for an incoming
                                request made by an IdP. An IdP may have multiple supported protocols.</para>
            <para>You can create a protocol like this:</para>
            <screen language="bash"><?dbsuse-fo font-size="8pt"?>$ openstack federation protocol create mapped --mapping myidp_mapping --identity-provider myidp</screen>
            <para>The name you give the protocol is not arbitrary. It must match the method name
                                you gave in the <literal>[auth]/methods</literal> config option. When authenticating it will be
                                referred to as the <literal>protocol_id</literal>.</para>
            <para>Read more about <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#protocols">federation protocols</link></para>
          </section>
        </section>
      </section>
      <section>
        <title>Performing federated authentication</title>
        <note>
          <para>Authentication with keystone-to-keystone federation does not follow these steps.
                            See <xref linkend="testing-it-all-out"/> to authenticate with keystone-to-keystone.</para>
        </note>
        <procedure>
          <step>
            <para>Authenticate externally and generate an unscoped token in keystone</para>
          </step>
          <step>
            <para>Determine accessible resources</para>
          </step>
          <step>
            <para>Get a scoped token</para>
          </step>
        </procedure>
        <section xml:id="get-an-unscoped-token">
          <title>Get an unscoped token</title>
          <para>Unlike other authentication methods in the Identity Service, the user does not
                            issue an HTTP POST request with authentication data in the request body. To
                            start federated authentication a user must access the dedicated URL with
                            Identity Provider’s and Protocol’s identifiers stored within a protected URL.
                            The URL has a format of:
                            <literal>/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth</literal>.</para>
          <para>In this instance we follow a standard SAML2 authentication procedure, that is,
                            the user will be redirected to the Identity Provider’s authentication webpage
                            and be prompted for credentials. After successfully authenticating the user
                            will be redirected to the Service Provider’s endpoint. If using a web browser,
                            a token will be returned in JSON format, with the ID in the X-Subject-Token
                            header.</para>
          <para>In the returned unscoped token, a list of Identity Service groups the user
                            belongs to will be included.</para>
          <para>Read more about <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#request-an-unscoped-os-federation-token">getting an unscoped token</link>.</para>
          <section>
            <title>Example cURL</title>
            <para>Note that the request does not include a body. The following url would be
                                considered protected by <literal>mod_shib</literal> and Apache, as such a request made
                                to the URL would be redirected to the Identity Provider, to start the
                                SAML authentication procedure.</para>
            <screen language="bash"><?dbsuse-fo font-size="8pt"?>$ curl -X GET -D - http://localhost:5000/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth</screen>
          </section>
        </section>
        <section>
          <title>Determine accessible resources</title>
          <para>By using the previously returned token, the user can issue requests to the list
                            projects and domains that are accessible.</para>
          <itemizedlist>
            <listitem>
              <para>List projects a federated user can access: <literal>GET /OS-FEDERATION/projects</literal></para>
            </listitem>
            <listitem>
              <para>List domains a federated user can access: <literal>GET /OS-FEDERATION/domains</literal></para>
            </listitem>
          </itemizedlist>
          <para>Read more about <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#list-projects-a-federated-user-can-access">listing resources</link>.</para>
          <section>
            <title>Example</title>
            <screen language="bash">$ export OS_IDENTITY_API_VERSION=3
$ export OS_TOKEN=&lt;unscoped token&gt;
$ export OS_URL=http://localhost:5000/v3
$ openstack federation project list</screen>
            <para>or</para>
            <screen language="bash">$ export OS_IDENTITY_API_VERSION=3
$ export OS_TOKEN=&lt;unscoped token&gt;
$ export OS_URL=http://localhost:5000/v3
$ openstack federation domain list</screen>
          </section>
        </section>
        <section>
          <title>Get a scoped token</title>
          <para>A federated user may request a scoped token, by using the unscoped token. A
                            project or domain may be specified by either <literal>id</literal> or <literal>name</literal>. An <literal>id</literal> is
                            sufficient to uniquely identify a project or domain.</para>
          <para>Read more about <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#request-a-scoped-os-federation-token">getting a scoped token</link>.</para>
          <section>
            <title>Example</title>
            <screen language="bash">$ export OS_AUTH_TYPE=token
$ export OS_IDENTITY_API_VERSION=3
$ export OS_TOKEN=&lt;unscoped token&gt;
$ export OS_AUTH_URL=http://localhost:5000/v3
$ export OS_PROJECT_DOMAIN_NAME=federated_domain
$ export OS_PROJECT_NAME=federated_project
$ openstack token issue</screen>
          </section>
        </section>
      </section>
    </section>
    <section xml:id="keystone-as-an-identity-provider-idp">
      <title>Keystone as an Identity Provider (IdP)</title>
      <note>
        <para>This feature is experimental and unsupported in Juno (with several issues
                        that will not be backported). These issues have been fixed and this feature
                        is considered stable and supported as of the Kilo release.</para>
      </note>
      <note>
        <para>This feature requires installation of the xmlsec1 tool via your
                        distribution packaging system (for instance apt or yum)</para>
        <para>Example for apt:</para>
        <screen language="bash">$ apt-get install xmlsec1</screen>
      </note>
      <section>
        <title>Configuration Options</title>
        <para>There are certain settings in <literal>keystone.conf</literal> that must be setup, prior to
                        attempting to federate multiple keystone deployments.</para>
        <para>Within <literal>keystone.conf</literal>, assign values to the <literal>[saml]</literal> related fields, for
                        example:</para>
        <screen language="ini">[saml]
idp_entity_id=https://myidp.example.com/v3/OS-FEDERATION/saml2/idp
idp_sso_endpoint=https://myidp.example.com/v3/OS-FEDERATION/saml2/sso</screen>
        <para><literal>idp_entity_id</literal> is the unique identifier for the Identity Provider. It
                        usually takes the form of a URI but it does not have to resolve to anything.
                        <literal>idp_sso_endpoint</literal> is required to generate valid metadata but its value is
                        not important, though it may be in the future.</para>
        <para>Note the <literal>certfile</literal>, <literal>keyfile</literal>, and <literal>idp_metadata_path</literal> settings and adjust them if
                        necessary:</para>
        <screen language="ini">certfile=/etc/keystone/ssl/certs/signing_cert.pem
keyfile=/etc/keystone/ssl/private/signing_key.pem
idp_metadata_path=/etc/keystone/saml2_idp_metadata.xml</screen>
        <para>Though not necessary, the follow Organization configuration options should
                        also be setup. It is recommended that these values be URL safe.</para>
        <screen language="ini">idp_organization_name=example_company
idp_organization_display_name=Example Corp.
idp_organization_url=example.com</screen>
        <para>As with the Organization options, the Contact options, are not necessary, but
                        it’s advisable to set these values too.</para>
        <screen language="ini">idp_contact_company=example_company
idp_contact_name=John
idp_contact_surname=Smith
idp_contact_email=jsmith@example.com
idp_contact_telephone=555-555-5555
idp_contact_type=technical</screen>
      </section>
      <section>
        <title>Generate Metadata</title>
        <para>In order to create a trust between the IdP and SP, metadata must be exchanged.</para>
        <para>First, if you haven’t already generated a PKI key pair, you need to do so and
                        copy those files the locations designated by <literal>certfile</literal> and <literal>keyfile</literal>
                        options that were assigned in the previous section. Ensure that your apache
                        vhost has SSL enabled and is using that keypair by adding the following to the
                        vhost:</para>
        <screen>SSLEngine on
SSLCertificateFile /etc/keystone/ssl/certs/signing_cert.pem
SSLCertificateKeyFile /etc/keystone/ssl/private/signing_key.pem</screen>
        <para>To create metadata for your keystone IdP, run the <literal>keystone-manage</literal> command
                        and redirect the output to a file. For example:</para>
        <screen language="bash">$ keystone-manage saml_idp_metadata &gt; /etc/keystone/saml2_idp_metadata.xml</screen>
        <note>
          <para>The file location should match the value of the configuration option
                            <literal>idp_metadata_path</literal> that was assigned in the previous section.</para>
        </note>
        <para>Finally, restart apache.</para>
      </section>
      <section>
        <title>Create a Service Provider (SP)</title>
        <para>In this example we are creating a new Service Provider with an ID of <literal>mysp</literal>,
                        a <literal>sp_url</literal> of <literal>http://mysp.example.com/Shibboleth.sso/SAML2/ECP</literal> and a
                        <literal>auth_url</literal> of <literal>http://mysp.example.com:5000/v3/OS-FEDERATION/identity_providers/myidp/protocols/mapped/auth</literal>
                        . The <literal>sp_url</literal> will be used when creating a SAML assertion for <literal>mysp</literal> and
                        signed by the current keystone IdP. The <literal>auth_url</literal> is used to retrieve the
                        token for <literal>mysp</literal> once the SAML assertion is sent. The auth_url has the format
                        described in <xref linkend="get-an-unscoped-token"/>.</para>
        <screen language="bash"><?dbsuse-fo font-size="8pt"?>$ openstack service provider create --service-provider-url 'http://mysp.example.com/Shibboleth.sso/SAML2/ECP' --auth-url http://mysp.example.com:5000/v3/OS-FEDERATION/identity_providers/myidp/protocols/mapped/auth mysp</screen>
      </section>
      <section xml:id="testing-it-all-out">
        <title>Testing it all out</title>
        <para>Use keystoneauth to create a password session with the IdP, then use the
                        session to authenticate with the SP, and get a scoped token from the SP.</para>
        <note>
          <para>ECP stands for Enhanced Client or Proxy, an extension from the SAML2
                            protocol used in non-browser interfaces, like in the following example.</para>
        </note>
        <screen language="python">import os

from keystoneauth1 import session
from keystoneauth1.identity import v3
from keystoneauth1.identity.v3 import k2k

auth = v3.Password(auth_url=os.environ.get('OS_AUTH_URL'),
                   username=os.environ.get('OS_USERNAME'),
                   password=os.environ.get('OS_PASSWORD'),
                   user_domain_name=os.environ.get('OS_USER_DOMAIN_NAME'),
                   project_name=os.environ.get('OS_PROJECT_NAME'),
                   project_domain_name=os.environ.get('OS_PROJECT_DOMAIN_NAME'))
password_session = session.Session(auth=auth)
k2ksession = k2k.Keystone2Keystone(password_session.auth, 'mysp',
                                   domain_name='federated_domain')
auth_ref = k2ksession.get_auth_ref(password_session)
scoped_token_id = auth_ref.auth_token
print('Scoped token id: %s' % scoped_token_id)</screen>
      </section>
    </section>
  </section>
  <section>
    <title>Mapping Combinations</title>
    <section>
      <title>Description</title>
      <para>During the authentication process an identity provider (IdP) will present
                    keystone with a set of user attributes about the user that is authenticating.
                    For example, in the SAML2 flow this comes to keystone in the form of a SAML
                    document.</para>
      <para>The attributes are typically processed by third-party software and are presented
                    to keystone as environment variables. The original document from the IdP is
                    generally not available to keystone. This is how the <literal>Shibboleth</literal> and <literal>Mellon</literal>
                    implementations work.</para>
      <para>The mapping format described in this document maps these environment variables
                    to a local keystone user. The mapping may also define group membership for
                    that user and projects the user can access.</para>
      <para>An IdP has exactly one mapping specified per protocol. Mappings themselves can
                    be used multiple times by different combinations of IdP and protocol.</para>
    </section>
    <section>
      <title>Definitions</title>
      <para>A mapping looks as follows:</para>
      <screen language="none">{
    "rules": [
        {
            "local": [
                {
                    &lt;user&gt;
                    [&lt;group&gt;]
                    [&lt;project&gt;]
                }
            ],
            "remote": [
                {
                    &lt;match&gt;
                    [&lt;condition&gt;]
                }
            ]
        }
    ]
}</screen>
      <itemizedlist>
        <listitem>
          <para><literal>mapping</literal>: a JSON object containing a list of rules.</para>
        </listitem>
        <listitem>
          <para><literal>rules</literal>: a property in the mapping that contains the list of rules.</para>
        </listitem>
        <listitem>
          <para><literal>rule</literal>: a JSON object containing <literal>local</literal> and <literal>remote</literal> properties to define
                            the rule. There is no explicit <literal>rule</literal> property.</para>
        </listitem>
        <listitem>
          <para><literal>local</literal>: a JSON object containing information on what local attributes will
                            be mapped. The mapping engine processes this using the <literal>context</literal> (defined
                            below) and the result is a representation of the user from keystone’s
                            perspective.</para>
          <itemizedlist>
            <listitem>
              <para><literal>&lt;user&gt;</literal>: the local user that will be mapped to the federated user.</para>
            </listitem>
            <listitem>
              <para><literal>&lt;group&gt;</literal>: (optional) the local groups the federated user will be placed in.</para>
            </listitem>
            <listitem>
              <para><literal>&lt;projects&gt;</literal>: (optional) the local projects mapped to the federated user.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><literal>remote</literal>: a JSON object containing information on what remote attributes will be mapped.</para>
          <itemizedlist>
            <listitem>
              <para><literal>&lt;match&gt;</literal>: a JSON object that tells the mapping engine what federated attribute
                                    to make available for substitution in the local object. There can be one or more
                                    of these objects in the <literal>remote</literal> list.</para>
            </listitem>
            <listitem>
              <para><literal>&lt;condition&gt;</literal>: a JSON object containing conditions that allow a rule. There can be
                                    zero or more of these objects in the <literal>remote</literal> list.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><literal>direct mapping</literal>: the mapping engine keeps track of each match and makes them
                            available to the local rule for substitution.</para>
        </listitem>
        <listitem>
          <para><literal>assertion</literal>: data provided to keystone by the IdP to assert facts
                            (name, groups, etc) about the authenticating user. This is an XML document when
                            using the SAML2 protocol.</para>
        </listitem>
        <listitem>
          <para><literal>mapping context</literal>: the data, represented as key-value pairs, that is used by the
                            mapping engine to turn the <literal>local</literal> object into a representation of the user
                            from keystone’s perspective. The mapping context contains the environment of the
                            keystone process and any <literal>direct mapping</literal> values calculated when processing the
                            <literal>remote</literal> list.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>How Mappings Are Processed</title>
      <para>A mapping is selected by IdP and protocol. Then keystone takes the mapping and
                    processes each rule sequentially stopping after the first matched rule. A rule
                    is matched when all of its conditions are met.</para>
      <para>First keystone evaluates each condition from the rule’s remote property to see
                    if the rule is a match. If it is a match, keystone saves the data captured by
                    each of the matches from the rule’s remote property in an ordered list. We call
                    these matches <literal>direct mappings</literal> since they can be used in the next step.</para>
      <para>After the rule is found using the rule’s conditions and a list of direct mappings is
                    stored, keystone begins processing the rule’s <literal>local</literal> property. Each object in
                    the <literal>local</literal> property is collapsed into a single JSON object. For example:</para>
      <screen language="none">{
    "local": [
        {
            "user": {...}
        },
        {
            "projects": [...]
        },
    ]
}</screen>
      <para>becomes:</para>
      <screen language="none">{
    "local": {
        "user": {...}
        "projects": [...]
    },
}</screen>
      <para>when the same property exists in the local multiple times the first occurrence wins:</para>
      <screen language="none">{
    "local": [
        {
            "user": {#first#}
        },
        {
            "projects": [...]
        },
        {
            "user": {#second#}
        },
    ]
}</screen>
      <para>becomes:</para>
      <screen language="none">{
    "local": {
        "user": {#first#}
        "projects": [...]
    },
}</screen>
      <para>We take this JSON object and then recursively process it in order to apply
                    the direct mappings. This is simply looking for the pattern <literal>{#}</literal> and
                    substituting it with values from the direct mappings list. The index of the
                    direct mapping starts at zero.</para>
    </section>
    <section>
      <title>Mapping Rules</title>
      <section>
        <title>Mapping Engine</title>
        <para>The mapping engine can be tested before creating a federated setup. It can be
                        tested with the <literal>keystone-manage mapping_engine</literal> command:</para>
        <screen language="bash">$ keystone-manage mapping_engine --rules &lt;file&gt; --input &lt;file&gt;</screen>
        <note>
          <para>Although the rules file is formatted as JSON, the input file of assertion
                            data is formatted as individual lines of key: value pairs, see
                            <literal>keystone-manage mapping_engine –help</literal> for details.</para>
        </note>
      </section>
      <section>
        <title>Mapping Conditions</title>
        <para>Mappings support 5 different types of conditions:</para>
        <para><literal>empty</literal>: The rule is matched to all claims containing the remote attribute type.
                        This condition does not need to be specified.</para>
        <para><literal>any_one_of</literal>: The rule is matched only if any of the specified strings appear
                        in the remote attribute type. Condition result is boolean, not the argument that
                        is passed as input.</para>
        <para><literal>not_any_of</literal>: The rule is not matched if any of the specified strings appear
                        in the remote attribute type. Condition result is boolean, not the argument that
                        is passed as input.</para>
        <para><literal>blacklist</literal>: This rule removes all groups matched from the assertion. It is
                        not intended to be used as a way to prevent users, or groups of users, from
                        accessing the service provider. The output from filtering through a blacklist
                        will be all groups from the assertion that were not listed in the blacklist.</para>
        <para><literal>whitelist</literal>: This rule explicitly states which groups should be carried over
                        from the assertion. The result is the groups present in the assertion and in
                        the whitelist.</para>
        <note>
          <para><literal>empty</literal>, <literal>blacklist</literal> and <literal>whitelist</literal> are the only conditions that can
                            be used in direct mapping ({0}, {1}, etc.)</para>
        </note>
        <para>Multiple conditions can be combined to create a single rule.</para>
      </section>
      <section>
        <title>Mappings Examples</title>
        <para>The following are all examples of mapping rule types.</para>
        <section>
          <title>empty condition</title>
          <screen language="json">{
    "rules": [
        {
            "local": [
                {
                    "user": {
                        "name": "{0} {1}",
                        "email": "{2}"
                    },
                    "group": {
                        "name": "{3}",
                        "domain": {
                            "id": "0cd5e9"
                        }
                    }
                }
            ],
            "remote": [
                {
                    "type": "FirstName"
                },
                {
                    "type": "LastName"
                },
                {
                    "type": "Email"
                },
                {
                    "type": "OIDC_GROUPS"
                }
            ]
        }
    ]
}</screen>
          <note>
            <para>The numbers in braces {} are indices, they map in order. For example:</para>
            <screen><?dbsuse-fo font-size="8pt"?>- Mapping to user with the name matching the value in remote attribute FirstName
- Mapping to user with the name matching the value in remote attribute LastName
- Mapping to user with the email matching value in remote attribute Email
- Mapping to a group(s) with the name matching the value(s) in remote attribute OIDC_GROUPS</screen>
          </note>
          <para>Groups can have multiple values. Each value must be separated by a <literal>;</literal>
                            Example: OIDC_GROUPS=developers;testers</para>
        </section>
        <section>
          <title>other conditions</title>
          <para>In <literal>&lt;other_condition&gt;</literal> shown below, please supply one of the following:
                            <literal>any_one_of</literal>, or <literal>not_any_of</literal>.</para>
          <screen language="json">{
    "rules": [
        {
            "local": [
                {
                    "user": {
                        "name": "{0}"
                    },
                    "group": {
                        "id": "0cd5e9"
                    }
                }
            ],
            "remote": [
                {
                    "type": "UserName"
                },
                {
                    "type": "HTTP_OIDC_GROUPIDS",
                    "&lt;other_condition&gt;": [
                        "HTTP_OIDC_EMAIL"
                    ]
                }
            ]
        }
    ]
}</screen>
          <para>In <literal>&lt;other_condition&gt;</literal> shown below, please supply one of the following:
                            <literal>blacklist</literal>, or <literal>whitelist</literal>.</para>
          <screen language="json">{
    "rules": [
        {
            "local": [
                {
                    "user": {
                        "name": "{0}"
                    }
                },
                {
                    "groups": "{1}",
                    "domain": {
                        "id": "0cd5e9"
                    }
                }
            ],
            "remote": [
                {
                    "type": "UserName"
                },
                {
                    "type": "HTTP_OIDC_GROUPIDS",
                    "&lt;other_condition&gt;": [
                        "me@example.com"
                    ]
                }
            ]
        }
    ]
}</screen>
          <note>
            <para>If the user id and name are not specified in the mapping, the server tries to
                                directly map <literal>REMOTE_USER</literal> environment variable. If this variable is also
                                unavailable the server returns an HTTP 401 Unauthorized error.</para>
          </note>
          <para>Group ids and names can be provided in the local section:</para>
          <screen language="json">{
    "local": [
        {
            "group": {
                "id":"0cd5e9"
            }
        }
    ]
}</screen>
          <screen language="json">{
    "local": [
        {
            "group": {
                "name": "developer_group",
                "domain": {
                    "id": "abc1234"
                }
            }
        }
    ]
}</screen>
          <screen language="json">{
    "local": [
        {
            "group": {
                "name": "developer_group",
                "domain": {
                    "name": "private_cloud"
                }
            }
        }
    ]
}</screen>
          <para>Users can be mapped to local users that already exist in keystone’s identity
                            backend by setting the <literal>type</literal> attribute of the user to <literal>local</literal> and providing
                            the domain to which the local user belongs:</para>
          <screen language="json">{
    "local": [
        {
            "user": {
                "name": "local_user",
                "type": "local",
                "domain": {
                    "name": "local_domain"
                }
            }
        }
    ]
}</screen>
          <para>The user is then treated as existing in the local identity backend, and the
                            server will attempt to fetch user details (id, name, roles, groups) from the
                            identity backend. The local user and domain are not generated dynamically, so
                            if they do not exist in the local identity backend, authentication attempts
                            will result in a 401 Unauthorized error.</para>
          <para>If you omit the <literal>type</literal> attribute or set it to <literal>ephemeral</literal> or do not provide a
                            domain, the user is deemed ephemeral and becomes a member of the identity
                            provider’s domain. It will not be looked up in the local keystone backend, so
                            all of its attributes must come from the IdP and the mapping rules.</para>
          <note>
            <para>Domain <literal>Federated</literal> is a service domain - it cannot be listed, displayed,
                                added or deleted.  There is no need to perform any operation on it prior to
                                federation configuration.</para>
          </note>
        </section>
      </section>
      <section>
        <title>Output</title>
        <para>If a mapping is valid you will receive the following output:</para>
        <screen language="none">{
    "group_ids": "[&lt;group-ids&gt;]",
    "user":
        {
            "domain":
                {
                    "id": "Federated" or "&lt;local-domain-id&gt;"
                },
            "type": "ephemeral" or "local",
            "name": "&lt;local-user-name&gt;",
            "id": "&lt;local-user-id&gt;"
        },
    "group_names":
        [
            {
                "domain":
                    {
                        "name": "&lt;domain-name&gt;"
                    },
                "name":
                    {
                        "name": "[&lt;groups-names&gt;]"
                    }
            }
            {
                "domain":
                    {
                        "name": "&lt;domain-name&gt;"
                    },
                "name":
                    {
                        "name": "[&lt;groups-names&gt;]"
                    }
            }
        ]
}</screen>
        <para>If the mapped user is local, mapping engine will discard further group
                        assigning and return set of roles configured for the user.</para>
      </section>
      <section>
        <title>Regular Expressions</title>
        <para>Regular expressions can be used in a mapping by specifying the <literal>regex</literal> key, and
                        setting it to <literal>true</literal>.</para>
        <screen language="json">{
    "rules": [
        {
            "local": [
                {
                    "user": {
                        "name": "{0}"
                    },
                    "group": {
                        "id": "0cd5e9"
                    }
                },
            ],
            "remote": [
                {
                    "type": "UserName"
                },
                {
                    "type": "HTTP_OIDC_GROUPIDS",
                    "any_one_of": [
                        ".*@yeah.com$"
                    ]
                    "regex": true
                }
            ]
        }
    ]
}</screen>
        <para>This allows any user with a claim containing a key with any value in
                        <literal>HTTP_OIDC_GROUPIDS</literal> to be mapped to group with id <literal>0cd5e9</literal>.</para>
      </section>
      <section>
        <title>Condition Combinations</title>
        <para>Combinations of mappings conditions can also be done.</para>
        <para><literal>empty</literal>, <literal>any_one_of</literal>, and <literal>not_any_of</literal> can all be used in the same rule,
                        but cannot be repeated within the same condition. <literal>any_one_of</literal> and
                        <literal>not_any_of</literal> are mutually exclusive within a condition’s scope. So are
                        <literal>whitelist</literal> and <literal>blacklist</literal>.</para>
        <screen language="json">{
    "rules": [
        {
            "local": [
                {
                    "user": {
                        "name": "{0}"
                    },
                    "group": {
                        "id": "0cd5e9"
                    }
                },
            ],
            "remote": [
                {
                    "type": "UserName"
                },
                {
                    "type": "cn=IBM_Canada_Lab",
                    "not_any_of": [
                        ".*@naww.com$"
                    ],
                    "regex": true
                },
                {
                    "type": "cn=IBM_USA_Lab",
                    "any_one_of": [
                        ".*@yeah.com$"
                    ]
                    "regex": true
                }
            ]
        }
    ]
}</screen>
        <para>As before group names and users can also be provided in the local section.</para>
        <para>This allows any user with the following claim information to be mapped to
                        group with id 0cd5e9.</para>
        <screen language="json">{"UserName":"&lt;any_name&gt;@yeah.com"}
{"cn=IBM_USA_Lab":"&lt;any_name&gt;@yeah.com"}
{"cn=IBM_Canada_Lab":"&lt;any_name&gt;@yeah.com"}</screen>
        <para>The following claims will be mapped:</para>
        <itemizedlist>
          <listitem>
            <para>any claim containing the key UserName.</para>
          </listitem>
          <listitem>
            <para>any claim containing key cn=IBM_Canada_Lab that doesn’t have the value &lt;any_name&gt;@naww.com.</para>
          </listitem>
          <listitem>
            <para>any claim containing key cn=IBM_USA_Lab that has value &lt;any_name&gt;@yeah.com.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>Multiple Rules</title>
        <para>Multiple rules can also be utilized in a mapping.</para>
        <screen language="json">{
    "rules": [
        {
            "local": [
                {
                    "user": {
                        "name": "{0}"
                    },
                    "group": {
                        "name": "non-contractors",
                        "domain": {
                            "id": "abc1234"
                        }
                    }
                }
            ],
            "remote": [
                {
                    "type": "UserName"
                },
                {
                    "type": "orgPersonType",
                    "not_any_of": [
                        "Contractor",
                        "SubContractor"
                    ]
                }
            ]
        },
        {
            "local": [
                {
                    "user": {
                        "name": "{0}"
                    },
                    "group": {
                        "name": "contractors",
                        "domain": {
                            "id": "abc1234"
                        }
                    }
                }
            ],
            "remote": [
                {
                    "type": "UserName"
                },
                {
                    "type": "orgPersonType",
                    "any_one_of": [
                        "Contractor",
                        "SubContractor"
                    ]
                }
            ]
        }
    ]
}</screen>
        <para>The above assigns groups membership basing on <literal>orgPersonType</literal> values:</para>
        <itemizedlist>
          <listitem>
            <para>neither <literal>Contractor</literal> nor <literal>SubContractor</literal> will belong to the <literal>non-contractors</literal> group.</para>
          </listitem>
          <listitem>
            <para>either <literal>Contractor or ``SubContractor</literal> will belong to the <literal>contractors</literal> group.</para>
          </listitem>
        </itemizedlist>
        <para>Rules are additive, so permissions will only be granted for the rules that
                        succeed.  All the remote conditions of a rule must be valid.</para>
        <para>When using multiple rules you can specify more than one effective user
                        identification, but only the first match will be considered and the others
                        ignored ordered from top to bottom.</para>
        <para>Since rules are additive one can specify one user identification and this will
                        also work. The best practice for multiple rules is to create a rule for just
                        user and another rule for just groups. Below is rules example repeated but with
                        global username mapping.</para>
        <screen language="json">{
    "rules": [{
        "local": [{
            "user": {
                "id": "{0}"
            }
        }],
        "remote": [{
            "type": "UserType"
        }]
    },
    {
        "local": [{
            "group": {
                "name": "non-contractors",
                "domain": {
                    "id": "abc1234"
                }
            }
        }],
        "remote": [{
            "type": "orgPersonType",
            "not_any_of": [
                "Contractor",
                "SubContractor"
            ]
        }]
    },
    {
        "local": [{
            "group": {
                "name": "contractors",
                "domain": {
                    "id": "abc1234"
                }
            }
        }],
        "remote": [{
            "type": "orgPersonType",
            "any_one_of": [
                "Contractor",
                "SubContractor"
            ]
        }]
    }]
 }</screen>
      </section>
      <section>
        <title>Auto-Provisioning</title>
        <para>The mapping engine has the ability to aid in the auto-provisioning of resources
                        when a federated user authenticates for the first time. This can be achieved
                        using a specific mapping syntax that the mapping engine can parse and
                        ultimately make decisions on.</para>
        <para>For example, consider the following mapping:</para>
        <screen language="json">{
    "rules": [
        {
            "local": [
                {
                    "user": {
                        "name": "{0}"
                    }
                },
                {
                    "projects": [
                        {
                            "name": "Production",
                            "roles": [
                                {
                                    "name": "observer"
                                }
                            ]
                        },
                        {
                            "name": "Staging",
                            "roles": [
                                {
                                    "name": "member"
                                }
                            ]
                        },
                        {
                            "name": "Project for {0}",
                            "roles": [
                                {
                                    "name": "admin"
                                }
                            ]
                        }
                    ]
                }
            ],
            "remote": [
                {
                    "type": "UserName"
                }
            ]
        }
    ]
}</screen>
        <para>The semantics of the <literal>remote</literal> section have not changed. The difference
                        between this mapping and the other examples is the addition of a <literal>projects</literal>
                        section within the <literal>local</literal> rules. The <literal>projects</literal> list supplies a list
                        of projects that the federated user will be given access to. The projects
                        will be automatically created if they don’t exist when the user
                        authenticated and the mapping engine has applied values from the assertion
                        and mapped them into the <literal>local</literal> rules.</para>
        <para>In the above example, an authenticated federated user will be granted the
                        <literal>observer</literal> role on the <literal>Production</literal> project, <literal>member</literal> role on the
                        <literal>Staging</literal> project, and they will have <literal>admin</literal> role on the <literal>Project for
jsmith</literal>.</para>
        <para>It is important to note the following constraints apply when auto-provisioning:</para>
        <itemizedlist>
          <listitem>
            <para>Projects are the only resource that will be created dynamically.</para>
          </listitem>
          <listitem>
            <para>Projects will be created within the domain associated with the Identity
                                Provider.</para>
          </listitem>
          <listitem>
            <para>The <literal>projects</literal> section of the mapping must also contain a <literal>roles</literal>
                                section.</para>
            <itemizedlist>
              <listitem>
                <para>Roles within the project must already exist in the deployment or domain.</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>Assignments are actually created for the user which is unlike the
                                ephemeral group memberships.</para>
          </listitem>
        </itemizedlist>
        <para>Since the creation of roles typically requires policy changes across other
                        services in the deployment, it is expected that roles are created ahead of
                        time. Federated authentication should also be considered idempotent if the
                        attributes from the SAML assertion have not changed. In the example from above,
                        if the user’s name is still <literal>jsmith</literal>, then no new projects will be
                        created as a result of authentication.</para>
        <para>Mappings can be created that mix <literal>groups</literal> and <literal>projects</literal> within the
                        <literal>local</literal> section. The mapping shown in the example above does not contain a
                        <literal>groups</literal> section in the <literal>local</literal> rules. This will result in the federated
                        user having direct role assignments on the projects in the <literal>projects</literal> list.
                        The following example contains <literal>local</literal> rules comprised of both <literal>projects</literal>
                        and <literal>groups</literal>, which allow for direct role assignments and group memberships.</para>
        <screen language="json">{
    "rules": [
        {
            "local": [
                {
                    "user": {
                        "name": "{0}"
                    }
                },
                {
                    "projects": [
                        {
                            "name": "Marketing",
                            "roles": [
                                {
                                    "name": "member"
                                }
                            ]
                        },
                        {
                            "name": "Development project for {0}",
                            "roles": [
                                {
                                    "name": "admin"
                                }
                            ]
                        }
                    ]
                },
                {
                    "group": {
                        "name": "Finance",
                        "domain": {
                            "id": "6fe767"
                        }
                    }
                }
            ],
            "remote": [
                {
                    "type": "UserName"
                }
            ]
        }
    ]
}</screen>
        <para>In the above example, a federated user will receive direct role assignments on
                        the <literal>Marketing</literal> project, as well as a dedicated project specific to the
                        federated user’s name. In addition to that, they will also be placed in the
                        <literal>Finance</literal> group and receive all role assignments that group has on projects
                        and domains.</para>
      </section>
      <section>
        <title>keystone-to-keystone</title>
        <para>keystone-to-keystone federation also utilizes mappings, but has some
                        differences.</para>
        <para>An attribute file (e.g. <literal>/etc/shibboleth/attribute-map.xml</literal> in a Shibboleth
                        implementation) is used to add attributes to the mapping <literal>context</literal>. Attributes
                        look as follows:</para>
        <screen language="xml">&lt;!-- example from a K2k Shibboleth implementation --&gt;
&lt;Attribute name="openstack_user" id="openstack_user"/&gt;
&lt;Attribute name="openstack_user_domain" id="openstack_user_domain"/&gt;</screen>
        <para>The service provider must contain a mapping as shown below.
                        <literal>openstack_user</literal>, and <literal>openstack_user_domain</literal> match to the attribute
                        names we have in the Identity Provider. It will map any user with the name
                        <literal>user1</literal> or <literal>admin</literal> in the <literal>openstack_user</literal> attribute and
                        <literal>openstack_domain</literal> attribute <literal>default</literal> to a group with id <literal>abc1234</literal>.</para>
        <screen language="json">{
    "rules": [
        {
            "local": [
                {
                    "group": {
                        "id": "abc1234"
                    }
                }
            ],
            "remote": [
                {
                    "type": "openstack_user",
                    "any_one_of": [
                        "user1",
                        "admin"
                    ]
                },
                {
                    "type":"openstack_user_domain",
                    "any_one_of": [
                        "Default"
                    ]
                }
            ]
        }
    ]
}</screen>
        <para>The possible attributes that can be used in a mapping are <literal>openstack_user</literal>,
                        <literal>openstack_user_domain</literal>, <literal>openstack_roles</literal>, <literal>openstack_project</literal>, and
                        <literal>openstack_project_domain</literal>.</para>
      </section>
    </section>
  </section>
  <section>
    <title>Setup OpenID Connect</title>
    <section>
      <title>Configuring mod_auth_openidc</title>
      <para>Federate Keystone (SP) and an external IdP using OpenID Connect (<link xlink:href="https://github.com/pingidentity/mod_auth_openidc">mod_auth_openidc</link>)</para>
      <para>To install <literal>mod_auth_openidc</literal> on Ubuntu, perform the following:</para>
      <screen language="bash">$ sudo apt-get install libapache2-mod-auth-openidc</screen>
      <para>This module is available for other distributions (Fedora/CentOS/Red Hat) from:
                    <link xlink:href="https://github.com/pingidentity/mod_auth_openidc/releases"/></para>
      <para>Enable the auth_openidc module:</para>
      <screen language="bash">$ sudo a2enmod auth_openidc</screen>
      <para>In the keystone vhost file, locate the virtual host entry and add the following
                    entries for OpenID Connect:</para>
      <screen language="none"><?dbsuse-fo font-size="8pt"?>&lt;VirtualHost *:5000&gt;

    ...

    OIDCClaimPrefix "OIDC-"
    OIDCResponseType "id_token"
    OIDCScope "openid email profile"
    OIDCProviderMetadataURL &lt;url_of_provider_metadata&gt;
    OIDCClientID &lt;openid_client_id&gt;
    OIDCClientSecret &lt;openid_client_secret&gt;
    OIDCCryptoPassphrase openstack
    OIDCRedirectURI http://localhost:5000/v3/OS-FEDERATION/identity_providers/&lt;idp_id&gt;/protocols/openid/auth

    &lt;LocationMatch /v3/OS-FEDERATION/identity_providers/.*?/protocols/openid/auth&gt;
      AuthType openid-connect
      Require valid-user
      LogLevel debug
    &lt;/LocationMatch&gt;
&lt;/VirtualHost&gt;</screen>
      <para>Note an example of an <literal>OIDCProviderMetadataURL</literal> instance is: <link xlink:href="https://accounts.google.com/.well-known/openid-configuration"/>
                    If not using <literal>OIDCProviderMetadataURL</literal>, then the following attributes
                    must be specified: <literal>OIDCProviderIssuer</literal>, <literal>OIDCProviderAuthorizationEndpoint</literal>,
                    <literal>OIDCProviderTokenEndpoint</literal>, <literal>OIDCProviderTokenEndpointAuth</literal>,
                    <literal>OIDCProviderUserInfoEndpoint</literal>, and <literal>OIDCProviderJwksUri</literal></para>
      <para>Note, if using a mod_wsgi version less than 4.3.0, then the <literal>OIDCClaimPrefix</literal>
                    must be specified to have only alphanumerics or a dash (“-“). This is because
                    mod_wsgi blocks headers that do not fit this criteria. See <link xlink:href="http://modwsgi.readthedocs.org/en/latest/release-notes/version-4.3.0.html#bugs-fixed"/>
                    for more details</para>
      <para>Once you are done, restart your Apache daemon:</para>
      <screen language="bash">$ sudo service apache2 restart</screen>
    </section>
    <section>
      <title>Tips</title>
      <procedure>
        <step>
          <para>When creating a <link xlink:href="configure_federation.html#mapping">mapping</link>, note that the ‘remote’ attributes will be prefixed,
                            with <literal>HTTP_</literal>, so for instance, if you set OIDCClaimPrefix to <literal>OIDC-</literal>, then a
                            typical remote value to check for is: <literal>HTTP_OIDC_ISS</literal>.</para>
        </step>
        <step>
          <para>Don’t forget to add openid as an [auth] plugin in keystone.conf, see
                            <link xlink:href="federated_identity.html#configure-authentication-drivers-in-keystone-conf">Configure authentication drivers in keystone.conf</link></para>
        </step>
      </procedure>
    </section>
  </section>
  <section>
    <title>Setup Mellon</title>
    <section>
      <title>Configure Apache HTTPD for mod_auth_mellon</title>
      <para>Follow the steps outlined at: <link xlink:href="../apache-httpd.html">Running Keystone in HTTPD</link>.</para>
      <para>You’ll also need to install the Apache module <link xlink:href="https://github.com/UNINETT/mod_auth_mellon">mod_auth_mellon</link>.  For example:</para>
      <screen language="bash">$ apt-get install libapache2-mod-auth-mellon</screen>
      <para>Configure your Keystone virtual host and adjust the config to properly handle SAML2 workflow:</para>
      <para>Add this <emphasis>WSGIScriptAlias</emphasis> directive to your public vhost configuration:</para>
      <screen><?dbsuse-fo font-size="8pt"?>WSGIScriptAliasMatch ^(/v3/OS-FEDERATION/identity_providers/.*?/protocols/.*?/auth)$ /usr/local/bin/keystone-wsgi-public/$1</screen>
      <para>Make sure the <emphasis>wsgi-keystone.conf</emphasis> contains a <emphasis>&lt;Location&gt;</emphasis> directive for the Mellon module and
                    a <emphasis>&lt;Location&gt;</emphasis> directive for each identity provider</para>
      <screen language="none"><?dbsuse-fo font-size="8pt"?>&lt;Location /v3&gt;
    MellonEnable "info"
    MellonSPPrivateKeyFile /etc/apache2/mellon/http_keystone.fqdn.key
    MellonSPCertFile /etc/apache2/mellon/http_keystone.fqdn.cert
    MellonSPMetadataFile /etc/apache2/mellon/http_keystone.fqdn.xml
    MellonIdPMetadataFile /etc/apache2/mellon/idp-metadata.xml
    MellonEndpointPath /v3/OS-FEDERATION/identity_providers/myidp/protocols/mapped/auth/mellon
    MellonIdP "IDP"
&lt;/Location&gt;

&lt;Location /v3/OS-FEDERATION/identity_providers/myidp/protocols/mapped/auth&gt;
    AuthType "Mellon"
    MellonEnable "auth"
&lt;/Location&gt;</screen>
      <note>
        <itemizedlist>
          <listitem>
            <para>See below for information about how to generate the values for the
                                <literal>MellonSPMetadataFile</literal>, etc. directives.</para>
          </listitem>
          <listitem>
            <para><literal>mapped</literal> is the name of the <link xlink:href="configure_federation.html#protocol">protocol that you will configure</link></para>
          </listitem>
          <listitem>
            <para><literal>myidp</literal> is the name associated with the <link xlink:href="configure_federation.html#identity_provider">IdP in Keystone</link></para>
          </listitem>
          <listitem>
            <para>You are advised to carefully examine <link xlink:href="https://github.com/UNINETT/mod_auth_mellon">mod_auth_mellon Apache
                                    configuration documentation</link></para>
          </listitem>
        </itemizedlist>
      </note>
      <para>Enable the <literal>auth_mellon</literal> module, for example:</para>
      <screen language="bash">$ a2enmod auth_mellon</screen>
    </section>
    <section>
      <title>Configuring the Mellon SP Metadata</title>
      <para>Mellon provides a script called <link xlink:href="https://github.com/UNINETT/mod_auth_mellon/blob/master/mellon_create_metadata.sh">mellon_create_metadata.sh</link> which generates
                    the values for the config directives <literal>MellonSPPrivateKeyFile</literal>,
                    <literal>MellonSPCertFile</literal>, and <literal>MellonSPMetadataFile</literal>.  It is run like this:</para>
      <screen language="bash"><?dbsuse-fo font-size="8pt"?>$ ./mellon_create_metadata.sh http://keystone.fqdn:5000 \
  http://keystone.fqdn:5000/v3/OS-FEDERATION/identity_providers/myidp/protocols/mapped/auth/mellon</screen>
      <para>The first parameter is used as the entity ID, a unique identifier for this
                    Keystone SP.  You do not have to use the URL, but it is an easy way to uniquely
                    identify each Keystone SP.  The second parameter is the full URL for the
                    endpoint path corresponding to the parameter <literal>MellonEndpointPath</literal>. Note that
                    the metadata generated by this script includes a signing key but not an
                    encryption key, and your IdP (such as testshib.org) may require an encryption
                    key. Simply change the node <literal>&lt;KeyDescriptor use=”signing”&gt;</literal> to
                    <literal>&lt;KeyDescriptor use=”encryption”&gt;</literal> or add another key to the file. Check your
                    IdP documentation for details.</para>
      <para>After generating the keypair and metadata, copy the files to the locations
                    given in the Mellon directives in your apache configs.</para>
      <para>Upload the Service Provider’s Metadata file which you just generated to your
                    Identity Provider. This is the file used as the value of the
                    <literal>MellonSPMetadataFile</literal> in the config. The IdP may provide a webpage where you
                    can upload the file, or you may be required to submit the file using <literal>wget</literal> or
                    <literal>curl</literal>. Please check your IdP documentation for details.</para>
      <para>Fetch your Identity Provider’s Metadata file and copy it to the path specified
                    by the <literal>MellonIdPMetadataFile</literal> directive above. For example:</para>
      <screen language="bash">$ wget --cacert /path/to/ca.crt -O /etc/apache2/mellon/idp-metadata.xml \
  https://idp.fqdn/idp/saml2/metadata</screen>
      <para>Once you are done, restart the Apache instance that is serving Keystone, for example:</para>
      <screen language="bash">$ service apache2 restart</screen>
    </section>
  </section>
  <section>
    <title>Setup Shibboleth</title>
    <section>
      <title>Configure Apache HTTPD for mod_shibboleth</title>
      <para>Follow the steps outlined at: <link xlink:href="../apache-httpd.html">Running Keystone in HTTPD</link>.</para>
      <para>You’ll also need to install <link xlink:href="https://wiki.shibboleth.net/confluence/display/SHIB2/Home">Shibboleth</link>, for
                    example:</para>
      <screen language="bash">$ apt-get install libapache2-mod-shib2</screen>
      <para>Configure your Keystone virtual host and adjust the config to properly handle SAML2 workflow:</para>
      <para>Add this <emphasis>WSGIScriptAliasMatch</emphasis> directive to your public vhost configuration:</para>
      <screen><?dbsuse-fo font-size="8pt"?>WSGIScriptAliasMatch ^(/v3/OS-FEDERATION/identity_providers/.*?/protocols/.*?/auth)$ /usr/local/bin/keystone-wsgi-public/$1</screen>
      <para>Make sure the <emphasis>keystone.conf</emphasis> vhost file contains a <emphasis>&lt;Location&gt;</emphasis> directive for the Shibboleth module and
                    a <emphasis>&lt;Location&gt;</emphasis> directive for each identity provider:</para>
      <screen>&lt;Location /Shibboleth.sso&gt;
    SetHandler shib
&lt;/Location&gt;

&lt;Location /v3/OS-FEDERATION/identity_providers/myidp/protocols/mapped/auth&gt;
    ShibRequestSetting requireSession 1
    AuthType shibboleth
    ShibExportAssertion Off
    Require valid-user

    &lt;IfVersion &lt; 2.4&gt;
        ShibRequireSession On
        ShibRequireAll On
   &lt;/IfVersion&gt;
&lt;/Location&gt;</screen>
      <note>
        <itemizedlist>
          <listitem>
            <para><literal>mapped</literal> is the name of the <link xlink:href="configure_federation.html#protocol">protocol that you will configure</link></para>
          </listitem>
          <listitem>
            <para><literal>myidp</literal> is the name associated with the <link xlink:href="configure_federation.html#identity_provider">IdP in Keystone</link></para>
          </listitem>
          <listitem>
            <para>The <literal>ShibRequireSession</literal> and <literal>ShibRequireAll</literal> rules are invalid in
                                Apache 2.4+.</para>
          </listitem>
          <listitem>
            <para>You are advised to carefully examine <link xlink:href="https://wiki.shibboleth.net/confluence/display/SHIB2/NativeSPApacheConfig">Shibboleth Apache configuration
                                    documentation</link></para>
          </listitem>
        </itemizedlist>
      </note>
      <para>Enable the <literal>shib2</literal> module, for example:</para>
      <screen language="bash">$ a2enmod shib2</screen>
      <para>Restart Apache, for example:</para>
      <screen language="bash">$ service apache2 restart</screen>
    </section>
    <section>
      <title>Configuring shibboleth2.xml</title>
      <para>Once you have your Keystone vhost (virtual host) ready, it’s then time to
                    configure Shibboleth and upload your Metadata to the Identity Provider.</para>
      <para>Create a new keypair for Shibboleth with:</para>
      <screen language="bash">$ shib-keygen -y &lt;number of years&gt;</screen>
      <para>The newly created key file will be stored under <literal>/etc/shibboleth/sp-key.pem</literal>.</para>
      <para>Configure your Service Provider by editing <literal>/etc/shibboleth/shibboleth2.xml</literal>
                    file. You will want to change five settings:</para>
      <itemizedlist>
        <listitem>
          <para>Set the SP entity ID. This value usually has the form of a URI but it does not
                            have to resolve to anything. It must uniquely identify your Service Provider
                            to your Identity Provider.</para>
        </listitem>
      </itemizedlist>
      <screen language="xml">&lt;ApplicationDefaults entityID="http://mysp.example.com/shibboleth"&gt;</screen>
      <itemizedlist>
        <listitem>
          <para>Set the IdP entity ID. This value is determined by the IdP. For example, if
                            Keystone is the IdP:</para>
        </listitem>
      </itemizedlist>
      <screen language="xml">&lt;SSO entityID="https://myidp.example.com/v3/OS-FEDERATION/saml2/idp"&gt;</screen>
      <para>Example if testshib.org is the IdP:</para>
      <screen language="xml">&lt;SSO entityID="https://idp.testshib.org/idp/shibboleth"&gt;</screen>
      <itemizedlist>
        <listitem>
          <para>Remove the discoveryURL lines unless you want to enable advanced IdP discovery.</para>
        </listitem>
        <listitem>
          <para>Add a MetadataProvider block. The URI given here is a real URL that Shibboleth
                            will use to fetch metadata from the IdP. For example, if Keystone is the IdP:</para>
        </listitem>
      </itemizedlist>
      <screen language="xml"><?dbsuse-fo font-size="8pt"?>&lt;MetadataProvider type="XML" uri="https://myidp.example.com:5000/v3/OS-FEDERATION/saml2/metadata"/&gt;</screen>
      <para>Example if testshib.org is the IdP:</para>
      <screen language="xml"><?dbsuse-fo font-size="8pt"?>&lt;MetadataProvider type="XML" uri="http://www.testshib.org/metadata/testshib-providers.xml" /&gt;</screen>
      <para>You are advised to examine <link xlink:href="https://wiki.shibboleth.net/confluence/display/SHIB2/Configuration">Shibboleth Service Provider Configuration documentation</link></para>
      <para>The result should look like (The example shown below is for reference only, not
                    to be used in a production environment):</para>
      <screen language="xml"><?dbsuse-fo font-size="8pt"?>&lt;SPConfig xmlns="urn:mace:shibboleth:2.0:native:sp:config"
    xmlns:conf="urn:mace:shibboleth:2.0:native:sp:config"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata"
    clockSkew="180"&gt;

    &lt;!--
    By default, in-memory StorageService, ReplayCache, ArtifactMap, and SessionCache
    are used. See example-shibboleth2.xml for samples of explicitly configuring them.
    --&gt;

    &lt;!--
    To customize behavior for specific resources on Apache, and to link vhosts or
    resources to ApplicationOverride settings below, use web server options/commands.
    See https://wiki.shibboleth.net/confluence/display/SHIB2/NativeSPConfigurationElements for help.

    For examples with the RequestMap XML syntax instead, see the example-shibboleth2.xml
    file, and the https://wiki.shibboleth.net/confluence/display/SHIB2/NativeSPRequestMapHowTo topic.
    --&gt;

    &lt;!-- The ApplicationDefaults element is where most of Shibboleth's SAML bits are defined. --&gt;
    &lt;ApplicationDefaults entityID="https://mysp.example.com/shibboleth"&gt;

        &lt;!--
        Controls session lifetimes, address checks, cookie handling, and the protocol handlers.
        You MUST supply an effectively unique handlerURL value for each of your applications.
        The value defaults to /Shibboleth.sso, and should be a relative path, with the SP computing
        a relative value based on the virtual host. Using handlerSSL="true", the default, will force
        the protocol to be https. You should also set cookieProps to "https" for SSL-only sites.
        Note that while we default checkAddress to "false", this has a negative impact on the
        security of your site. Stealing sessions via cookie theft is much easier with this disabled.
        --&gt;
        &lt;Sessions lifetime="28800" timeout="3600" relayState="ss:mem"
                  checkAddress="false" handlerSSL="false" cookieProps="http"&gt;

            &lt;!--
            Configures SSO for a default IdP. To allow for &gt;1 IdP, remove
            entityID property and adjust discoveryURL to point to discovery service.
            (Set discoveryProtocol to "WAYF" for legacy Shibboleth WAYF support.)
            You can also override entityID on /Login query string, or in RequestMap/htaccess.
            --&gt;
            &lt;SSO entityID="https://myidp.example.com/v3/OS-FEDERATION/saml2/idp"&gt;
              SAML2 SAML1
            &lt;/SSO&gt;

            &lt;!-- SAML and local-only logout. --&gt;
            &lt;Logout&gt;SAML2 Local&lt;/Logout&gt;

            &lt;!-- Extension service that generates "approximate" metadata based on SP configuration. --&gt;
            &lt;Handler type="MetadataGenerator" Location="/Metadata" signing="false"/&gt;

            &lt;!-- Status reporting service. --&gt;
            &lt;Handler type="Status" Location="/Status" acl="127.0.0.1 ::1"/&gt;

            &lt;!-- Session diagnostic service. --&gt;
            &lt;Handler type="Session" Location="/Session" showAttributeValues="false"/&gt;

            &lt;!-- JSON feed of discovery information. --&gt;
            &lt;Handler type="DiscoveryFeed" Location="/DiscoFeed"/&gt;
        &lt;/Sessions&gt;
        &lt;!--
        Allows overriding of error template information/filenames. You can
        also add attributes with values that can be plugged into the templates.
        --&gt;
        &lt;Errors supportContact="root@localhost"
            helpLocation="/about.html"
            styleSheet="/shibboleth-sp/main.css"/&gt;

        &lt;!-- Example of remotely supplied batch of signed metadata. --&gt;
        &lt;!--
        &lt;MetadataProvider type="XML" uri="http://federation.org/federation-metadata.xml"
              backingFilePath="federation-metadata.xml" reloadInterval="7200"&gt;
            &lt;MetadataFilter type="RequireValidUntil" maxValidityInterval="2419200"/&gt;
            &lt;MetadataFilter type="Signature" certificate="fedsigner.pem"/&gt;
        &lt;/MetadataProvider&gt;
        --&gt;

        &lt;!-- Example of locally maintained metadata. --&gt;
        &lt;!--
        &lt;MetadataProvider type="XML" file="partner-metadata.xml"/&gt;
        --&gt;
        &lt;MetadataProvider type="XML" uri="https://myidp.example.com:5000/v3/OS-FEDERATION/saml2/metadata"/&gt;

        &lt;!-- Map to extract attributes from SAML assertions. --&gt;
        &lt;AttributeExtractor type="XML" validate="true" reloadChanges="false" path="attribute-map.xml"/&gt;

        &lt;!-- Use a SAML query if no attributes are supplied during SSO. --&gt;
        &lt;AttributeResolver type="Query" subjectMatch="true"/&gt;

        &lt;!-- Default filtering policy for recognized attributes, lets other data pass. --&gt;
        &lt;AttributeFilter type="XML" validate="true" path="attribute-policy.xml"/&gt;

        &lt;!-- Simple file-based resolver for using a single keypair. --&gt;
        &lt;CredentialResolver type="File" key="sp-key.pem" certificate="sp-cert.pem"/&gt;

        &lt;!--
        The default settings can be overridden by creating ApplicationOverride elements (see
        the https://wiki.shibboleth.net/confluence/display/SHIB2/NativeSPApplicationOverride topic).
        Resource requests are mapped by web server commands, or the RequestMapper, to an
        applicationId setting.
        Example of a second application (for a second vhost) that has a different entityID.
        Resources on the vhost would map to an applicationId of "admin":
        --&gt;
        &lt;!--
        &lt;ApplicationOverride id="admin" entityID="https://admin.example.org/shibboleth"/&gt;
        --&gt;
    &lt;/ApplicationDefaults&gt;

    &lt;!-- Policies that determine how to process and authenticate runtime messages. --&gt;
    &lt;SecurityPolicyProvider type="XML" validate="true" path="security-policy.xml"/&gt;

    &lt;!-- Low-level configuration about protocols and bindings available for use. --&gt;
    &lt;ProtocolProvider type="XML" validate="true" reloadChanges="false" path="protocols.xml"/&gt;

&lt;/SPConfig&gt;</screen>
      <para>If keystone is your IdP, you will need to examine your attributes map file
                    <literal>/etc/shibboleth/attribute-map.xml</literal> and add the following attributes:</para>
      <screen language="xml">&lt;Attribute name="openstack_user" id="openstack_user"/&gt;
&lt;Attribute name="openstack_roles" id="openstack_roles"/&gt;
&lt;Attribute name="openstack_project" id="openstack_project"/&gt;
&lt;Attribute name="openstack_user_domain" id="openstack_user_domain"/&gt;
&lt;Attribute name="openstack_project_domain" id="openstack_project_domain"/&gt;</screen>
      <para>For more information see the
                    <link xlink:href="https://wiki.shibboleth.net/confluence/display/SHIB2/NativeSPAddAttribute">attributes documentation</link></para>
      <para>Once you are done, restart your Shibboleth daemon and apache:</para>
      <screen language="bash">$ service shibd restart
$ service apache2 restart</screen>
      <para>Check <literal>/var/log/shibboleth/shibd_warn.log</literal> for any ERROR or CRIT notices and
                    correct them.</para>
      <para>Upload your Service Provider’s metadata file to your Identity Provider. You can
                    fetch it with:</para>
      <screen language="bash">$ wget http://mysp.example.com/Shibboleth.sso/Metadata</screen>
      <para>This step depends on your Identity Provider choice and is not covered here.
                    If keystone is your Identity Provider you do not need to upload this file.</para>
    </section>
  </section>
  <section>
    <title>Setup Web Single Sign-On (SSO)</title>
    <section>
      <title>Keystone Changes</title>
      <procedure>
        <step>
          <para>Update <literal>trusted_dashboard</literal> in keystone.conf.</para>
        </step>
      </procedure>
      <para>Specify URLs of trusted horizon servers. This value may be repeated
                    multiple times. This setting ensures that keystone only sends token data back
                    to trusted servers. This is performed as a precaution, specifically to
                    prevent man-in-the-middle (MITM) attacks.</para>
      <screen language="ini">[federation]
trusted_dashboard = http://acme.horizon.com/auth/websso/
trusted_dashboard = http://beta.horizon.com/auth/websso/</screen>
      <procedure>
        <step>
          <para>Update httpd vhost file with websso information.</para>
        </step>
      </procedure>
      <para>The <literal>/v3/auth/OS-FEDERATION/websso/&lt;protocol&gt;</literal> and
                    <literal>/v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso</literal>
                    routes must be protected by the chosen httpd module. This is performed so the
                    request that originates from horizon will use the same identity provider that
                    is configured in keystone.</para>
      <warning>
        <para>By using the IdP specific route, a user will no longer leverage the Remote
                        ID of a specific Identity Provider, and will be unable to verify that the
                        Identity Provider is trusted, the mapping will remain as the only means to
                        controlling authorization.</para>
      </warning>
      <para>If <literal>mod_shib</literal> is used, then use the following as an example:</para>
      <screen language="none"><?dbsuse-fo font-size="8pt"?>&lt;VirtualHost *:5000&gt;

    ...

    &lt;Location ~ "/v3/auth/OS-FEDERATION/websso/mapped"&gt;
      AuthType shibboleth
      Require valid-user
      ShibRequestSetting requireSession 1
      ShibRequireSession On
      ShibExportAssertion Off
    &lt;/Location&gt;
    &lt;Location ~ "/v3/auth/OS-FEDERATION/identity_providers/myidp/protocols/mapped/websso"&gt;
      AuthType shibboleth
      Require valid-user
    &lt;/Location&gt;
&lt;/VirtualHost&gt;</screen>
      <para>If <literal>mod_auth_openidc</literal> is used, then use the following as an example:</para>
      <screen language="none"><?dbsuse-fo font-size="8pt"?>&lt;VirtualHost *:5000&gt;

    OIDCRedirectURI http://localhost:5000/v3/auth/OS-FEDERATION/websso
    OIDCRedirectURI http://localhost:5000/v3/auth/OS-FEDERATION/identity_providers/myidp/protocols/openid/websso

    ...

    &lt;Location ~ "/v3/auth/OS-FEDERATION/websso/openid"&gt;
      AuthType openid-connect
      Require valid-user
      ...
    &lt;/Location&gt;
    &lt;Location ~ "/v3/auth/OS-FEDERATION/identity_providers/myidp/protocols/openid/websso"&gt;
      AuthType openid-connect
      Require valid-user
      ...
    &lt;/Location&gt;
&lt;/VirtualHost&gt;</screen>
      <para>If <literal>mod_auth_kerb</literal> is used, then use the following as an example:</para>
      <screen language="none"><?dbsuse-fo font-size="8pt"?>&lt;VirtualHost *:5000&gt;

    ...

    &lt;Location ~ "/v3/auth/OS-FEDERATION/websso/kerberos"&gt;
      AuthType Kerberos
      AuthName "Acme Corporation"
      KrbMethodNegotiate on
      KrbMethodK5Passwd off
      Krb5Keytab /etc/apache2/http.keytab
      ...
    &lt;/Location&gt;
    &lt;Location ~ "/v3/auth/OS-FEDERATION/identity_providers/myidp/protocols/kerberos/websso"&gt;
      AuthType Kerberos
      AuthName "Acme Corporation"
      KrbMethodNegotiate on
      KrbMethodK5Passwd off
      Krb5Keytab /etc/apache2/http.keytab
      ...
    &lt;/Location&gt;
&lt;/VirtualHost&gt;</screen>
      <para>If <literal>mod_auth_mellon</literal> is used, then use the following as an example:</para>
      <screen language="none"><?dbsuse-fo font-size="8pt"?>&lt;VirtualHost *:5000&gt;

    ...

    &lt;Location ~ "/v3/auth/OS-FEDERATION/websso/mapped"&gt;
      AuthType Mellon
      MellonEnable auth
      Require valid-user
      ...
    &lt;/Location&gt;
    &lt;Location ~ "/v3/auth/OS-FEDERATION/identity_providers/myidp/protocols/mapped/websso"&gt;
      AuthType Mellon
      MellonEnable auth
      Require valid-user
      ...
    &lt;/Location&gt;
&lt;/VirtualHost&gt;</screen>
      <note>
        <para>If you are also using SSO via the API, don’t forget to make the Location
                        settings match your configuration used for the keystone identity provider
                        location:
                        <literal>/v3/OS-FEDERATION/identity_providers/&lt;idp&gt;/protocols/&lt;protocol&gt;/auth</literal></para>
      </note>
      <procedure>
        <step>
          <para>Update <literal>remote_id_attribute</literal> in keystone.conf.</para>
        </step>
      </procedure>
      <para>A remote id attribute indicates the header to retrieve from the WSGI
                    environment. This header contains information about the identity
                    of the identity provider. For <literal>mod_shib</literal> this would be
                    <literal>Shib-Identity-Provider</literal>, for <literal>mod_auth_openidc</literal>, this could be
                    <literal>HTTP_OIDC_ISS</literal>.  For <literal>mod_auth_mellon</literal>, this could be <literal>MELLON_IDP</literal>.</para>
      <para>It is recommended that this option be set on a per-protocol basis.</para>
      <screen language="ini">[mapped]
remote_id_attribute = Shib-Identity-Provider
[openid]
remote_id_attribute = HTTP_OIDC_ISS</screen>
      <para>Alternatively, a generic option may be set at the <literal>[federation]</literal> level.</para>
      <screen language="ini">[federation]
remote_id_attribute = HTTP_OIDC_ISS</screen>
      <para>4. Copy the <link xlink:href="https://git.openstack.org/cgit/openstack/keystone/plain/etc/sso_callback_template.html">sso_callback_template.html</link>
                    template into the location specified by <literal>[federation]/sso_callback_template</literal>.</para>
    </section>
    <section>
      <title>Horizon Changes</title>
      <note>
        <para>Django OpenStack Auth version 1.2.0 or higher is required for these steps.</para>
        <para>Identity provider and federation protocol specific webSSO is only available
                        in Django OpenStack Auth version 2.0.0 or higher.</para>
      </note>
      <procedure>
        <step>
          <para>Set the <literal>WEBSSO_ENABLED</literal> option.</para>
        </step>
      </procedure>
      <para>Ensure the <literal>WEBSSO_ENABLED</literal> option is set to True in horizon’s local_settings.py file,
                    this will provide users with an updated login screen for horizon.</para>
      <screen language="python">WEBSSO_ENABLED = True</screen>
      <procedure>
        <step>
          <para>(Optional) Create a list of authentication methods with the
                            <literal>WEBSSO_CHOICES</literal> option.</para>
        </step>
      </procedure>
      <para>Within horizon’s settings.py file, a list of supported authentication methods can be
                    specified. The list includes Keystone federation protocols such as OpenID Connect and
                    SAML, and also keys that map to specific identity provider and federation protocol
                    combinations (as defined in <literal>WEBSSO_IDP_MAPPING</literal>). With the exception of <literal>credentials</literal>
                    which is reserved by horizon, and maps to the user name and password used by keystone’s
                    identity backend.</para>
      <screen language="python">WEBSSO_CHOICES = (
      ("credentials", _("Keystone Credentials")),
      ("openid", _("OpenID Connect")),
      ("mapped", _("Security Assertion Markup Language")),
      ("myidp_openid", "Acme Corporation - OpenID Connect"),
      ("myidp_mapped", "Acme Corporation - SAML2")
    )</screen>
      <procedure>
        <step>
          <para>(Optional) Create a dictionary of specific identity provider and federation
                            protocol combinations.</para>
        </step>
      </procedure>
      <para>A dictionary of specific identity provider and federation protocol combinations.
                    From the selected authentication mechanism, the value will be looked up as keys
                    in the dictionary. If a match is found, it will redirect the user to a identity
                    provider and federation protocol specific WebSSO endpoint in keystone, otherwise
                    it will use the value as the protocol_id when redirecting to the WebSSO by
                    protocol endpoint.</para>
      <screen language="python">WEBSSO_IDP_MAPPING = {
      "myidp_openid": ("myidp", "openid"),
      "myidp_mapped": ("myidp", "mapped")
    }</screen>
      <note>
        <para>The value is expected to be a tuple formatted as: (&lt;idp_id&gt;, &lt;protocol_id&gt;).</para>
      </note>
      <procedure>
        <step>
          <para>(Optional) Specify an initial choice with the <literal>WEBSSO_INITIAL_CHOICE</literal>
                            option.</para>
        </step>
      </procedure>
      <para>The list set by the <literal>WEBSSO_CHOICES</literal> option will be generated in a drop-down
                    menu in the login screen. The setting <literal>WEBSSO_INITIAL_CHOICE</literal> will
                    automatically set that choice to be highlighted by default.</para>
      <screen language="python">WEBSSO_INITIAL_CHOICE = "credentials"</screen>
      <procedure>
        <step>
          <para>Restart your web server:</para>
        </step>
      </procedure>
      <screen language="bash">$ sudo service apache2 restart</screen>
    </section>
  </section>
</section>
