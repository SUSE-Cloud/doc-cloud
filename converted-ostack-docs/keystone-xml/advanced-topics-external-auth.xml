<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Using external authentication with Keystone</title>
  <para>When Keystone is executed in a web server like Apache HTTPD,
            it is possible to have the web server also handle authentication.
            This enables support for additional methods of authentication that
            are not provided by the identity store backend and
            the authentication plugins that Keystone supports.</para>
  <para>Having the web server handle authentication is not exclusive, and both
            Keystone and the web server can provide different methods of authentication at
            the same time. For example, the web server can provide support for X.509 or
            Kerberos authentication, while Keystone provides support for password
            authentication (with SQL or an identity store as the backend).</para>
  <para>When the web server authenticates a user, it sets environment variables,
            usually <literal>REMOTE_USER</literal>, which can be used in the underlying application.
            Keystone can be configured to use these environment variables to determine the
            identity of the user.</para>
  <section>
    <title>Configuration</title>
    <para>In Identity API v2, there is no way to disable external authentication. In
                order to activate the external authentication mechanism for Identity API v3,
                the <literal>external</literal> method must be in the list of enabled authentication methods.
                By default it is enabled, so if you don’t want to use external authentication,
                remove it from the <literal>methods</literal> option in the <literal>auth</literal> section.</para>
    <para>To configure the plugin that should be used set the <literal>external</literal> option again
                in the <literal>auth</literal> section. There are two external authentication method plugins
                provided by Keystone:</para>
    <itemizedlist>
      <listitem>
        <para><literal>DefaultDomain</literal>: This plugin won’t take into account the domain information
                        that the external authentication method may pass down to Keystone and will
                        always use the configured default domain. The <literal>REMOTE_USER</literal> variable is the
                        username. This is the default if no plugin is given.</para>
      </listitem>
      <listitem>
        <para><literal>Domain</literal>: This plugin expects that the <literal>REMOTE_DOMAIN</literal> variable contains
                        the domain for the user. If this variable is not present, the configured
                        default domain will be used. The <literal>REMOTE_USER</literal> variable is the username.</para>
      </listitem>
    </itemizedlist>
    <important>
      <para>You should disable the external auth method if you are currently using
                    federation. External auth and federation both use the <literal>REMOTE_USER</literal>
                    variable. Since both the mapped and external plugin are being invoked to
                    validate attributes in the request environment, it can cause conflicts.</para>
      <para>For example, imagine there are two distinct users with the same username
                    <literal>foo</literal>, one in the <literal>Default</literal> domain while the other is in the <literal>BAR</literal> domain.
                    The external Federation modules (i.e. mod_shib) sets the <literal>REMOTE_USER</literal>
                    attribute to <literal>foo</literal>. The external auth module also tries to set the
                    <literal>REMOTE_USER</literal> attribute to <literal>foo</literal> for the <literal>Default</literal> domain. The
                    federated mapping engine maps the incoming identity to <literal>foo</literal> in the <literal>BAR</literal>
                    domain. This results in user_id conflict since both are using different
                    user_ids to set <literal>foo</literal> in the <literal>Default</literal> domain and the <literal>BAR</literal> domain.</para>
      <para>To disable this, simply remove <literal>external</literal> from the <literal>methods</literal> option in
                    <literal>keystone.conf</literal>:</para>
      <screen>methods = external,password,token,oauth1</screen>
    </important>
  </section>
  <section>
    <title>Using HTTPD authentication</title>
    <para>Web servers like Apache HTTP support many methods of authentication. Keystone
                can profit from this feature and let the authentication be done in the web
                server, that will pass down the authenticated user to Keystone using the
                <literal>REMOTE_USER</literal> environment variable. This user must exist in advance in the
                identity backend to get a token from the controller.</para>
    <para>To use this method, Keystone should be running on HTTPD.</para>
    <section>
      <title>X.509 example</title>
      <para>The following snippet for the Apache conf will authenticate the user based on
                    a valid X.509 certificate from a known CA:</para>
      <screen>&lt;VirtualHost _default_:5000&gt;
    SSLEngine on
    SSLCertificateFile    /etc/ssl/certs/ssl.cert
    SSLCertificateKeyFile /etc/ssl/private/ssl.key

    SSLCACertificatePath /etc/ssl/allowed_cas
    SSLCARevocationPath  /etc/ssl/allowed_cas
    SSLUserName          SSL_CLIENT_S_DN_CN
    SSLVerifyClient      require
    SSLVerifyDepth       10

    (...)
&lt;/VirtualHost&gt;</screen>
    </section>
  </section>
  <section>
    <title>Developing a WSGI middleware for authentication</title>
    <para>In addition to the method described above, it is possible to implement other
                custom authentication mechanisms using the <literal>REMOTE_USER</literal> WSGI environment
                variable.</para>
    <para>If you find you must implement a custom authentication mechanism, you will need
                to develop a custom WSGI middleware pipeline component. This middleware should
                set the environment variable <literal>REMOTE_USER</literal> to the authenticated username.
                Keystone then will assume that the user has been already authenticated upstream
                and will not try to authenticate it. However, as with HTTPD authentication, the
                user must exist in advance in the identity backend so that a proper token can
                be issued.</para>
    <para>Your code should set the <literal>REMOTE_USER</literal> if the user is properly authenticated,
                following the semantics below:</para>
    <screen language="python">from keystone.common import wsgi
from keystone import exception

class MyMiddlewareAuth(wsgi.Middleware):
    def __init__(self, *args, **kwargs):
        super(MyMiddlewareAuth, self).__init__(*args, **kwargs)

    def process_request(self, request):
        if request.environ.get('REMOTE_USER', None) is not None:
            # Assume that it is authenticated upstream
            return self.application

        if not self.is_auth_applicable(request):
            # Not applicable
            return self.application

        username = self.do_auth(request)
        if username is not None:
            # User is authenticated
            request.environ['REMOTE_USER'] = username
        else:
            # User is not authenticated, render exception
            raise exception.Unauthorized("Invalid user")</screen>
    <section>
      <title>Pipeline configuration</title>
      <para>Once you have your WSGI middleware component developed you have to add it to
                    your pipeline. The first step is to add the middleware to your configuration
                    file. Assuming that your middleware module is
                    <literal>keystone.middleware.MyMiddlewareAuth</literal>, you can configure it in your
                    <literal>keystone-paste.ini</literal> as:</para>
      <screen>[filter:my_auth]
paste.filter_factory = keystone.middleware.MyMiddlewareAuth.factory</screen>
      <para>The second step is to add your middleware to the pipeline. The exact place
                    where you should place it will depend on your code (i.e. if you need for
                    example that the request body is converted from JSON before perform the
                    authentication you should place it after the <literal>json_body</literal> filter) but it
                    should be set before the <literal>public_service</literal> (for the <literal>public_api</literal> pipeline)
                    or <literal>admin_service</literal> (for the <literal>admin_api</literal> pipeline), since they consume
                    authentication.</para>
      <para>For example, if the original pipeline looks like this:</para>
      <screen><?dbsuse-fo font-size="8pt"?>[pipeline:public_api]
pipeline = url_normalize token_auth admin_token_auth json_body debug ec2_extension user_crud_extension public_service</screen>
      <para>Your modified pipeline might then look like this:</para>
      <screen><?dbsuse-fo font-size="8pt"?>[pipeline:public_api]
pipeline = url_normalize token_auth admin_token_auth json_body my_auth debug ec2_extension user_crud_extension public_service</screen>
    </section>
  </section>
</section>
