<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Credential Encryption</title>
  <para>As of the Newton release, keystone encrypts all credentials stored in the
            default <literal>sql</literal> backend. Credentials are encrypted with the same mechanism used
            to encrypt Fernet tokens, <literal>fernet</literal>. Keystone provides only one type of
            credential encryption but the encryption provider is pluggable in the event
            you wish to supply a custom implementation.</para>
  <para>This document details how credential encryption works, how to migrate existing
            credentials in a deployment, and how to manage encryption keys for credentials.</para>
  <section>
    <title>Configuring credential encryption</title>
    <para>The configuration for credential encryption is straightforward. There are only
                two configuration options needed:</para>
    <screen language="ini">[credential]
provider = fernet
key_repository = /etc/keystone/credential-keys/</screen>
    <para><literal>[credential] provider</literal> defaults to the only option supplied by keystone,
                <literal>fernet</literal>. There is no reason to change this option unless you wish to provide
                a custom credential encryption implementation. The <literal>[credential]
key_repository</literal> location is a requirement of using <literal>fernet</literal> but will default
                to the <literal>/etc/keystone/credential-keys/</literal> directory. Both <literal>[credential]
key_repository</literal> and <literal>[fernet_tokens] key_repository</literal> define locations for
                keys used to encrypt things. One holds the keys to encrypt and decrypt
                credentials and the other holds keys to encrypt and decrypt tokens. It is
                imperative that these repositories are managed separately and they must not
                share keys. Meaning they cannot share the same directory path. The
                <literal>[credential] key_repository</literal> is only allowed to have three keys. This is not
                configurable and allows for credentials to be re-encrypted periodically with a
                new encryption key for the sake of security.</para>
  </section>
  <section>
    <title>How credential encryption works</title>
    <para>The implementation of this feature did not change any existing credential API
                contracts. All changes are transparent to the user unless you’re inspecting the
                credential backend directly.</para>
    <para>When creating a credential, keystone will encrypt the <literal>blob</literal> attribute before
                persisting it to the backend. Keystone will also store a hash of the key that
                was used to encrypt the information in that credential. Since Fernet is used to
                encrypt credentials, a key repository consists of multiple keys. Keeping track
                of which key was used to encrypt each credential is an important part of
                encryption key management. Why this is important is detailed later in the
                <literal>Encryption key management</literal> section.</para>
    <para>When updating an existing credential’s <literal>blob</literal> attribute, keystone will encrypt
                the new <literal>blob</literal> and update the key hash.</para>
    <para>When listing or showing credentials, all <literal>blob</literal> attributes are decrypted in
                the response. Neither the cipher text, nor the hash of the key used to encrypt
                the <literal>blob</literal> are exposed through the API. Furthermore, the key is only used
                internally to keystone.</para>
  </section>
  <section>
    <title>Encrypting existing credentials</title>
    <para>When upgrading a Mitaka deployment to Newton, three database migrations will
                ensure all credentials are encrypted. The process is as follows:</para>
    <procedure>
      <step>
        <para>An additive schema change is made to create the new <literal>encrypted_blob</literal> and
                        <literal>key_hash</literal> columns in the existing <literal>credential</literal> table using
                        <literal>keystone-manage db_sync --expand</literal>.</para>
      </step>
      <step>
        <para>A data migration will loop through all existing credentials, encrypt each
                        <literal>blob</literal> and store the result in the new <literal>encrypted_blob</literal> column. The hash
                        of the key used is also written to the <literal>key_hash</literal> column for that specific
                        credential. This step is done using <literal>keystone-manage db_sync --migrate</literal>.</para>
      </step>
      <step>
        <para>A contractive schema will remove the <literal>blob</literal> column that held the plain
                        text representations of the credential using <literal>keystone-manage db_sync
--contract</literal>. This should only be done after all nodes in the deployment are
                        running Newton. If any Mitaka nodes are running after the database is
                        contracted, they won’t be able to read credentials since they are looking
                        for the <literal>blob</literal> column that no longer exists.</para>
      </step>
    </procedure>
    <note>
      <para>You may also use <literal>keystone-manage db_sync --check</literal> in order to check the
                    current status of your rolling upgrades.</para>
    </note>
    <para>If performing a rolling upgrade, please note that a limited service outage will
                take affect during this migration. When the migration is in place, credentials
                will become read-only until the database is contracted. After the contract
                phase is complete, credentials will be writeable to the backend. A
                <literal>[credential] key_repository</literal> location must be specified through
                configuration and bootstrapped with keys using <literal>keystone-manage
credential_setup</literal> prior to migrating any existing credentials. If a new key
                repository isn’t setup using <literal>keystone-manage credential_setup</literal> keystone will
                assume a null key to encrypt and decrypt credentials until a proper key
                repository is present. The null key is a key consisting of all null bytes and
                its only purpose is to ease the upgrade process from Mitaka to Newton. It is
                highly recommended that the null key isn’t used. It is no more secure than
                storing credentials in plain text. If the null key is used, you should migrate
                to a proper key repository using <literal>keystone-manage credential_setup</literal> and
                <literal>keystone-manage credential_migrate</literal>.</para>
  </section>
  <section>
    <title>Encryption key management</title>
    <para>Key management of <literal>[credential] key_repository</literal> is handled with three
                <literal>keystone-manage</literal> commands:</para>
    <procedure>
      <step>
        <para>
          <literal>keystone-manage credential_setup</literal>
        </para>
      </step>
      <step>
        <para>
          <literal>keystone-manage credential_rotate</literal>
        </para>
      </step>
      <step>
        <para>
          <literal>keystone-manage credential_migrate</literal>
        </para>
      </step>
    </procedure>
    <para><literal>keystone-manage credential_setup</literal> will populate <literal>[credential]
key_repository</literal> with new encryption keys. This must be done in order for
                proper credential encryption to work, with the exception of the null key. This
                step should only be done once.</para>
    <para><literal>keystone-manage credential_rotate</literal> will create and rotate a new encryption
                key in the <literal>[credential] key_repository</literal>. This will only be done if all
                credential key hashes match the hash of the current primary key. If any
                credential has been encrypted with an older key, or secondary key, the rotation
                will fail. Failing the rotation is necessary to prevent overrotation, which
                would leave some credentials indecipherable since the key used to encrypt it
                no longer exists. If this step fails, it is possible to forcibly re-key all
                credentials using the same primary key with <literal>keystone-manage
credential_migrate</literal>.</para>
    <para><literal>keystone-manage credential_migrate</literal> will check the backend for credentials
                whose key hash doesn’t match the hash of the current primary key. Any
                credentials with a key hash mismatching the current primary key will be
                re-encrypted with the current primary key. The new cipher text and key hash
                will be updated in the backend.</para>
  </section>
</section>
