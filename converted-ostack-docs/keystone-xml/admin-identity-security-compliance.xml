<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Security compliance and PCI-DSS</title>
  <para>As of the Newton release, the Identity service contains additional security
            compliance features, specifically to satisfy Payment Card Industry -
            Data Security Standard (PCI-DSS) v3.1 requirements. See
            <link xlink:href="https://specs.openstack.org/openstack/keystone-specs/specs/keystone/newton/pci-dss.html">Security Hardening PCI-DSS</link> for more information on PCI-DSS.</para>
  <para>Security compliance features are disabled by default and most of the features
            only apply to the SQL backend for the identity driver. Other identity backends,
            such as LDAP, should implement their own security controls.</para>
  <para>Enable these features by changing the configuration settings under the
            <literal>[security_compliance]</literal> section in <literal>keystone.conf</literal>.</para>
  <section>
    <title>Setting an account lockout threshold</title>
    <para>The account lockout feature limits the number of incorrect password attempts.
                If a user fails to authenticate after the maximum number of attempts, the
                service disables the user. Users can be re-enabled by explicitly setting the
                enable user attribute with the update user API call, either
                <link xlink:href="https://developer.openstack.org/api-ref/identity/v2-admin/index.html?expanded=update-user-admin-endpoint-detail#update-user-admin-endpoint">v2.0</link> or <link xlink:href="https://developer.openstack.org/api-ref/identity/v3/index.html#update-user">v3</link>.</para>
    <para>You set the maximum number of failed authentication attempts by setting
                the <literal>lockout_failure_attempts</literal>:</para>
    <screen language="ini">[security_compliance]
lockout_failure_attempts = 6</screen>
    <para>You set the number of minutes a user would be locked out by setting
                the <literal>lockout_duration</literal> in seconds:</para>
    <screen language="ini">[security_compliance]
lockout_duration = 1800</screen>
    <para>If you do not set the <literal>lockout_duration</literal>, users will be locked out
                indefinitely until the user is explicitly enabled via the API.</para>
    <para>You can ensure specific users are never locked out. This can be useful for
                service accounts or administrative users. You can do this by setting
                <literal>ignore_lockout_failure_attempts</literal> to <literal>true</literal> via a user update API
                (<literal>PATCH /v3/users/{user_id}</literal>):</para>
    <screen language="json">{
    "user": {
        "options": {
            "ignore_lockout_failure_attempts": true
        }
    }
}</screen>
  </section>
  <section>
    <title>Disabling inactive users</title>
    <para>PCI-DSS 8.1.4 requires that inactive user accounts be removed or disabled
                within 90 days. You can achieve this by setting the
                <literal>disable_user_account_days_inactive</literal>:</para>
    <screen language="ini">[security_compliance]
disable_user_account_days_inactive = 90</screen>
    <para>This above example means that users that have not authenticated (inactive) for
                the past 90 days are automatically disabled. Users can be re-enabled by
                explicitly setting the enable user attribute via the API.</para>
  </section>
  <section>
    <title>Force users to change password upon first use</title>
    <para>PCI-DSS 8.2.6 requires users to change their password for first time use and
                upon an administrative password reset. Within the identity <link xlink:href="http://developer.openstack.org/api-ref/identity/v3/index.html#users">user API</link>,
                <literal>create user</literal> and <literal>update user</literal> are considered administrative password
                changes. Whereas, <literal>change password for user</literal> is a self-service password
                change. Once this feature is enabled, new users, and users that have had their
                password reset, will be required to change their password upon next
                authentication (first use), before being able to access any services.</para>
    <para>Prior to enabling this feature, you may want to exempt some users that you do
                not wish to be required to change their password. You can mark a user as
                exempt by setting the user options attribute
                <literal>ignore_change_password_upon_first_use</literal> to <literal>true</literal> via a user update API
                (<literal>PATCH /v3/users/{user_id}</literal>):</para>
    <screen language="json">{
    "user": {
        "options": {
            "ignore_change_password_upon_first_use": true
        }
    }
}</screen>
    <warning>
      <para>Failure to mark service users as exempt from this requirement will result
                    in your service account passwords becoming expired after being reset.</para>
    </warning>
    <para>When ready, you can configure it so that users are forced to change their
                password upon first use by setting <literal>change_password_upon_first_use</literal>:</para>
    <screen language="ini">[security_compliance]
change_password_upon_first_use = True</screen>
  </section>
  <section>
    <title>Configuring password expiration</title>
    <para>Passwords can be configured to expire within a certain number of days by
                setting the <literal>password_expires_days</literal>:</para>
    <screen language="ini">[security_compliance]
password_expires_days = 90</screen>
    <para>Once set, any new password changes have an expiration date based on the
                date/time of the password change plus the number of days defined here. Existing
                passwords will not be impacted. If you want existing passwords to have an
                expiration date, you would need to run a SQL script against the password table
                in the database to update the expires_at column.</para>
    <para>If there exists a user whose password you do not want to expire, keystone
                supports setting that userâ€™s option <literal>ignore_password_expiry</literal> to <literal>true</literal>
                via user update API (<literal>PATCH /v3/users/{user_id}</literal>):</para>
    <screen language="json">{
    "user": {
        "options": {
            "ignore_password_expiry": true
        }
    }
}</screen>
  </section>
  <section>
    <title>Configuring password strength requirements</title>
    <para>You can set password strength requirements, such as requiring numbers in
                passwords or setting a minimum password length, by adding a regular
                expression to the <literal>password_regex</literal> setting:</para>
    <screen language="ini">[security_compliance]
password_regex = ^(?=.*\d)(?=.*[a-zA-Z]).{7,}$</screen>
    <para>The above example is a regular expression that requires a password to have:</para>
    <itemizedlist>
      <listitem>
        <para>One (1) letter</para>
      </listitem>
      <listitem>
        <para>One (1) digit</para>
      </listitem>
      <listitem>
        <para>Minimum length of seven (7) characters</para>
      </listitem>
    </itemizedlist>
    <para>If you do set the <literal>password_regex</literal>, you should provide text that
                describes your password strength requirements. You can do this by setting the
                <literal>password_regex_description</literal>:</para>
    <screen language="ini">[security_compliance]
password_regex_description = Passwords must contain at least 1 letter, 1
                             digit, and be a minimum length of 7
                             characters.</screen>
    <para>It is imperative that the <literal>password_regex_description</literal> matches the actual
                regex. If the <literal>password_regex</literal> and the <literal>password_regex_description</literal> do
                not match, it will cause user experience to suffer since this description
                will be returned to users to explain why their requested password was
                insufficient.</para>
    <note>
      <para>You must ensure the <literal>password_regex_description</literal> accurately and
                    completely describes the <literal>password_regex</literal>. If the two options are out of
                    sync, the help text could inaccurately describe the password requirements
                    being applied to the password. This would lead to a poor user experience.</para>
    </note>
  </section>
  <section>
    <title>Requiring a unique password history</title>
    <para>The password history requirements controls the number of passwords for a user
                that must be unique before an old password can be reused. You can enforce this
                by setting the <literal>unique_last_password_count</literal>:</para>
    <screen language="ini">[security_compliance]
unique_last_password_count= 5</screen>
    <para>The above example does not allow a user to create a new password that is the
                same as any of their last four previous passwords.</para>
    <para>Similarly, you can set the number of days that a password must be used before
                the user can change it by setting the <literal>minimum_password_age</literal>:</para>
    <screen language="ini">[security_compliance]
minimum_password_age = 1</screen>
    <para>In the above example, once a user changes their password, they would not be
                able to change it again for one day. This prevents users from changing their
                passwords immediately in order to wipe out their password history and reuse an
                old password.</para>
    <note>
      <para>When you set <literal>password_expires_days</literal>, the value for the
                    <literal>minimum_password_age</literal> should be less than the <literal>password_expires_days</literal>.
                    Otherwise, users would not be able to change their passwords before they
                    expire.</para>
    </note>
  </section>
</section>
