<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Caching layer</title>
  <para>OpenStack Identity supports a caching layer that is above the configurable
            subsystems (for example, token). This gives you the flexibility to setup
            caching for all or some subsystems. OpenStack Identity uses the <link xlink:href="https://docs.openstack.org/oslo.cache/pike/">oslo.cache</link> library which allows
            flexible cache back ends. The majority of the caching configuration options are
            set in the <literal>[cache]</literal> section of the <literal>/etc/keystone/keystone.conf</literal> file. The
            <literal>enabled</literal> option of the <literal>[cache]</literal> section must be set to <literal>True</literal> in order
            for any subsystem to cache responses. Each section that has the capability to
            be cached will have a <literal>caching</literal> boolean value that toggles caching behavior
            of that particular subsystem.</para>
  <para>So to enable only the token back end caching, set the values as follows:</para>
  <screen language="ini">[cache]
enabled=true

[catalog]
caching=false

[domain_config]
caching=false

[federation]
caching=false

[resource]
caching=false

[revoke]
caching=false

[role]
caching=false

[token]
caching=true</screen>
  <note>
    <para>Each subsystem is configured to cache by default. However, the global
                toggle for caching defaults to <literal>False</literal>. A subsystem is only able to cache
                responses if the global toggle is enabled.</para>
  </note>
  <para>Current functional back ends are:</para>
  <variablelist>
    <varlistentry>
      <term>
        <literal>dogpile.cache.memcached</literal>
      </term>
      <listitem>
        <para>Memcached back end using the standard <literal>python-memcached</literal> library.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>
        <literal>dogpile.cache.pylibmc</literal>
      </term>
      <listitem>
        <para>Memcached back end using the <literal>pylibmc</literal> library.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>
        <literal>dogpile.cache.bmemcached</literal>
      </term>
      <listitem>
        <para>Memcached using the <literal>python-binary-memcached</literal> library.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>
        <literal>dogpile.cache.redis</literal>
      </term>
      <listitem>
        <para>Redis back end.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>
        <literal>dogpile.cache.dbm</literal>
      </term>
      <listitem>
        <para>Local DBM file back end.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>
        <literal>dogpile.cache.memory</literal>
      </term>
      <listitem>
        <para>In-memory cache, not suitable for use outside of testing as it does not
                        cleanup its internal cache on cache expiration and does not share cache
                        between processes. This means that caching and cache invalidation will not
                        be consistent or reliable.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>
        <literal>dogpile.cache.mongo</literal>
      </term>
      <listitem>
        <para>MongoDB as caching back end.</para>
      </listitem>
    </varlistentry>
  </variablelist>
  <section>
    <title>Caching for tokens and tokens validation</title>
    <para>The token subsystem is OpenStack Identityâ€™s most heavily used API. As a result,
                all types of tokens benefit from caching, including Fernet tokens. Although
                Fernet tokens do not need to be persisted, they should still be cached for
                optimal token validation performance.</para>
    <para>The token system has a separate <literal>cache_time</literal> configuration option,
                that can be set to a value above or below the global <literal>expiration_time</literal>
                default, allowing for different caching behavior from the other systems
                in OpenStack Identity. This option is set in the <literal>[token]</literal> section of
                the configuration file.</para>
    <para>The token revocation list cache time is handled by the configuration
                option <literal>revocation_cache_time</literal> in the <literal>[token]</literal> section. The
                revocation list is refreshed whenever a token is revoked. It typically
                sees significantly more requests than specific token retrievals or token
                validation calls.</para>
    <para>Here is a list of actions that are affected by the cached time: getting
                a new token, revoking tokens, validating tokens, checking v2 tokens, and
                checking v3 tokens.</para>
    <para>The delete token API calls invalidate the cache for the tokens being
                acted upon, as well as invalidating the cache for the revoked token list
                and the validate and check token calls.</para>
    <para>Token caching is configurable independently of the <literal>revocation_list</literal>
                caching. Lifted expiration checks from the token drivers to the token
                manager. This ensures that cached tokens will still raise a
                <literal>TokenNotFound</literal> flag when expired.</para>
    <para>For cache consistency, all token IDs are transformed into the short
                token hash at the provider and token driver level. Some methods have
                access to the full ID (PKI Tokens), and some methods do not. Cache
                invalidation is inconsistent without token ID normalization.</para>
  </section>
  <section>
    <title>Caching for non-token resources</title>
    <para>Various other keystone components have a separate <literal>cache_time</literal> configuration
                option, that can be set to a value above or below the global
                <literal>expiration_time</literal> default, allowing for different caching behavior
                from the other systems in Identity service. This option can be set in various
                sections (for example, <literal>[role]</literal> and <literal>[resource]</literal>) of the configuration
                file.
                The create, update, and delete actions for domains, projects and roles
                will perform proper invalidations of the cached methods listed above.</para>
    <para>For more information about the different back ends (and configuration
                options), see:</para>
    <itemizedlist>
      <listitem>
        <para>
          <link xlink:href="https://dogpilecache.sqlalchemy.org/en/latest/api.html#memory-backends">dogpile.cache.memory</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link xlink:href="https://dogpilecache.sqlalchemy.org/en/latest/api.html#memcached-backends">dogpile.cache.memcached</link>
        </para>
        <note>
          <para>The memory back end is not suitable for use in a production
                            environment.</para>
        </note>
      </listitem>
      <listitem>
        <para>
          <link xlink:href="https://dogpilecache.sqlalchemy.org/en/latest/api.html#redis-backends">dogpile.cache.redis</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link xlink:href="https://dogpilecache.sqlalchemy.org/en/latest/api.html#file-backends">dogpile.cache.dbm</link>
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Cache invalidation</title>
    <para>A common concern with caching is relaying inaccurate information after updating
                or deleting a resource. Most subsystems within OpenStack Identity invalidate
                specific cache entries once they have changed. In cases where a specific cache
                entry cannot be invalidated from the cache, the cache region will be
                invalidated instead. This invalidates all entries within the cache to prevent
                returning stale or misleading data. A subsequent request for the resource will
                be fully processed and cached.</para>
    <warning>
      <para>Be aware that if a read-only back end is in use for a particular subsystem,
                    the cache will not immediately reflect changes performed through the back
                    end. Any given change may take up to the <literal>cache_time</literal> (if set in the
                    subsystem section of the configuration) or the global <literal>expiration_time</literal>
                    (set in the <literal>[cache]</literal> section of the configuration) before it is
                    reflected. If this type of delay is an issue, we recommend disabling
                    caching for that particular subsystem.</para>
    </warning>
  </section>
  <section>
    <title>Configure the Memcached back end example</title>
    <para>The following example shows how to configure the memcached back end:</para>
    <screen language="ini">[cache]

enabled = true
backend = dogpile.cache.memcached
backend_argument = url:127.0.0.1:11211</screen>
    <para>You need to specify the URL to reach the <literal>memcached</literal> instance with the
                <literal>backend_argument</literal> parameter.</para>
  </section>
</section>
