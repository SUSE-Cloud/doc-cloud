<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Keystone Architecture</title>
  <para>Much of the design assumes that in most deployments auth backends will be shims
            in front of existing user systems.</para>
  <section>
    <title>Services</title>
    <para>Keystone is organized as a group of internal services exposed on one or many
                endpoints. Many of these services are used in a combined fashion by the
                frontend. For example, an authenticate call will validate user/project
                credentials with the Identity service and, upon success, create and return a
                token with the Token service.</para>
    <section>
      <title>Identity</title>
      <para>The Identity service provides auth credential validation and data about <literal>users</literal>
                    and <literal>groups</literal>. In the basic case, this data is managed by the Identity service,
                    allowing it to also handle all CRUD operations associated with this data. In
                    more complex cases, the data is instead managed by an authoritative backend
                    service. An example of this would be when the Identity service acts as a
                    frontend for LDAP. In that case the LDAP server is the source of truth and the
                    role of the Identity service is to relay that information accurately.</para>
      <section>
        <title>Users</title>
        <para><literal>Users</literal> represent an individual API consumer. A user itself must be owned by
                        a specific domain, and hence all user names are <emphasis role="bold">not</emphasis> globally unique, but
                        only unique to their domain.</para>
      </section>
      <section>
        <title>Groups</title>
        <para><literal>Groups</literal> are a container representing a collection of users. A group itself
                        must be owned by a specific domain, and hence all group names are <emphasis role="bold">not</emphasis>
                        globally unique, but only unique to their domain.</para>
      </section>
    </section>
    <section>
      <title>Resource</title>
      <para>The Resource service provides data about <literal>projects</literal> and <literal>domains</literal>.</para>
      <section>
        <title>Projects (Tenants)</title>
        <para><literal>Projects</literal> (known as <literal>Tenants</literal> in v2.0) represent the base unit of
                        <literal>ownership</literal> in OpenStack, in that all resources in OpenStack should be owned
                        by a specific project. A project itself must be owned by a specific domain, and
                        hence all project names are <emphasis role="bold">not</emphasis> globally unique, but unique to their
                        domain. If the domain for a project is not specified, then it is added to the
                        default domain.</para>
      </section>
      <section>
        <title>Domains</title>
        <para><literal>Domains</literal> are a high-level container for projects, users and groups. Each is
                        owned by exactly one domain. Each domain defines a namespace where an
                        API-visible name attribute exists. Keystone provides a default domain, aptly
                        named ‘Default’.</para>
        <para>In the Identity v3 API, the uniqueness of attributes is as follows:</para>
        <itemizedlist>
          <listitem>
            <para>Domain Name. Globally unique across all domains.</para>
          </listitem>
          <listitem>
            <para>Role Name. Unique within the owning domain.</para>
          </listitem>
          <listitem>
            <para>User Name. Unique within the owning domain.</para>
          </listitem>
          <listitem>
            <para>Project Name. Unique within the owning domain.</para>
          </listitem>
          <listitem>
            <para>Group Name. Unique within the owning domain.</para>
          </listitem>
        </itemizedlist>
        <para>Due to their container architecture, domains may be used as a way to delegate
                        management of OpenStack resources. A user in a domain may still access
                        resources in another domain, if an appropriate assignment is granted.</para>
      </section>
    </section>
    <section>
      <title>Assignment</title>
      <para>The Assignment service provides data about <literal>roles</literal> and <literal>role assignments</literal>.</para>
      <section>
        <title>Roles</title>
        <para><literal>Roles</literal> dictate the level of authorization the end user can obtain. Roles
                        can be granted at either the domain or project level. A role can be assigned at
                        the individual user or group level. Role names are unique within the
                        owning domain.</para>
      </section>
      <section>
        <title>Role Assignments</title>
        <para>A 3-tuple that has a <literal>Role</literal>, a <literal>Resource</literal> and an <literal>Identity</literal>.</para>
      </section>
    </section>
    <section>
      <title>Token</title>
      <para>The Token service validates and manages tokens used for authenticating requests
                    once a user’s credentials have already been verified.</para>
    </section>
    <section>
      <title>Catalog</title>
      <para>The Catalog service provides an endpoint registry used for endpoint discovery.</para>
    </section>
    <section>
      <title>Policy</title>
      <para>The Policy service provides a rule-based authorization engine and the
                    associated rule management interface.</para>
    </section>
  </section>
  <section>
    <title>Application Construction</title>
    <para>Keystone is an HTTP front-end to several services. Like other OpenStack
                applications, this is done using python WSGI interfaces and applications are
                configured together using <link xlink:href="http://pythonpaste.org/">Paste</link>. The application’s HTTP endpoints are made up
                of pipelines of WSGI middleware, such as:</para>
    <screen language="ini"><?dbsuse-fo font-size="8pt"?>[pipeline:api_v3]
pipeline = healthcheck cors sizelimit http_proxy_to_wsgi osprofiler url_normalize request_id build_auth_context token_auth json_body ec2_extension_v3 s3_extension service_v3</screen>
    <para>These in turn use a subclass of <literal>keystone.common.wsgi.ComposingRouter</literal> to
                link URLs to controllers (a subclass of
                <literal>keystone.common.wsgi.Application</literal>). Within each controller, one or more
                managers are loaded (for example, see <literal>keystone.catalog.core.Manager</literal>),
                which are thin wrapper classes which load the appropriate service driver based
                on the keystone configuration.</para>
    <itemizedlist>
      <listitem>
        <para>Assignment</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.assignment.controllers.GrantAssignmentV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.assignment.controllers.ImpliedRolesV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.assignment.controllers.ProjectAssignmentV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.assignment.controllers.TenantAssignment</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.assignment.controllers.Role</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.assignment.controllers.RoleAssignmentV2</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.assignment.controllers.RoleAssignmentV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.assignment.controllers.RoleV3</literal>
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>Authentication</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.auth.controllers.Auth</literal>
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>Catalog</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.catalog.controllers.EndpointFilterV3Controller</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.catalog.controllers.EndpointGroupV3Controller</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.catalog.controllers.EndpointV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.catalog.controllers.ProjectEndpointGroupV3Controller</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.catalog.controllers.RegionV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.catalog.controllers.ServiceV3</literal>
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>Credentials</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.contrib.ec2.controllers.Ec2ControllerV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.credential.controllers.CredentialV3</literal>
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>Federation</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.federation.controllers.IdentityProvider</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.federation.controllers.FederationProtocol</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.federation.controllers.MappingController</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.federation.controllers.ServiceProvider</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.federation.controllers.SAMLMetadataV3</literal>
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>Identity</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.identity.controllers.GroupV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.identity.controllers.UserV3</literal>
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>Policy</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.policy.controllers.PolicyV3</literal>
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>Resource</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.resource.controllers.DomainV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.resource.controllers.DomainConfigV3</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.resource.controllers.ProjectV3</literal>
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>Revoke</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.revoke.controllers.RevokeController</literal>
        </para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>Trust</para>
      </listitem>
    </itemizedlist>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.trust.controllers.TrustV3</literal>
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Service Backends</title>
    <para>Each of the services can be configured to use a backend to allow keystone to
                fit a variety of environments and needs. The backend for each service is
                defined in the keystone.conf file with the key <literal>driver</literal> under a group
                associated with each service.</para>
    <para>A general class exists under each backend to provide an abstract base class
                for any implementations, identifying the expected service implementations. The
                abstract base classes are stored in the service’s backends directory as
                <literal>base.py</literal>. The corresponding drivers for the services are:</para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.assignment.backends.base.AssignmentDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.assignment.role_backends.base.RoleDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.auth.plugins.base.AuthMethodHandler</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.catalog.backends.base.CatalogDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.credential.backends.base.CredentialDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.endpoint_policy.backends.base.EndpointPolicyDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.federation.backends.base.FederationDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.identity.backends.base.IdentityDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.identity.mapping_backends.base.MappingDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.identity.shadow_backends.base.ShadowUsersDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.oauth1.backends.base.Oauth1DriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.policy.backends.base.PolicyDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.resource.backends.base.ResourceDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.resource.config_backends.base.DomainConfigDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.revoke.backends.base.RevokeDriverBase</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.token.providers.base.Provider</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.trust.backends.base.TrustDriverBase</literal>
        </para>
      </listitem>
    </itemizedlist>
    <para>If you implement a backend driver for one of the keystone services, you’re
                expected to subclass from these classes.</para>
    <section>
      <title>Templated Backend</title>
      <para>Largely designed for a common use case around service catalogs in the keystone
                    project, a templated backend is a catalog backend that simply expands
                    pre-configured templates to provide catalog data.</para>
      <para>Example paste.deploy config (uses $ instead of % to avoid ConfigParser’s
                    interpolation)</para>
      <screen language="ini">[DEFAULT]
catalog.RegionOne.identity.publicURL = http://localhost:$(public_port)s/v2.0
catalog.RegionOne.identity.adminURL = http://localhost:$(public_port)s/v2.0
catalog.RegionOne.identity.internalURL = http://localhost:$(public_port)s/v2.0
catalog.RegionOne.identity.name = 'Identity Service'</screen>
    </section>
  </section>
  <section>
    <title>Data Model</title>
    <para>Keystone was designed from the ground up to be amenable to multiple styles of
                backends. As such, many of the methods and data types will happily accept more
                data than they know what to do with and pass them on to a backend.</para>
    <para>There are a few main data types:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">User</emphasis>: has account credentials, is associated with one or more projects or domains</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Group</emphasis>: a collection of users, is associated with one or more projects or domains</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Project</emphasis>: unit of ownership in OpenStack, contains one or more users</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Domain</emphasis>: unit of ownership in OpenStack, contains users, groups and projects</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Role</emphasis>: a first-class piece of metadata associated with many user-project pairs.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Token</emphasis>: identifying credential associated with a user or user and project</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Extras</emphasis>: bucket of key-value metadata associated with a user-project pair.</para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Rule</emphasis>: describes a set of requirements for performing an action.</para>
      </listitem>
    </itemizedlist>
    <para>While the general data model allows a many-to-many relationship between users
                and groups to projects and domains; the actual backend implementations take
                varying levels of advantage of that functionality.</para>
  </section>
  <section>
    <title>Approach to CRUD</title>
    <para>While it is expected that any “real” deployment at a large company will manage
                their users and groups in their existing user systems, a variety of CRUD
                operations are provided for the sake of development and testing.</para>
    <para>CRUD is treated as an extension or additional feature to the core feature set
                in that it is not required that a backend support it. It is expected that
                backends for services that don’t support the CRUD operations will raise a
                <literal>keystone.exception.NotImplemented</literal>.</para>
  </section>
  <section>
    <title>Approach to Authorization (Policy)</title>
    <para>Various components in the system require that different actions are allowed
                based on whether the user is authorized to perform that action.</para>
    <para>For the purposes of keystone there are only a couple levels of authorization
                being checked for:</para>
    <itemizedlist>
      <listitem>
        <para>Require that the performing user is considered an admin.</para>
      </listitem>
      <listitem>
        <para>Require that the performing user matches the user being referenced.</para>
      </listitem>
    </itemizedlist>
    <para>Other systems wishing to use the policy engine will require additional styles
                of checks and will possibly write completely custom backends. By default,
                keystone leverages policy enforcement that is maintained in <link xlink:href="https://git.openstack.org/cgit/openstack/oslo.policy/">oslo.policy</link>.</para>
    <section>
      <title>Rules</title>
      <para>Given a list of matches to check for, simply verify that the credentials
                    contain the matches. For example:</para>
      <screen language="python">credentials = {'user_id': 'foo', 'is_admin': 1, 'roles': ['nova:netadmin']}

# An admin only call:
policy_api.enforce(('is_admin:1',), credentials)

# An admin or owner call:
policy_api.enforce(('is_admin:1', 'user_id:foo'), credentials)

# A netadmin call:
policy_api.enforce(('roles:nova:netadmin',), credentials)</screen>
      <para>Credentials are generally built from the user metadata in the ‘extras’ part
                    of the Identity API. So, adding a ‘role’ to the user just means adding the role
                    to the user metadata.</para>
    </section>
    <section>
      <title>Capability RBAC</title>
      <para>(Not yet implemented.)</para>
      <para>Another approach to authorization can be action-based, with a mapping of roles
                    to which capabilities are allowed for that role. For example:</para>
      <screen language="python">credentials = {'user_id': 'foo', 'is_admin': 1, 'roles': ['nova:netadmin']}

# add a policy
policy_api.add_policy('action:nova:add_network', ('roles:nova:netadmin',))

policy_api.enforce(('action:nova:add_network',), credentials)</screen>
      <para>In the backend this would look up the policy for ‘action:nova:add_network’ and
                    then do what is effectively a ‘Simple Match’ style match against the credentials.</para>
    </section>
  </section>
  <section>
    <title>Approach to Authentication</title>
    <para>Keystone provides several authentication plugins that inherit from
                <literal>keystone.auth.plugins.base</literal>. The following is a list of available plugins.</para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>keystone.auth.plugins.external.Base</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.auth.plugins.mapped.Mapped</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.auth.plugins.oauth1.OAuth</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.auth.plugins.password.Password</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.auth.plugins.token.Token</literal>
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>keystone.auth.plugins.totp.TOTP</literal>
        </para>
      </listitem>
    </itemizedlist>
    <para>In the most basic plugin <literal>password</literal>, two pieces of information are required
                to authenticate with keystone, a bit of <literal>Resource</literal> information and a bit of
                <literal>Identity</literal>.</para>
    <para>Take the following call POST data for instance:</para>
    <screen language="javascript">{
    "auth": {
        "identity": {
            "methods": [
                "password"
            ],
            "password": {
                "user": {
                    "id": "0ca8f6",
                    "password": "secretsecret"
                }
            }
        },
        "scope": {
            "project": {
                "id": "263fd9"
            }
        }
    }
}</screen>
    <para>The user (ID of 0ca8f6) is attempting to retrieve a token that is scoped to
                project (ID of 263fd9).</para>
    <para>To perform the same call with names instead of IDs, we now need to supply
                information about the domain. This is because usernames are only unique within
                a given domain, but user IDs are supposed to be unique across the deployment.
                Thus, the auth request looks like the following:</para>
    <screen language="javascript">{
    "auth": {
        "identity": {
            "methods": [
                "password"
            ],
            "password": {
                "user": {
                    "domain": {
                        "name": "acme"
                    }
                    "name": "userA",
                    "password": "secretsecret"
                }
            }
        },
        "scope": {
            "project": {
                "domain": {
                    "id": "1789d1"
                },
                "name": "project-x"
            }
        }
    }
}</screen>
    <para>For both the user and the project portion, we must supply either a domain ID
                or a domain name, in order to properly determine the correct user and project.</para>
    <para>Alternatively, if we wanted to represent this as environment variables for a
                command line, it would be:</para>
    <screen language="bash">$ export OS_PROJECT_DOMAIN_ID=1789d1
$ export OS_USER_DOMAIN_NAME=acme
$ export OS_USERNAME=userA
$ export OS_PASSWORD=secretsecret
$ export OS_PROJECT_NAME=project-x</screen>
    <para>Note that the project the user is attempting to access must be in the same
                domain as the user.</para>
    <section>
      <title>What is Scope?</title>
      <para>Scope is an overloaded term.</para>
      <para>In reference to authenticating, as seen above, scope refers to the portion
                    of the POST data that dictates what <literal>Resource</literal> (project or domain) the user
                    wants to access.</para>
      <para>In reference to tokens, scope refers to the effectiveness of a token,
                    i.e.: a <literal>project-scoped</literal> token is only useful on the project it was initially
                    granted for. A <literal>domain-scoped</literal> token may be used to perform domain-related
                    function.</para>
      <para>In reference to users, groups, and projects, scope often refers to the domain
                    that the entity is owned by. i.e.: a user in domain X is scoped to domain X.</para>
    </section>
  </section>
</section>
