<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Configuring Keystone for Tokenless Authorization</title>
  <note>
    <para>This feature is experimental and unsupported in Liberty.</para>
  </note>
  <section>
    <title>Definitions</title>
    <itemizedlist>
      <listitem>
        <para><literal>X.509 Tokenless Authorization</literal>: Provides a means to authorize client
                        operations within Keystone by using an X.509 SSL client certificate
                        without having to issue a token. For details, please refer to the specs
                        <link xlink:href="https://specs.openstack.org/openstack/keystone-specs/specs/liberty/keystone-tokenless-authz-with-x509-ssl-client-cert.html">Tokenless Authorization with X.509 Client SSL Certificate</link></para>
      </listitem>
    </itemizedlist>
    <section>
      <title>Prerequisites</title>
      <para>Keystone must be running in a web container with https enabled; tests have
                    been done with Apache/2.4.7 running on Ubuntu 14.04 . Please refer to
                    <link xlink:href="https://docs.openstack.org/developer/keystone/apache-httpd.html">running-keystone-in-httpd</link> and <link xlink:href="https://www.digitalocean.com/community/tutorials/how-to-create-a-ssl-certificate-on-apache-for-ubuntu-14-04">apache-certificate-and-key-installation</link>
                    as references for this setup.</para>
    </section>
  </section>
  <section>
    <title>Apache Configuration</title>
    <para>To enable X.509 tokenless authorization, SSL has to be enabled and configured
                in the Apache virtual host file. The Client authentication attribute
                <literal>SSLVerifyClient</literal> should be set as <literal>optional</literal> to allow other token
                authentication methods and attribute <literal>SSLOptions</literal> needs to set as
                <literal>+StdEnvVars</literal> to allow certificate attributes to be passed. The following
                is the sample virtual host file used for the testing.</para>
    <screen language="ini">&lt;VirtualHost *:443&gt;
    WSGIScriptAlias / /var/www/cgi-bin/keystone/main
    ErrorLog /var/log/apache2/keystone.log
    LogLevel debug
    CustomLog /var/log/apache2/access.log combined
    SSLEngine on
    SSLCertificateFile    /etc/apache2/ssl/apache.cer
    SSLCertificateKeyFile /etc/apache2/ssl/apache.key
    SSLCACertificatePath /etc/apache2/capath
    SSLOptions +StdEnvVars
    SSLVerifyClient optional
&lt;/VirtualHost&gt;</screen>
  </section>
  <section>
    <title>Keystone Configuration</title>
    <para>The following options can be defined in <literal>keystone.conf</literal>:</para>
    <itemizedlist>
      <listitem>
        <para><literal>trusted_issuer</literal> - The multi-str list of trusted issuers to further
                        filter the certificates that are allowed to participate in the X.509
                        tokenless authorization. If the option is absent then no certificates
                        will be allowed. The naming format for the attributes of a Distinguished
                        Name(DN) must be separated by a comma and contain no spaces; however
                        spaces are allowed for the value of an attribute, like ‘L=San Jose’ in
                        the example below. This configuration option may be repeated for multiple
                        values. Please look at the sample below.</para>
      </listitem>
      <listitem>
        <para><literal>protocol</literal> - The protocol name for the X.509 tokenless authorization
                        along with the option <literal>issuer_attribute</literal> below can look up its
                        corresponding mapping. It defaults to <literal>x509</literal>.</para>
      </listitem>
      <listitem>
        <para><literal>issuer_attribute</literal> - The issuer attribute that is served as an IdP ID for
                        the X.509 tokenless authorization along with the protocol to look up its
                        corresponding mapping. It is the environment variable in the WSGI
                        environment that references to the Issuer of the client certificate. It
                        defaults to <literal>SSL_CLIENT_I_DN</literal>.</para>
      </listitem>
    </itemizedlist>
    <para>This is a sample configuration for two <literal>trusted_issuer</literal> and a <literal>protocol</literal> set
                to <literal>x509</literal>.</para>
    <screen language="ini"><?dbsuse-fo font-size="8pt"?>[tokenless_auth]
trusted_issuer = emailAddress=mary@abc.com,CN=mary,OU=eng,O=abc,L=San Jose,ST=California,C=US
trusted_issuer = emailAddress=john@openstack.com,CN=john,OU=keystone,O=openstack,L=Sunnyvale,ST=California,C=US
protocol = x509</screen>
  </section>
  <section>
    <title>Setup Mapping</title>
    <para>Like federation, X.509 tokenless authorization also utilizes the mapping
                mechanism to formulate an identity. The identity provider must correspond
                to the issuer of the X.509 SSL client certificate. The protocol for the
                given identity is <literal>x509</literal> by default, but can be configurable.</para>
    <section>
      <title>Create an Identity Provider (IdP)</title>
      <para>In order to create an IdP, the issuer DN in the client certificate needs
                    to be provided. The following sample is what a generic issuer DN looks
                    like in a certificate.</para>
      <screen language="ini">E=john@openstack.com
CN=john
OU=keystone
O=openstack
L=Sunnyvale
S=California
C=US</screen>
      <para>The issuer DN should be constructed as a string that contains no spaces
                    and have the right order separated by commas like the example below.
                    Please be aware that <literal>emailAddress</literal> and <literal>ST</literal> should be used instead
                    of <literal>E</literal> and <literal>S</literal> that are shown in the above example. The following is
                    the sample Python code used to create the IdP ID.</para>
      <screen language="python">import hashlib
issuer_dn = 'emailAddress=john@openstack.com,CN=john,OU=keystone,
    O=openstack,L=Sunnyvale,ST=California,C=US'
hashed_idp = hashlib.sha256(issuer_dn)
idp_id = hashed_idp.hexdigest()
print(idp_id)</screen>
      <para>The output of the above Python code will be the IdP ID and the following
                    sample curl command should be sent to keystone to create an IdP with the
                    newly generated IdP ID.</para>
      <screen language="bash"><?dbsuse-fo font-size="8pt"?>curl -k -s -X PUT -H "X-Auth-Token: &lt;TOKEN&gt;" \
     -H "Content-Type: application/json" \
     -d '{"identity_provider": {"description": "Stores keystone IDP identities.","enabled": true}}' \
     https://&lt;HOSTNAME&gt;:&lt;PORT&gt;/v3/OS-FEDERATION/identity_providers/&lt;IdP ID&gt;</screen>
    </section>
    <section>
      <title>Create a Map</title>
      <para>A mapping needs to be created to map the <literal>Subject DN</literal> in the client
                    certificate as a user to yield a valid local user if the user’s <literal>type</literal>
                    defined as <literal>local</literal> in the mapping. For example, the client certificate
                    has <literal>Subject DN</literal> as <literal>CN=alex,OU=eng,O=nice-network,L=Sunnyvale,
ST=California,C=US</literal>, in the following examples, <literal>user_name</literal> will be
                    mapped to``alex`` and <literal>domain_name</literal> will be mapped to <literal>nice-network</literal>.
                    And it has user’s <literal>type</literal> set to <literal>local</literal>. If user’s <literal>type</literal> is not
                    defined, it defaults to <literal>ephemeral</literal>.</para>
      <para>Please refer to <link xlink:href="http://httpd.apache.org/docs/current/mod/mod_ssl.html">mod_ssl</link> for the detailed mapping attributes.</para>
      <screen language="javascript">{
     "mapping": {
         "rules": [
             {
                 "local": [
                     {
                        "user": {
                            "name": "{0}",
                            "domain": {
                                "name": "{1}"
                            },
                            "type": "local"
                        }
                     }
                ],
                "remote": [
                    {
                        "type": "SSL_CLIENT_S_DN_CN"
                    },
                    {
                        "type": "SSL_CLIENT_S_DN_O"
                    }
                ]
            }
        ]
    }
}</screen>
      <para>When user’s <literal>type</literal> is not defined or set to <literal>ephemeral</literal>, the mapped user
                    does not have to be a valid local user but the mapping must yield at least
                    one valid local group. For example:</para>
      <screen language="javascript">{
     "mapping": {
         "rules": [
             {
                 "local": [
                     {
                        "user": {
                            "name": "{0}",
                            "type": "ephemeral"
                        }
                     },
                     {
                        "group": {
                            "id": "12345678"
                        }
                     }
                ],
                "remote": [
                    {
                        "type": "SSL_CLIENT_S_DN_CN"
                    }
                ]
            }
        ]
    }
}</screen>
      <para>The following sample curl command should be sent to keystone to create a
                    mapping with the provided mapping ID. The mapping ID is user designed and
                    it can be any string as opposed to IdP ID.</para>
      <screen language="bash"><?dbsuse-fo font-size="8pt"?>curl -k -s -H "X-Auth-Token: &lt;TOKEN&gt;" \
     -H "Content-Type: application/json" \
     -d '{"mapping": {"rules": [{"local": [{"user": {"name": "{0}","type": "ephemeral"}},{"group": {"id": "&lt;GROUPID&gt;"}}],"remote": [{"type": "SSL_CLIENT_S_DN_CN"}]}]}}' \
     -X PUT https://&lt;HOSTNAME&gt;:&lt;PORT&gt;/v3/OS-FEDERATION/mappings/&lt;MAPPING ID&gt;</screen>
    </section>
    <section>
      <title>Create a Protocol</title>
      <para>The name of the protocol will be the one defined in <literal>keystone.conf</literal> as
                    <literal>protocol</literal> which defaults to <literal>x509</literal>. The protocol name is user designed
                    and it can be any name as opposed to IdP ID.</para>
      <para>A protocol name and an IdP ID will uniquely identify a mapping.</para>
      <para>The following sample curl command should be sent to keystone to create a
                    protocol with the provided protocol name that is defined in <literal>keystone.conf</literal>.</para>
      <screen language="bash"><?dbsuse-fo font-size="8pt"?>curl -k -s -H "X-Auth-Token: &lt;TOKEN&gt;" \
     -H "Content-Type: application/json" \
     -d '{"protocol": {"mapping_id": "&lt;MAPPING ID&gt;"}}' \
     -X PUT https://&lt;HOSTNAME&gt;:&lt;PORT&gt;/v3/OS-FEDERATION/identity_providers/&lt;IdP ID&gt;/protocols/&lt;PROTOCOL NAME&gt;</screen>
    </section>
  </section>
  <section>
    <title>Setup <literal>auth_token</literal> middleware</title>
    <para>In order to use <literal>auth_token</literal> middleware as the service client for X.509
                tokenless authorization, both configurable options and scope information
                will need to be setup.</para>
    <section>
      <title>Configurable Options</title>
      <para>The following configurable options in <literal>auth_token</literal> middleware
                    should set to the correct values:</para>
      <itemizedlist>
        <listitem>
          <para><literal>auth_protocol</literal> - Set to <literal>https</literal>.</para>
        </listitem>
        <listitem>
          <para><literal>certfile</literal> - Set to the full path of the certificate file.</para>
        </listitem>
        <listitem>
          <para><literal>keyfile</literal> - Set to the full path of the private key file.</para>
        </listitem>
        <listitem>
          <para><literal>cafile</literal> - Set to the full path of the trusted CA certificate file.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Scope Information</title>
      <para>The scope information will be passed from the headers with the following
                    header attributes to:</para>
      <itemizedlist>
        <listitem>
          <para><literal>X-Project-Id</literal> - If specified, its the project scope.</para>
        </listitem>
        <listitem>
          <para><literal>X-Project-Name</literal> - If specified, its the project scope.</para>
        </listitem>
        <listitem>
          <para><literal>X-Project-Domain-Id</literal> - If specified, its the domain of project scope.</para>
        </listitem>
        <listitem>
          <para><literal>X-Project-Domain-Name</literal> - If specified, its the domain of project scope.</para>
        </listitem>
        <listitem>
          <para><literal>X-Domain-Id</literal> - If specified, its the domain scope.</para>
        </listitem>
        <listitem>
          <para><literal>X-Domain-Name</literal> - If specified, its the domain scope.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Test It Out with cURL</title>
    <para>Once the above configurations have been setup, the following curl command can
                be used for token validation.</para>
    <screen language="bash">curl -v -k -s -X GET --cert /&lt;PATH&gt;/x509client.crt \
     --key /&lt;PATH&gt;/x509client.key \
     --cacert /&lt;PATH&gt;/ca.crt \
     -H "X-Project-Name: &lt;PROJECT-NAME&gt;" \
     -H "X-Project-Domain-Id: &lt;PROJECT-DOMAIN-ID&gt;" \
     -H "X-Subject-Token: &lt;TOKEN&gt;" \
     https://&lt;HOST&gt;:&lt;PORT&gt;/v3/auth/tokens | python -mjson.tool</screen>
    <section>
      <title>Details of the Options</title>
      <itemizedlist>
        <listitem>
          <para><literal>--cert</literal> - The client certificate that will be presented to Keystone.
                            The <literal>Issuer</literal> in the certificate along with the defined <literal>protocol</literal>
                            in <literal>keystone.conf</literal> will uniquely identify the mapping. The <literal>Subject</literal>
                            in the certificate will be mapped to the valid local user from the
                            identified mapping.</para>
        </listitem>
        <listitem>
          <para><literal>--key</literal> - The corresponding client private key.</para>
        </listitem>
        <listitem>
          <para><literal>--cacert</literal> - It can be the Apache server certificate or its issuer
                            (signer) certificate.</para>
        </listitem>
        <listitem>
          <para><literal>X-Project-Name</literal> - The project scope needs to be passed in the header.</para>
        </listitem>
        <listitem>
          <para><literal>X-Project-Domain-Id</literal> - Its the domain of project scope.</para>
        </listitem>
        <listitem>
          <para><literal>X-Subject-Token</literal> - The token to be validated.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
</section>
