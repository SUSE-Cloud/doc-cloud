<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Identity API protection with role-based access control (RBAC)</title>
  <para>Like most OpenStack projects, Identity supports the protection of its
            APIs by defining policy rules based on an RBAC approach. Identity stores
            a reference to a policy JSON file in the main Identity configuration
            file, <literal>/etc/keystone/keystone.conf</literal>. Typically this file is named
            <literal>policy.json</literal>, and contains the rules for which roles have access to
            certain actions in defined services.</para>
  <para>Each Identity API v3 call has a line in the policy file that dictates
            which level of governance of access applies.</para>
  <screen language="none">API_NAME: RULE_STATEMENT or MATCH_STATEMENT</screen>
  <para>Where:</para>
  <para><literal>RULE_STATEMENT</literal> can contain <literal>RULE_STATEMENT</literal> or
            <literal>MATCH_STATEMENT</literal>.</para>
  <para><literal>MATCH_STATEMENT</literal> is a set of identifiers that must match between the
            token provided by the caller of the API and the parameters or target
            entities of the API call in question. For example:</para>
  <screen language="none">"identity:create_user": "role:admin and domain_id:%(user.domain_id)s"</screen>
  <para>Indicates that to create a user, you must have the admin role in your
            token. The <literal>domain_id</literal> in your token must match the
            <literal>domain_id</literal> in the user object that you are trying
            to create, which implies this must be a domain-scoped token.
            In other words, you must have the admin role on the domain
            in which you are creating the user, and the token that you use
            must be scoped to that domain.</para>
  <para>Each component of a match statement uses this format:</para>
  <screen language="none">ATTRIB_FROM_TOKEN:CONSTANT or ATTRIB_RELATED_TO_API_CALL</screen>
  <para>The Identity service expects these attributes:</para>
  <para>Attributes from token:</para>
  <itemizedlist>
    <listitem>
      <para>
        <literal>user_id</literal>
      </para>
    </listitem>
    <listitem>
      <para>
        <literal>domain_id</literal>
      </para>
    </listitem>
    <listitem>
      <para>
        <literal>project_id</literal>
      </para>
    </listitem>
  </itemizedlist>
  <para>The <literal>project_id</literal> attribute requirement depends on the scope, and the
            list of roles you have within that scope.</para>
  <para>Attributes related to API call:</para>
  <itemizedlist>
    <listitem>
      <para>
        <literal>user.domain_id</literal>
      </para>
    </listitem>
    <listitem>
      <para>Any parameters passed into the API call</para>
    </listitem>
    <listitem>
      <para>Any filters specified in the query string</para>
    </listitem>
  </itemizedlist>
  <para>You reference attributes of objects passed with an object.attribute
            syntax (such as, <literal>user.domain_id</literal>). The target objects of an API are
            also available using a target.object.attribute syntax. For instance:</para>
  <screen language="none">"identity:delete_user": "role:admin and domain_id:%(target.user.domain_id)s"</screen>
  <para>would ensure that Identity only deletes the user object in the same
            domain as the provided token.</para>
  <para>Every target object has an <literal>id</literal> and a <literal>name</literal> available as
            <literal>target.OBJECT.id</literal> and <literal>target.OBJECT.name</literal>. Identity retrieves
            other attributes from the database, and the attributes vary between
            object types. The Identity service filters out some database fields,
            such as user passwords.</para>
  <para>List of object attributes:</para>
  <screen language="yaml">role:
     target.role.id
     target.role.name

user:
     target.user.default_project_id
     target.user.description
     target.user.domain_id
     target.user.enabled
     target.user.id
     target.user.name

group:
     target.group.description
     target.group.domain_id
     target.group.id
     target.group.name

domain:
     target.domain.enabled
     target.domain.id
     target.domain.name

project:
     target.project.description
     target.project.domain_id
     target.project.enabled
     target.project.id
     target.project.name</screen>
  <para>The default <literal>policy.json</literal> file supplied provides a somewhat
            basic example of API protection, and does not assume any particular
            use of domains. Refer to <literal>policy.v3cloudsample.json</literal> as an
            example of multi-domain configuration installations where a cloud
            provider wants to delegate administration of the contents of a domain
            to a particular <literal>admin domain</literal>. This example policy file also
            shows the use of an <literal>admin_domain</literal> to allow a cloud provider to
            enable administrators to have wider access across the APIs.</para>
  <para>A clean installation could start with the standard policy file, to
            allow creation of the <literal>admin_domain</literal> with the first users within
            it. You could then obtain the <literal>domain_id</literal> of the admin domain,
            paste the ID into a modified version of
            <literal>policy.v3cloudsample.json</literal>, and then enable it as the main
            <literal>policy file</literal>.</para>
</section>
