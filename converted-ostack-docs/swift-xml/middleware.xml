<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:id="common-middleware">
  <title>Middleware</title>
  <section>
    <title>Account Quotas</title>
    <para><literal>account_quotas</literal> is a middleware which blocks write requests (PUT, POST) if a
                given account quota (in bytes) is exceeded while DELETE requests are still
                allowed.</para>
    <para><literal>account_quotas</literal> uses the <literal>x-account-meta-quota-bytes</literal> metadata entry to
                store the quota. Write requests to this metadata entry are only permitted for
                resellers. There is no quota limit if <literal>x-account-meta-quota-bytes</literal> is not
                set.</para>
    <para>The <literal>account_quotas</literal> middleware should be added to the pipeline in your
                <literal>/etc/swift/proxy-server.conf</literal> file just after any auth middleware.
                For example:</para>
    <screen>[pipeline:main]
pipeline = catch_errors cache tempauth account_quotas proxy-server

[filter:account_quotas]
use = egg:swift#account_quotas</screen>
    <para>To set the quota on an account:</para>
    <screen><?dbsuse-fo font-size="8pt"?>swift -A http://127.0.0.1:8080/auth/v1.0 -U account:reseller -K secret post -m quota-bytes:10000</screen>
    <para>Remove the quota:</para>
    <screen><?dbsuse-fo font-size="8pt"?>swift -A http://127.0.0.1:8080/auth/v1.0 -U account:reseller -K secret post -m quota-bytes:</screen>
    <para>The same limitations apply for the account quotas as for the container quotas.</para>
    <para>For example, when uploading an object without a content-length header the proxy
                server doesn’t know the final size of the currently uploaded object and the
                upload will be allowed if the current account size is within the quota.
                Due to the eventual consistency further uploads might be possible until the
                account size has been updated.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.account_quotas.AccountQuotaMiddleware">
        <term>
          <literal>swift.common.middleware.account_quotas.AccountQuotaMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Account quota middleware</para>
          <para>See above for a full description.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.account_quotas.filter_factory">
        <term>
          <function>swift.common.middleware.account_quotas.filter_factory</function>
        </term>
        <listitem>
          <para>Returns a WSGI filter app for use with paste.deploy.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="bulk">
    <title>Bulk Operations (Delete and Archive Auto Extraction)</title>
    <para>Middleware that will perform many operations on a single request.</para>
    <section>
      <title>Extract Archive</title>
      <para>Expand tar files into a Swift account. Request must be a PUT with the
                    query parameter <literal>?extract-archive=format</literal> specifying the format of archive
                    file. Accepted formats are tar, tar.gz, and tar.bz2.</para>
      <para>For a PUT to the following url:</para>
      <screen>/v1/AUTH_Account/$UPLOAD_PATH?extract-archive=tar.gz</screen>
      <para>UPLOAD_PATH is where the files will be expanded to. UPLOAD_PATH can be a
                    container, a pseudo-directory within a container, or an empty string. The
                    destination of a file in the archive will be built as follows:</para>
      <screen>/v1/AUTH_Account/$UPLOAD_PATH/$FILE_PATH</screen>
      <para>Where FILE_PATH is the file name from the listing in the tar file.</para>
      <para>If the UPLOAD_PATH is an empty string, containers will be auto created
                    accordingly and files in the tar that would not map to any container (files
                    in the base directory) will be ignored.</para>
      <para>Only regular files will be uploaded. Empty directories, symlinks, etc will
                    not be uploaded.</para>
    </section>
    <section>
      <title>Content Type</title>
      <para>If the content-type header is set in the extract-archive call, Swift will
                    assign that content-type to all the underlying files. The bulk middleware
                    will extract the archive file and send the internal files using PUT
                    operations using the same headers from the original request
                    (e.g. auth-tokens, content-Type, etc.). Notice that any middleware call
                    that follows the bulk middleware does not know if this was a bulk request
                    or if these were individual requests sent by the user.</para>
      <para>In order to make Swift detect the content-type for the files based on the
                    file extension, the content-type in the extract-archive call should not be
                    set. Alternatively, it is possible to explicitly tell Swift to detect the
                    content type using this header:</para>
      <screen>X-Detect-Content-Type: true</screen>
      <para>For example:</para>
      <screen>curl -X PUT http://127.0.0.1/v1/AUTH_acc/cont/$?extract-archive=tar
 -T backup.tar
 -H "Content-Type: application/x-tar"
 -H "X-Auth-Token: xxx"
 -H "X-Detect-Content-Type: true"</screen>
    </section>
    <section>
      <title>Assigning Metadata</title>
      <para>The tar file format (1) allows for UTF-8 key/value pairs to be associated
                    with each file in an archive. If a file has extended attributes, then tar
                    will store those as key/value pairs. The bulk middleware can read those
                    extended attributes and convert them to Swift object metadata. Attributes
                    starting with “user.meta” are converted to object metadata, and
                    “user.mime_type” is converted to Content-Type.</para>
      <para>For example:</para>
      <screen>setfattr -n user.mime_type -v "application/python-setup" setup.py
setfattr -n user.meta.lunch -v "burger and fries" setup.py
setfattr -n user.meta.dinner -v "baked ziti" setup.py
setfattr -n user.stuff -v "whee" setup.py</screen>
      <para>Will get translated to headers:</para>
      <screen>Content-Type: application/python-setup
X-Object-Meta-Lunch: burger and fries
X-Object-Meta-Dinner: baked ziti</screen>
      <para>The bulk middleware  will handle xattrs stored by both GNU and BSD tar (2).
                    Only xattrs <literal>user.mime_type</literal> and <literal>user.meta.*</literal> are processed. Other
                    attributes are ignored.</para>
      <para>Notes:</para>
      <para>(1) The POSIX 1003.1-2001 (pax) format. The default format on GNU tar
                    1.27.1 or later.</para>
      <para>(2) Even with pax-format tarballs, different encoders store xattrs slightly
                    differently; for example, GNU tar stores the xattr “user.userattribute” as
                    pax header “SCHILY.xattr.user.userattribute”, while BSD tar (which uses
                    libarchive) stores it as “LIBARCHIVE.xattr.user.userattribute”.</para>
    </section>
    <section>
      <title>Response</title>
      <para>The response from bulk operations functions differently from other Swift
                    responses. This is because a short request body sent from the client could
                    result in many operations on the proxy server and precautions need to be
                    made to prevent the request from timing out due to lack of activity. To
                    this end, the client will always receive a 200 OK response, regardless of
                    the actual success of the call.  The body of the response must be parsed to
                    determine the actual success of the operation. In addition to this the
                    client may receive zero or more whitespace characters prepended to the
                    actual response body while the proxy server is completing the request.</para>
      <para>The format of the response body defaults to text/plain but can be either
                    json or xml depending on the <literal>Accept</literal> header. Acceptable formats are
                    <literal>text/plain</literal>, <literal>application/json</literal>, <literal>application/xml</literal>, and <literal>text/xml</literal>.
                    An example body is as follows:</para>
      <screen>{"Response Status": "201 Created",
 "Response Body": "",
 "Errors": [],
 "Number Files Created": 10}</screen>
      <para>If all valid files were uploaded successfully the Response Status will be
                    201 Created.  If any files failed to be created the response code
                    corresponds to the subrequest’s error. Possible codes are 400, 401, 502 (on
                    server errors), etc. In both cases the response body will specify the
                    number of files successfully uploaded and a list of the files that failed.</para>
      <para>There are proxy logs created for each file (which becomes a subrequest) in
                    the tar. The subrequest’s proxy log will have a swift.source set to “EA”
                    the log’s content length will reflect the unzipped size of the file. If
                    double proxy-logging is used the leftmost logger will not have a
                    swift.source set and the content length will reflect the size of the
                    payload sent to the proxy (the unexpanded size of the tar.gz).</para>
    </section>
    <section>
      <title>Bulk Delete</title>
      <para>Will delete multiple objects or containers from their account with a
                    single request. Responds to POST requests with query parameter
                    <literal>?bulk-delete</literal> set. The request url is your storage url. The Content-Type
                    should be set to <literal>text/plain</literal>. The body of the POST request will be a
                    newline separated list of url encoded objects to delete. You can delete
                    10,000 (configurable) objects per request. The objects specified in the
                    POST request body must be URL encoded and in the form:</para>
      <screen>/container_name/obj_name</screen>
      <para>or for a container (which must be empty at time of delete):</para>
      <screen>/container_name</screen>
      <para>The response is similar to extract archive as in every response will be a
                    200 OK and you must parse the response body for actual results. An example
                    response is:</para>
      <screen>{"Number Not Found": 0,
 "Response Status": "200 OK",
 "Response Body": "",
 "Errors": [],
 "Number Deleted": 6}</screen>
      <para>If all items were successfully deleted (or did not exist), the Response
                    Status will be 200 OK. If any failed to delete, the response code
                    corresponds to the subrequest’s error. Possible codes are 400, 401, 502 (on
                    server errors), etc. In all cases the response body will specify the number
                    of items successfully deleted, not found, and a list of those that failed.
                    The return body will be formatted in the way specified in the request’s
                    <literal>Accept</literal> header. Acceptable formats are <literal>text/plain</literal>, <literal>application/json</literal>,
                    <literal>application/xml</literal>, and <literal>text/xml</literal>.</para>
      <para>There are proxy logs created for each object or container (which becomes a
                    subrequest) that is deleted. The subrequest’s proxy log will have a
                    swift.source set to “BD” the log’s content length of 0. If double
                    proxy-logging is used the leftmost logger will not have a
                    swift.source set and the content length will reflect the size of the
                    payload sent to the proxy (the list of objects/containers to be deleted).</para>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.bulk.CreateContainerError">
          <term>
            <literal>swift.common.middleware.bulk.CreateContainerError</literal>
          </term>
          <listitem>
            <para>Bases: <literal>Exception</literal></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.bulk.get_response_body">
          <term>
            <function>swift.common.middleware.bulk.get_response_body</function>
          </term>
          <listitem>
            <para>Returns a properly formatted response body according to format. Handles
                            json and xml, otherwise will return text/plain. Note: xml response does not
                            include xml declaration.
                            :params data_format: resulting format
                            :params data_dict: generated data about results.
                            :params error_list: list of quoted filenames that failed</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section xml:id="catch-errors">
    <title>CatchErrors</title>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.catch_errors.CatchErrorMiddleware">
        <term>
          <literal>swift.common.middleware.catch_errors.CatchErrorMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Middleware that provides high-level error handling and ensures that a
                        transaction id will be set for every request.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.catch_errors.CatchErrorsContext">
        <term>
          <literal>swift.common.middleware.catch_errors.CatchErrorsContext</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.wsgi.WSGIContext"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>CNAME Lookup</title>
    <para>CNAME Lookup Middleware</para>
    <para>Middleware that translates an unknown domain in the host header to
                something that ends with the configured storage_domain by looking up
                the given domain’s CNAME record in DNS.</para>
    <para>This middleware will continue to follow a CNAME chain in DNS until it finds
                a record ending in the configured storage domain or it reaches the configured
                maximum lookup depth. If a match is found, the environment’s Host header is
                rewritten and the request is passed further down the WSGI chain.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.cname_lookup.CNAMELookupMiddleware">
        <term>
          <literal>swift.common.middleware.cname_lookup.CNAMELookupMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>CNAME Lookup Middleware</para>
          <para>See above for a full description.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.cname_lookup.lookup_cname">
        <term>
          <function>swift.common.middleware.cname_lookup.lookup_cname</function>
        </term>
        <listitem>
          <para>Given a domain, returns its DNS CNAME mapping and DNS ttl.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="container-quotas">
    <title>Container Quotas</title>
    <para>The <literal>container_quotas</literal> middleware implements simple quotas that can be
                imposed on swift containers by a user with the ability to set container
                metadata, most likely the account administrator.  This can be useful for
                limiting the scope of containers that are delegated to non-admin users, exposed
                to <literal>formpost</literal> uploads, or just as a self-imposed sanity check.</para>
    <para>Any object PUT operations that exceed these quotas return a 413 response
                (request entity too large) with a descriptive body.</para>
    <para>Quotas are subject to several limitations: eventual consistency, the timeliness
                of the cached container_info (60 second ttl by default), and it’s unable to
                reject chunked transfer uploads that exceed the quota (though once the quota
                is exceeded, new chunked transfers will be refused).</para>
    <para>Quotas are set by adding meta values to the container, and are validated when
                set:</para>
    <informaltable>
      <tgroup cols="2">
        <colspec colname="c1" colwidth="59.2*"/>
        <colspec colname="c2" colwidth="40.8*"/>
        <thead>
          <row>
            <entry>
              <para>Metadata</para>
            </entry>
            <entry>
              <para>Use</para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>X-Container-Meta-Quota-Bytes</para>
            </entry>
            <entry>
              <para>Maximum size of the
                                    container, in bytes.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>X-Container-Meta-Quota-Count</para>
            </entry>
            <entry>
              <para>Maximum object count of the
                                    container.</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>The <literal>container_quotas</literal> middleware should be added to the pipeline in your
                <literal>/etc/swift/proxy-server.conf</literal> file just after any auth middleware.
                For example:</para>
    <screen>[pipeline:main]
pipeline = catch_errors cache tempauth container_quotas proxy-server

[filter:container_quotas]
use = egg:swift#container_quotas</screen>
  </section>
  <section xml:id="container-sync">
    <title>Container Sync Middleware</title>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.container_sync.ContainerSync">
        <term>
          <literal>swift.common.middleware.container_sync.ContainerSync</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>WSGI middleware that validates an incoming container sync request
                        using the container-sync-realms.conf style of container sync.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Cross Domain Policies</title>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crossdomain.CrossDomainMiddleware">
        <term>
          <literal>swift.common.middleware.crossdomain.CrossDomainMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Cross domain middleware used to respond to requests for cross domain
                        policy information.</para>
          <para>If the path is /crossdomain.xml it will respond with an xml cross domain
                        policy document. This allows web pages hosted elsewhere to use client
                        side technologies such as Flash, Java and Silverlight to interact
                        with the Swift API.</para>
          <para>To enable this middleware, add it to the pipeline in your proxy-server.conf
                        file. It should be added before any authentication (e.g., tempauth or
                        keystone) middleware. In this example ellipsis (…) indicate other
                        middleware you may have chosen to use:</para>
          <screen>[pipeline:main]
pipeline =  ... crossdomain ... authtoken ... proxy-server</screen>
          <para>And add a filter section, such as:</para>
          <screen>[filter:crossdomain]
use = egg:swift#crossdomain
cross_domain_policy = &lt;allow-access-from domain="*.example.com" /&gt;
    &lt;allow-access-from domain="www.example.com" secure="false" /&gt;</screen>
          <para>For continuation lines, put some whitespace before the continuation
                        text. Ensure you put a completely blank line to terminate the
                        cross_domain_policy value.</para>
          <para>The cross_domain_policy name/value is optional. If omitted, the policy
                        defaults as if you had specified:</para>
          <screen>cross_domain_policy = &lt;allow-access-from domain="*" secure="false" /&gt;</screen>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crossdomain.CrossDomainMiddleware.GET">
              <term>
                <property>swift.common.middleware.crossdomain.CrossDomainMiddleware.GET</property>
              </term>
              <listitem>
                <para>Returns a 200 response with cross domain policy information</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="discoverability">
    <title>Discoverability</title>
    <para>Swift will by default provide clients with an interface providing details
                about the installation. Unless disabled (i.e <literal>expose_info=false</literal> in
                <xref linkend="proxy-server-config"/>), a GET request to <literal>/info</literal> will return configuration
                data in JSON format.  An example response:</para>
    <screen>{"swift": {"version": "1.11.0"}, "staticweb": {}, "tempurl": {}}</screen>
    <para>This would signify to the client that swift version 1.11.0 is running and that
                staticweb and tempurl are available in this installation.</para>
    <para>There may be administrator-only information available via <literal>/info</literal>. To
                retrieve it, one must use an HMAC-signed request, similar to TempURL.
                The signature may be produced like so:</para>
    <screen>swift tempurl GET 3600 /info secret 2&gt;/dev/null | sed s/temp_url/swiftinfo/g</screen>
  </section>
  <section>
    <title>Domain Remap</title>
    <para>Domain Remap Middleware</para>
    <para>Middleware that translates container and account parts of a domain to
                path parameters that the proxy server understands.</para>
    <para>container.account.storageurl/object gets translated to
                container.account.storageurl/path_root/account/container/object</para>
    <para>account.storageurl/path_root/container/object gets translated to
                account.storageurl/path_root/account/container/object</para>
    <para>Browsers can convert a host header to lowercase, so check that reseller
                prefix on the account is the correct case. This is done by comparing the
                items in the reseller_prefixes config option to the found prefix. If they
                match except for case, the item from reseller_prefixes will be used
                instead of the found reseller prefix. When none match, the default reseller
                prefix is used. When no default reseller prefix is configured, any request with
                an account prefix not in that list will be ignored by this middleware.
                reseller_prefixes defaults to ‘AUTH’.</para>
    <para>Note that this middleware requires that container names and account names
                (except as described above) must be DNS-compatible. This means that the
                account name created in the system and the containers created by users
                cannot exceed 63 characters or have UTF-8 characters. These are
                restrictions over and above what swift requires and are not explicitly
                checked. Simply put, the this middleware will do a best-effort attempt to
                derive account and container names from elements in the domain name and
                put those derived values into the URL path (leaving the Host header
                unchanged).</para>
    <para>Also note that using container sync with remapped domain names is not
                advised. With container sync, you should use the true storage end points as
                sync destinations.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.domain_remap.DomainRemapMiddleware">
        <term>
          <literal>swift.common.middleware.domain_remap.DomainRemapMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Domain Remap Middleware</para>
          <para>See above for a full description.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="dynamic-large-objects">
    <title>Dynamic Large Objects</title>
    <para>DLO support centers around a user specified filter that matches
                segments and concatenates them together in object listing order. Please see
                the DLO docs for <xref linkend="dlo-doc"/> further details.</para>
  </section>
  <section xml:id="encryption">
    <title>Encryption</title>
    <para>Encryption middleware should be deployed in conjunction with the
                <xref linkend="keymaster"/> middleware.</para>
    <para>Implements middleware for object encryption which comprises an instance of a
                <xref linkend="swift.common.middleware.crypto.decrypter.Decrypter"/> combined with an
                instance of an <xref linkend="swift.common.middleware.crypto.encrypter.Encrypter"/>.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.filter_factory">
        <term>
          <function>swift.common.middleware.crypto.filter_factory</function>
        </term>
        <listitem>
          <para>Provides a factory function for loading encryption middleware.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.encrypter.EncInputWrapper">
        <term>
          <literal>swift.common.middleware.crypto.encrypter.EncInputWrapper</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>File-like object to be swapped in for wsgi.input.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.encrypter.Encrypter">
        <term>
          <literal>swift.common.middleware.crypto.encrypter.Encrypter</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Middleware for encrypting data and user metadata.</para>
          <para>By default all PUT or POST’ed object data and/or metadata will be
                        encrypted. Encryption of new data and/or metadata may be disabled by
                        setting the <literal>disable_encryption</literal> option to True. However, this middleware
                        should remain in the pipeline in order for existing encrypted data to be
                        read.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.encrypter.EncrypterObjContext">
        <term>
          <literal>swift.common.middleware.crypto.encrypter.EncrypterObjContext</literal>
        </term>
        <listitem>
          <para>Bases: <literal>swift.common.middleware.crypto.crypto_utils.CryptoWSGIContext</literal></para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.encrypter.EncrypterObjContext.encrypt_user_metadata">
              <term>
                <property>swift.common.middleware.crypto.encrypter.EncrypterObjContext.encrypt_user_metadata</property>
              </term>
              <listitem>
                <para>Encrypt user-metadata header values. Replace each x-object-meta-&lt;key&gt;
                                user metadata header with a corresponding
                                x-object-transient-sysmeta-crypto-meta-&lt;key&gt; header which has the
                                crypto metadata required to decrypt appended to the encrypted value.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.encrypter.EncrypterObjContext.handle_post">
              <term>
                <property>swift.common.middleware.crypto.encrypter.EncrypterObjContext.handle_post</property>
              </term>
              <listitem>
                <para>Encrypt the new object headers with a new iv and the current crypto.
                                Note that an object may have encrypted headers while the body may
                                remain unencrypted.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.encrypter.encrypt_header_val">
        <term>
          <function>swift.common.middleware.crypto.encrypter.encrypt_header_val</function>
        </term>
        <listitem>
          <para>Encrypt a header value using the supplied key.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.decrypter.BaseDecrypterContext">
        <term>
          <literal>swift.common.middleware.crypto.decrypter.BaseDecrypterContext</literal>
        </term>
        <listitem>
          <para>Bases: <literal>swift.common.middleware.crypto.crypto_utils.CryptoWSGIContext</literal></para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.BaseDecrypterContext.decrypt_value">
              <term>
                <property>swift.common.middleware.crypto.decrypter.BaseDecrypterContext.decrypt_value</property>
              </term>
              <listitem>
                <para>Base64-decode and decrypt a value using the crypto_meta provided.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.BaseDecrypterContext.decrypt_value_with_meta">
              <term>
                <property>swift.common.middleware.crypto.decrypter.BaseDecrypterContext.decrypt_value_with_meta</property>
              </term>
              <listitem>
                <para>Base64-decode and decrypt a value if crypto meta can be extracted from
                                the value itself, otherwise return the value unmodified.</para>
                <para>A value should either be a string that does not contain the ‘;’
                                character or should be of the form:</para>
                <para>&lt;base64-encoded ciphertext&gt;;swift_meta=&lt;crypto meta&gt;</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.BaseDecrypterContext.get_crypto_meta">
              <term>
                <property>swift.common.middleware.crypto.decrypter.BaseDecrypterContext.get_crypto_meta</property>
              </term>
              <listitem>
                <para>Extract a crypto_meta dict from a header.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.BaseDecrypterContext.get_decryption_keys">
              <term>
                <property>swift.common.middleware.crypto.decrypter.BaseDecrypterContext.get_decryption_keys</property>
              </term>
              <listitem>
                <para>Determine if a response should be decrypted, and if so then fetch keys.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.BaseDecrypterContext.get_unwrapped_key">
              <term>
                <property>swift.common.middleware.crypto.decrypter.BaseDecrypterContext.get_unwrapped_key</property>
              </term>
              <listitem>
                <para>Get a wrapped key from crypto-meta and unwrap it using the provided
                                wrapping key.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.decrypter.Decrypter">
        <term>
          <literal>swift.common.middleware.crypto.decrypter.Decrypter</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Middleware for decrypting data and user metadata.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.decrypter.DecrypterContContext">
        <term>
          <literal>swift.common.middleware.crypto.decrypter.DecrypterContContext</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.middleware.crypto.decrypter.BaseDecrypterContext"/></para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.DecrypterContContext.process_json_resp">
              <term>
                <property>swift.common.middleware.crypto.decrypter.DecrypterContContext.process_json_resp</property>
              </term>
              <listitem>
                <para>Parses json body listing and decrypt encrypted entries. Updates
                                Content-Length header with new body length and return a body iter.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.DecrypterContContext.process_xml_resp">
              <term>
                <property>swift.common.middleware.crypto.decrypter.DecrypterContContext.process_xml_resp</property>
              </term>
              <listitem>
                <para>Parses xml body listing and decrypt encrypted entries. Updates
                                Content-Length header with new body length and return a body iter.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.decrypter.DecrypterObjContext">
        <term>
          <literal>swift.common.middleware.crypto.decrypter.DecrypterObjContext</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.middleware.crypto.decrypter.BaseDecrypterContext"/></para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.DecrypterObjContext.decrypt_resp_headers">
              <term>
                <property>swift.common.middleware.crypto.decrypter.DecrypterObjContext.decrypt_resp_headers</property>
              </term>
              <listitem>
                <para>Find encrypted headers and replace with the decrypted versions.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.DecrypterObjContext.multipart_response_iter">
              <term>
                <property>swift.common.middleware.crypto.decrypter.DecrypterObjContext.multipart_response_iter</property>
              </term>
              <listitem>
                <para>Decrypts a multipart mime doc response body.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.decrypter.DecrypterObjContext.response_iter">
              <term>
                <property>swift.common.middleware.crypto.decrypter.DecrypterObjContext.response_iter</property>
              </term>
              <listitem>
                <para>Decrypts a response body.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="formpost">
    <title>FormPost</title>
    <para>FormPost Middleware</para>
    <para>Translates a browser form post into a regular Swift object PUT.</para>
    <para>The format of the form is:</para>
    <screen>&lt;form action="&lt;swift-url&gt;" method="POST"
      enctype="multipart/form-data"&gt;
  &lt;input type="hidden" name="redirect" value="&lt;redirect-url&gt;" /&gt;
  &lt;input type="hidden" name="max_file_size" value="&lt;bytes&gt;" /&gt;
  &lt;input type="hidden" name="max_file_count" value="&lt;count&gt;" /&gt;
  &lt;input type="hidden" name="expires" value="&lt;unix-timestamp&gt;" /&gt;
  &lt;input type="hidden" name="signature" value="&lt;hmac&gt;" /&gt;
  &lt;input type="file" name="file1" /&gt;&lt;br /&gt;
  &lt;input type="submit" /&gt;
&lt;/form&gt;</screen>
    <para>Optionally, if you want the uploaded files to be temporary you can set
                x-delete-at or x-delete-after attributes by adding one of these as a
                form input:</para>
    <screen>&lt;input type="hidden" name="x_delete_at" value="&lt;unix-timestamp&gt;" /&gt;
&lt;input type="hidden" name="x_delete_after" value="&lt;seconds&gt;" /&gt;</screen>
    <para>The &lt;swift-url&gt; is the URL of the Swift destination, such as:</para>
    <screen>https://swift-cluster.example.com/v1/AUTH_account/container/object_prefix</screen>
    <para>The name of each file uploaded will be appended to the &lt;swift-url&gt;
                given. So, you can upload directly to the root of container with a
                url like:</para>
    <screen>https://swift-cluster.example.com/v1/AUTH_account/container/</screen>
    <para>Optionally, you can include an object prefix to better separate
                different users’ uploads, such as:</para>
    <screen>https://swift-cluster.example.com/v1/AUTH_account/container/object_prefix</screen>
    <para>Note the form method must be POST and the enctype must be set as
                “multipart/form-data”.</para>
    <para>The redirect attribute is the URL to redirect the browser to after the upload
                completes. This is an optional parameter. If you are uploading the form via an
                XMLHttpRequest the redirect should not be included. The URL will have status
                and message query parameters added to it, indicating the HTTP status code for
                the upload (2xx is success) and a possible message for further information if
                there was an error (such as “max_file_size exceeded”).</para>
    <para>The max_file_size attribute must be included and indicates the
                largest single file upload that can be done, in bytes.</para>
    <para>The max_file_count attribute must be included and indicates the
                maximum number of files that can be uploaded with the form. Include
                additional <literal>&lt;input type="file" name="filexx" /&gt;</literal> attributes if
                desired.</para>
    <para>The expires attribute is the Unix timestamp before which the form
                must be submitted before it is invalidated.</para>
    <para>The signature attribute is the HMAC-SHA1 signature of the form. Here is
                sample code for computing the signature:</para>
    <screen>import hmac
from hashlib import sha1
from time import time
path = '/v1/account/container/object_prefix'
redirect = 'https://srv.com/some-page'  # set to '' if redirect not in form
max_file_size = 104857600
max_file_count = 10
expires = int(time() + 600)
key = 'mykey'
hmac_body = '%s\n%s\n%s\n%s\n%s' % (path, redirect,
    max_file_size, max_file_count, expires)
signature = hmac.new(key, hmac_body, sha1).hexdigest()</screen>
    <para>The key is the value of either the account (X-Account-Meta-Temp-URL-Key,
                X-Account-Meta-Temp-Url-Key-2) or the container
                (X-Container-Meta-Temp-URL-Key, X-Container-Meta-Temp-Url-Key-2) TempURL keys.</para>
    <para>Be certain to use the full path, from the /v1/ onward.
                Note that x_delete_at and x_delete_after are not used in signature generation
                as they are both optional attributes.</para>
    <para>The command line tool <literal>swift-form-signature</literal> may be used (mostly
                just when testing) to compute expires and signature.</para>
    <para>Also note that the file attributes must be after the other attributes
                in order to be processed correctly. If attributes come after the
                file, they won’t be sent with the subrequest (there is no way to
                parse all the attributes on the server-side without reading the whole
                thing into memory – to service many requests, some with large files,
                there just isn’t enough memory on the server, so attributes following
                the file are simply ignored).</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.formpost.FormPost">
        <term>
          <literal>swift.common.middleware.formpost.FormPost</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>FormPost Middleware</para>
          <para>See above for a full description.</para>
          <para>The proxy logs created for any subrequests made will have swift.source set
                        to “FP”.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.formpost.FormPost.app">
              <term>
                <property>swift.common.middleware.formpost.FormPost.app</property>
              </term>
              <listitem>
                <para>The next WSGI application/filter in the paste.deploy pipeline.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.formpost.FormPost.conf">
              <term>
                <property>swift.common.middleware.formpost.FormPost.conf</property>
              </term>
              <listitem>
                <para>The filter configuration dict.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.formpost.filter_factory">
        <term>
          <function>swift.common.middleware.formpost.filter_factory</function>
        </term>
        <listitem>
          <para>Returns the WSGI filter for use with paste.deploy.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.formpost.READ_CHUNK_SIZE">
        <term>
          <literal>swift.common.middleware.formpost.READ_CHUNK_SIZE</literal>
        </term>
        <listitem>
          <para>The size of data to read from the form at any given time.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.formpost.MAX_VALUE_LENGTH">
        <term>
          <literal>swift.common.middleware.formpost.MAX_VALUE_LENGTH</literal>
        </term>
        <listitem>
          <para>The maximum size of any attribute’s value. Any additional data will be
                        truncated.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="gatekeeper">
    <title>GateKeeper</title>
    <para>The <literal>gatekeeper</literal> middleware imposes restrictions on the headers that
                may be included with requests and responses. Request headers are filtered
                to remove headers that should never be generated by a client. Similarly,
                response headers are filtered to remove private headers that should
                never be passed to a client.</para>
    <para>The <literal>gatekeeper</literal> middleware must always be present in the proxy server
                wsgi pipeline. It should be configured close to the start of the pipeline
                specified in <literal>/etc/swift/proxy-server.conf</literal>, immediately after catch_errors
                and before any other middleware. It is essential that it is configured ahead
                of all middlewares using system metadata in order that they function
                correctly.</para>
    <para>If <literal>gatekeeper</literal> middleware is not configured in the pipeline then it will be
                automatically inserted close to the start of the pipeline by the proxy server.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.gatekeeper.outbound_exclusions">
        <term>
          <literal>swift.common.middleware.gatekeeper.outbound_exclusions</literal>
        </term>
        <listitem>
          <para>A list of python regular expressions that will be used to
                        match against outbound response headers. Matching headers will
                        be removed from the response.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="healthcheck">
    <title>Healthcheck</title>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.healthcheck.HealthCheckMiddleware">
        <term>
          <literal>swift.common.middleware.healthcheck.HealthCheckMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Healthcheck middleware used for monitoring.</para>
          <para>If the path is /healthcheck, it will respond 200 with “OK” as the body.</para>
          <para>If the optional config parameter “disable_path” is set, and a file is
                        present at that path, it will respond 503 with “DISABLED BY FILE” as the
                        body.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.healthcheck.HealthCheckMiddleware.DISABLED">
              <term>
                <property>swift.common.middleware.healthcheck.HealthCheckMiddleware.DISABLED</property>
              </term>
              <listitem>
                <para>Returns a 503 response with “DISABLED BY FILE” in the body.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.healthcheck.HealthCheckMiddleware.GET">
              <term>
                <property>swift.common.middleware.healthcheck.HealthCheckMiddleware.GET</property>
              </term>
              <listitem>
                <para>Returns a 200 response with “OK” in the body.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="keymaster">
    <title>Keymaster</title>
    <para>Keymaster middleware should be deployed in conjunction with the
                <xref linkend="encryption"/> middleware.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.keymaster.KeyMaster">
        <term>
          <literal>swift.common.middleware.crypto.keymaster.KeyMaster</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Middleware for providing encryption keys.</para>
          <para>The middleware requires its <literal>encryption_root_secret</literal> option to be set.
                        This is the root secret from which encryption keys are derived. This must
                        be set before first use to a value that is a base64 encoding of at least 32
                        bytes. The security of all encrypted data critically depends on this key,
                        therefore it should be set to a high-entropy value. For example, a suitable
                        value may be obtained by base-64 encoding a 32 byte (or longer) value
                        generated by a cryptographically secure random number generator. Changing
                        the root secret is likely to result in data loss.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.crypto.keymaster.KeyMasterContext">
        <term>
          <literal>swift.common.middleware.crypto.keymaster.KeyMasterContext</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.wsgi.WSGIContext"/></para>
          <para>The simple scheme for key derivation is as follows: every path is
                        associated with a key, where the key is derived from the path itself in a
                        deterministic fashion such that the key does not need to be stored.
                        Specifically, the key for any path is an HMAC of a root key and the path
                        itself, calculated using an SHA256 hash function:</para>
          <screen>&lt;path_key&gt; = HMAC_SHA256(&lt;root_secret&gt;, &lt;path&gt;)</screen>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.crypto.keymaster.KeyMasterContext.fetch_crypto_keys">
              <term>
                <property>swift.common.middleware.crypto.keymaster.KeyMasterContext.fetch_crypto_keys</property>
              </term>
              <listitem>
                <para>Setup container and object keys based on the request path.</para>
                <para>Keys are derived from request path. The ‘id’ entry in the results dict
                                includes the part of the path used to derive keys. Other keymaster
                                implementations may use a different strategy to generate keys and may
                                include a different type of ‘id’, so callers should treat the ‘id’ as
                                opaque keymaster-specific data.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="keystoneauth">
    <title>KeystoneAuth</title>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.keystoneauth.KeystoneAuth">
        <term>
          <literal>swift.common.middleware.keystoneauth.KeystoneAuth</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Swift middleware to Keystone authorization system.</para>
          <para>In Swift’s proxy-server.conf add this keystoneauth middleware and the
                        authtoken middleware to your pipeline. Make sure you have the authtoken
                        middleware before the keystoneauth middleware.</para>
          <para>The authtoken middleware will take care of validating the user and
                        keystoneauth will authorize access.</para>
          <para>The sample proxy-server.conf shows a sample pipeline that uses keystone.</para>
          <para/>
          <para>The authtoken middleware is shipped with keystonemiddleware - it
                        does not have any other dependencies than itself so you can either
                        install it by copying the file directly in your python path or by
                        installing keystonemiddleware.</para>
          <para>If support is required for unvalidated users (as with anonymous
                        access) or for formpost/staticweb/tempurl middleware, authtoken will
                        need to be configured with <literal>delay_auth_decision</literal> set to true.  See
                        the Keystone documentation for more detail on how to configure the
                        authtoken middleware.</para>
          <para>In proxy-server.conf you will need to have the setting account
                        auto creation to true:</para>
          <screen>[app:proxy-server]
account_autocreate = true</screen>
          <para>And add a swift authorization filter section, such as:</para>
          <screen>[filter:keystoneauth]
use = egg:swift#keystoneauth
operator_roles = admin, swiftoperator</screen>
          <para>The user who is able to give ACL / create Containers permissions
                        will be the user with a role listed in the <literal>operator_roles</literal>
                        setting which by default includes the admin and the swiftoperator
                        roles.</para>
          <para>The keystoneauth middleware maps a Keystone project/tenant to an account
                        in Swift by adding a prefix (<literal>AUTH_</literal> by default) to the tenant/project
                        id.. For example, if the project id is <literal>1234</literal>, the path is
                        <literal>/v1/AUTH_1234</literal>.</para>
          <para>If you need to have a different reseller_prefix to be able to
                        mix different auth servers you can configure the option
                        <literal>reseller_prefix</literal> in your keystoneauth entry like this:</para>
          <screen>reseller_prefix = NEWAUTH</screen>
          <para>Don’t forget to also update the Keystone service endpoint configuration to
                        use NEWAUTH in the path.</para>
          <para>It is possible to have several accounts associated with the same project.
                        This is done by listing several prefixes as shown in the following
                        example:</para>
          <para>reseller_prefix = AUTH, SERVICE</para>
          <para>This means that for project id ‘1234’, the paths ‘/v1/AUTH_1234’ and
                        ‘/v1/SERVICE_1234’ are associated with the project and are authorized
                        using roles that a user has with that project. The core use of this feature
                        is that it is possible to provide different rules for each account
                        prefix. The following parameters may be prefixed with the appropriate
                        prefix:</para>
          <para>operator_roles
                            service_roles</para>
          <para>For backward compatibility, if either of these parameters is specified
                        without a prefix then it applies to all reseller_prefixes. Here is an
                        example, using two prefixes:</para>
          <screen>reseller_prefix = AUTH, SERVICE
# The next three lines have identical effects (since the first applies
# to both prefixes).
operator_roles = admin, swiftoperator
AUTH_operator_roles = admin, swiftoperator
SERVICE_operator_roles = admin, swiftoperator
# The next line only applies to accounts with the SERVICE prefix
SERVICE_operator_roles = admin, some_other_role</screen>
          <para>X-Service-Token tokens are supported by the inclusion of the service_roles
                        configuration option. When present, this option requires that the
                        X-Service-Token header supply a token from a user who has a role listed
                        in service_roles. Here is an example configuration:</para>
          <screen>reseller_prefix = AUTH, SERVICE
AUTH_operator_roles = admin, swiftoperator
SERVICE_operator_roles = admin, swiftoperator
SERVICE_service_roles = service</screen>
          <para>The keystoneauth middleware supports cross-tenant access control using the
                        syntax <literal>&lt;tenant&gt;:&lt;user&gt;</literal> to specify a grantee in container Access Control
                        Lists (ACLs). For a request to be granted by an ACL, the grantee
                        <literal>&lt;tenant&gt;</literal> must match the UUID of the tenant to which the request
                        X-Auth-Token is scoped and the grantee <literal>&lt;user&gt;</literal> must match the UUID of
                        the user authenticated by that token.</para>
          <para>Note that names must no longer be used in cross-tenant ACLs because with
                        the introduction of domains in keystone names are no longer globally
                        unique.</para>
          <para>For backwards compatibility, ACLs using names will be granted by
                        keystoneauth when it can be established that the grantee tenant,
                        the grantee user and the tenant being accessed are either not yet in a
                        domain (e.g. the X-Auth-Token has been obtained via the keystone v2
                        API) or are all in the default domain to which legacy accounts would
                        have been migrated. The default domain is identified by its UUID,
                        which by default has the value <literal>default</literal>. This can be changed by
                        setting the <literal>default_domain_id</literal> option in the keystoneauth
                        configuration:</para>
          <screen>default_domain_id = default</screen>
          <para>The backwards compatible behavior can be disabled by setting the config
                        option <literal>allow_names_in_acls</literal> to false:</para>
          <screen>allow_names_in_acls = false</screen>
          <para>To enable this backwards compatibility, keystoneauth will attempt to
                        determine the domain id of a tenant when any new account is created,
                        and persist this as account metadata. If an account is created for a tenant
                        using a token with reselleradmin role that is not scoped on that tenant,
                        keystoneauth is unable to determine the domain id of the tenant;
                        keystoneauth will assume that the tenant may not be in the default domain
                        and therefore not match names in ACLs for that account.</para>
          <para>By default, middleware higher in the WSGI pipeline may override auth
                        processing, useful for middleware such as tempurl and formpost. If you know
                        you’re not going to use such middleware and you want a bit of extra
                        security you can disable this behaviour by setting the <literal>allow_overrides</literal>
                        option to <literal>false</literal>:</para>
          <screen>allow_overrides = false</screen>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.keystoneauth.KeystoneAuth.authorize_anonymous">
              <term>
                <property>swift.common.middleware.keystoneauth.KeystoneAuth.authorize_anonymous</property>
              </term>
              <listitem>
                <para>Authorize an anonymous request.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.keystoneauth.KeystoneAuth.denied_response">
              <term>
                <property>swift.common.middleware.keystoneauth.KeystoneAuth.denied_response</property>
              </term>
              <listitem>
                <para>Deny WSGI Response.</para>
                <para>Returns a standard WSGI response callable with the status of 403 or 401
                                depending on whether the REMOTE_USER is set or not.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.keystoneauth.filter_factory">
        <term>
          <function>swift.common.middleware.keystoneauth.filter_factory</function>
        </term>
        <listitem>
          <para>Returns a WSGI filter app for use with paste.deploy.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="list-endpoints">
    <title>List Endpoints</title>
    <para>List endpoints for an object, account or container.</para>
    <para>This middleware makes it possible to integrate swift with software
                that relies on data locality information to avoid network overhead,
                such as Hadoop.</para>
    <para>Using the original API, answers requests of the form:</para>
    <screen>/endpoints/{account}/{container}/{object}
/endpoints/{account}/{container}
/endpoints/{account}
/endpoints/v1/{account}/{container}/{object}
/endpoints/v1/{account}/{container}
/endpoints/v1/{account}</screen>
    <para>with a JSON-encoded list of endpoints of the form:</para>
    <screen>http://{server}:{port}/{dev}/{part}/{acc}/{cont}/{obj}
http://{server}:{port}/{dev}/{part}/{acc}/{cont}
http://{server}:{port}/{dev}/{part}/{acc}</screen>
    <para>correspondingly, e.g.:</para>
    <screen>http://10.1.1.1:6200/sda1/2/a/c2/o1
http://10.1.1.1:6200/sda1/2/a/c2
http://10.1.1.1:6200/sda1/2/a</screen>
    <para>Using the v2 API, answers requests of the form:</para>
    <screen>/endpoints/v2/{account}/{container}/{object}
/endpoints/v2/{account}/{container}
/endpoints/v2/{account}</screen>
    <para>with a JSON-encoded dictionary containing a key ‘endpoints’ that maps to a list
                of endpoints having the same form as described above, and a key ‘headers’ that
                maps to a dictionary of headers that should be sent with a request made to
                the endpoints, e.g.:</para>
    <screen>{ "endpoints": {"http://10.1.1.1:6010/sda1/2/a/c3/o1",
                "http://10.1.1.1:6030/sda3/2/a/c3/o1",
                "http://10.1.1.1:6040/sda4/2/a/c3/o1"},
  "headers": {"X-Backend-Storage-Policy-Index": "1"}}</screen>
    <para>In this example, the ‘headers’ dictionary indicates that requests to the
                endpoint URLs should include the header ‘X-Backend-Storage-Policy-Index: 1’
                because the object’s container is using storage policy index 1.</para>
    <para>The ‘/endpoints/’ path is customizable (‘list_endpoints_path’
                configuration parameter).</para>
    <para>Intended for consumption by third-party services living inside the
                cluster (as the endpoints make sense only inside the cluster behind
                the firewall); potentially written in a different language.</para>
    <para>This is why it’s provided as a REST API and not just a Python API:
                to avoid requiring clients to write their own ring parsers in their
                languages, and to avoid the necessity to distribute the ring file
                to clients and keep it up-to-date.</para>
    <para>Note that the call is not authenticated, which means that a proxy
                with this middleware enabled should not be open to an untrusted
                environment (everyone can query the locality data using this middleware).</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.list_endpoints.ListEndpointsMiddleware">
        <term>
          <literal>swift.common.middleware.list_endpoints.ListEndpointsMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>List endpoints for an object, account or container.</para>
          <para>See above for a full description.</para>
          <para>Uses configuration parameter <literal>swift_dir</literal> (default <literal>/etc/swift</literal>).</para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.list_endpoints.ListEndpointsMiddleware.get_object_ring">
              <term>
                <property>swift.common.middleware.list_endpoints.ListEndpointsMiddleware.get_object_ring</property>
              </term>
              <listitem>
                <para>Get the ring object to use to handle a request based on its policy.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Memcache</title>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.memcache.MemcacheMiddleware">
        <term>
          <literal>swift.common.middleware.memcache.MemcacheMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Caching middleware that manages caching in swift.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Name Check (Forbidden Character Filter)</title>
    <para>Created on February 27, 2012</para>
    <para>A filter that disallows any paths that contain defined forbidden characters or
                that exceed a defined length.</para>
    <para>Place early in the proxy-server pipeline after the left-most occurrence of the
                <literal>proxy-logging</literal> middleware (if present) and before the final
                <literal>proxy-logging</literal> middleware (if present) or the <literal>proxy-serer</literal> app itself,
                e.g.:</para>
    <screen><?dbsuse-fo font-size="8pt"?>[pipeline:main]
pipeline = catch_errors healthcheck proxy-logging name_check cache ratelimit tempauth sos proxy-logging proxy-server

[filter:name_check]
use = egg:swift#name_check
forbidden_chars = '"`&lt;&gt;
maximum_length = 255</screen>
    <para>There are default settings for forbidden_chars (FORBIDDEN_CHARS) and
                maximum_length (MAX_LENGTH)</para>
    <para>The filter returns HTTPBadRequest if path is invalid.</para>
    <para>@author: eamonn-otoole</para>
  </section>
  <section xml:id="versioned-writes">
    <title>Object Versioning</title>
    <para>Object versioning in swift is implemented by setting a flag on the container
                to tell swift to version all objects in the container. The value of the flag is
                the container where the versions are stored (commonly referred to as the
                “archive container”). The flag itself is one of two headers, which determines
                how object <literal>DELETE</literal> requests are handled:</para>
    <itemizedlist>
      <listitem>
        <para>
          <literal>X-History-Location</literal>
        </para>
        <para>On <literal>DELETE</literal>, copy the current version of the object to the archive
                            container, write a zero-byte “delete marker” object that notes when the
                            delete took place, and delete the object from the versioned container. The
                            object will no longer appear in container listings for the versioned
                            container and future requests there will return <literal>404 Not Found</literal>. However,
                            the content will still be recoverable from the archive container.</para>
      </listitem>
      <listitem>
        <para>
          <literal>X-Versions-Location</literal>
        </para>
        <para>On <literal>DELETE</literal>, only remove the current version of the object. If any
                            previous versions exist in the archive container, the most recent one is
                            copied over the current version, and the copy in the archive container is
                            deleted. As a result, if you have 5 total versions of the object, you must
                            delete the object 5 times for that object name to start responding with
                            <literal>404 Not Found</literal>.</para>
      </listitem>
    </itemizedlist>
    <para>Either header may be used for the various containers within an account, but
                only one may be set for any given container. Attempting to set both
                simulataneously will result in a <literal>400 Bad Request</literal> response.</para>
    <note>
      <para>It is recommended to use a different archive container for
                    each container that is being versioned.</para>
    </note>
    <note>
      <para>Enabling versioning on an archive container is not recommended.</para>
    </note>
    <para>When data is <literal>PUT</literal> into a versioned container (a container with the
                versioning flag turned on), the existing data in the file is redirected to a
                new object in the archive container and the data in the <literal>PUT</literal> request is
                saved as the data for the versioned object. The new object name (for the
                previous version) is <literal>&lt;archive_container&gt;/&lt;length&gt;&lt;object_name&gt;/&lt;timestamp&gt;</literal>,
                where <literal>length</literal> is the 3-character zero-padded hexadecimal length of the
                <literal>&lt;object_name&gt;</literal> and <literal>&lt;timestamp&gt;</literal> is the timestamp of when the previous
                version was created.</para>
    <para>A <literal>GET</literal> to a versioned object will return the current version of the object
                without having to do any request redirects or metadata lookups.</para>
    <para>A <literal>POST</literal> to a versioned object will update the object metadata as normal,
                but will not create a new version of the object. In other words, new versions
                are only created when the content of the object changes.</para>
    <para>A <literal>DELETE</literal> to a versioned object will be handled in one of two ways,
                as described above.</para>
    <para>To restore a previous version of an object, find the desired version in the
                archive container then issue a <literal>COPY</literal> with a <literal>Destination</literal> header
                indicating the original location. This will archive the current version similar
                to a <literal>PUT</literal> over the versioned object. If the client additionally wishes to
                permanently delete what was the current version, it must find the newly-created
                archive in the archive container and issue a separate <literal>DELETE</literal> to it.</para>
    <section>
      <title>How to Enable Object Versioning in a Swift Cluster</title>
      <para>This middleware was written as an effort to refactor parts of the proxy server,
                    so this functionality was already available in previous releases and every
                    attempt was made to maintain backwards compatibility. To allow operators to
                    perform a seamless upgrade, it is not required to add the middleware to the
                    proxy pipeline and the flag <literal>allow_versions</literal> in the container server
                    configuration files are still valid, but only when using
                    <literal>X-Versions-Location</literal>. In future releases, <literal>allow_versions</literal> will be
                    deprecated in favor of adding this middleware to the pipeline to enable or
                    disable the feature.</para>
      <para>In case the middleware is added to the proxy pipeline, you must also
                    set <literal>allow_versioned_writes</literal> to <literal>True</literal> in the middleware options
                    to enable the information about this middleware to be returned in a /info
                    request.</para>
      <note>
        <para>You need to add the middleware to the proxy pipeline and set
                            <literal>allow_versioned_writes = True</literal> to use <literal>X-History-Location</literal>. Setting
                            <literal>allow_versions = True</literal> in the container server is not sufficient to
                            enable the use of <literal>X-History-Location</literal>.</para>
      </note>
      <section>
        <title>Upgrade considerations:</title>
        <para>If <literal>allow_versioned_writes</literal> is set in the filter configuration, you can leave
                        the <literal>allow_versions</literal> flag in the container server configuration files
                        untouched. If you decide to disable or remove the <literal>allow_versions</literal> flag, you
                        must re-set any existing containers that had the <literal>X-Versions-Location</literal> flag
                        configured so that it can now be tracked by the versioned_writes middleware.</para>
        <para>Clients should not use the <literal>X-History-Location</literal> header until all proxies in
                        the cluster have been upgraded to a version of Swift that supports it.
                        Attempting to use <literal>X-History-Location</literal> during a rolling upgrade may result
                        in some requests being served by proxies running old code, leading to data
                        loss.</para>
      </section>
    </section>
    <section>
      <title>Examples Using <literal>curl</literal> with <literal>X-Versions-Location</literal></title>
      <para>First, create a container with the <literal>X-Versions-Location</literal> header or add the
                    header to an existing container. Also make sure the container referenced by
                    the <literal>X-Versions-Location</literal> exists. In this example, the name of that
                    container is “versions”:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XPUT -H "X-Auth-Token: &lt;token&gt;" -H "X-Versions-Location: versions" http://&lt;storage_url&gt;/container
curl -i -XPUT -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/versions</screen>
      <para>Create an object (the first version):</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XPUT --data-binary 1 -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/container/myobject</screen>
      <para>Now create a new version of that object:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XPUT --data-binary 2 -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/container/myobject</screen>
      <para>See a listing of the older versions of the object:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/versions?prefix=008myobject/</screen>
      <para>Now delete the current version of the object and see that the older version is
                    gone from ‘versions’ container and back in ‘container’ container:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XDELETE -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/container/myobject
curl -i -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/versions?prefix=008myobject/
curl -i -XGET -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/container/myobject</screen>
    </section>
    <section>
      <title>Examples Using <literal>curl</literal> with <literal>X-History-Location</literal></title>
      <para>As above, create a container with the <literal>X-History-Location</literal> header and ensure
                    that the container referenced by the <literal>X-History-Location</literal> exists. In this
                    example, the name of that container is “versions”:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XPUT -H "X-Auth-Token: &lt;token&gt;" -H "X-History-Location: versions" http://&lt;storage_url&gt;/container
curl -i -XPUT -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/versions</screen>
      <para>Create an object (the first version):</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XPUT --data-binary 1 -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/container/myobject</screen>
      <para>Now create a new version of that object:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XPUT --data-binary 2 -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/container/myobject</screen>
      <para>Now delete the current version of the object. Subsequent requests will 404:</para>
      <screen>curl -i -XDELETE -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/container/myobject
curl -i -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/container/myobject</screen>
      <para>A listing of the older versions of the object will include both the first and
                    second versions of the object, as well as a “delete marker” object:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/versions?prefix=008myobject/</screen>
      <para>To restore a previous version, simply <literal>COPY</literal> it from the archive container:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XCOPY -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/versions/008myobject/&lt;timestamp&gt; -H "Destination: container/myobject"</screen>
      <para>Note that the archive container still has all previous versions of the object,
                    including the source for the restore:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/versions?prefix=008myobject/</screen>
      <para>To permanently delete a previous version, <literal>DELETE</literal> it from the archive
                    container:</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XDELETE -H "X-Auth-Token: &lt;token&gt;" http://&lt;storage_url&gt;/versions/008myobject/&lt;timestamp&gt;</screen>
    </section>
    <section>
      <title>How to Disable Object Versioning in a Swift Cluster</title>
      <para>If you want to disable all functionality, set <literal>allow_versioned_writes</literal> to
                    <literal>False</literal> in the middleware options.</para>
      <para>Disable versioning from a container (x is any value except empty):</para>
      <screen><?dbsuse-fo font-size="8pt"?>curl -i -XPOST -H "X-Auth-Token: &lt;token&gt;" -H "X-Remove-Versions-Location: x" http://&lt;storage_url&gt;/container</screen>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.versioned_writes.VersionedWritesContext">
          <term>
            <literal>swift.common.middleware.versioned_writes.VersionedWritesContext</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.common.wsgi.WSGIContext"/></para>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.versioned_writes.VersionedWritesContext.handle_obj_versions_delete_pop">
                <term>
                  <property>swift.common.middleware.versioned_writes.VersionedWritesContext.handle_obj_versions_delete_pop</property>
                </term>
                <listitem>
                  <para>Handle DELETE requests when in stack mode.</para>
                  <para>Delete current version of object and pop previous version in its place.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.versioned_writes.VersionedWritesContext.handle_obj_versions_delete_push">
                <term>
                  <property>swift.common.middleware.versioned_writes.VersionedWritesContext.handle_obj_versions_delete_push</property>
                </term>
                <listitem>
                  <para>Handle DELETE requests when in history mode.</para>
                  <para>Copy current version of object to versions_container and write a
                                    delete marker before proceeding with original request.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.versioned_writes.VersionedWritesContext.handle_obj_versions_put">
                <term>
                  <property>swift.common.middleware.versioned_writes.VersionedWritesContext.handle_obj_versions_put</property>
                </term>
                <listitem>
                  <para>Copy current version of object to versions_container before proceeding
                                    with original request.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.versioned_writes.check_container_format">
          <term>
            <function>swift.common.middleware.versioned_writes.check_container_format</function>
          </term>
          <listitem>
            <para>Validate that the header contains valid account or container name.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section>
    <title>Proxy Logging</title>
    <para>Logging middleware for the Swift proxy.</para>
    <para>This serves as both the default logging implementation and an example of how
                to plug in your own logging format/method.</para>
    <para>The logging format implemented below is as follows:</para>
    <variablelist>
      <varlistentry>
        <term>client_ip remote_addr datetime request_method request_path protocol</term>
        <listitem>
          <para>status_int referer user_agent auth_token bytes_recvd bytes_sent
                            client_etag transaction_id headers request_time source log_info
                            request_start_time request_end_time</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>These values are space-separated, and each is url-encoded, so that they can
                be separated with a simple .split()</para>
    <itemizedlist>
      <listitem>
        <para>remote_addr is the contents of the REMOTE_ADDR environment variable, while
                        client_ip is swift’s best guess at the end-user IP, extracted variously
                        from the X-Forwarded-For header, X-Cluster-Ip header, or the REMOTE_ADDR
                        environment variable.</para>
      </listitem>
      <listitem>
        <para>source (swift.source in the WSGI environment) indicates the code
                        that generated the request, such as most middleware. (See below for
                        more detail.)</para>
      </listitem>
      <listitem>
        <para>log_info (swift.log_info in the WSGI environment) is for additional
                        information that could prove quite useful, such as any x-delete-at
                        value or other “behind the scenes” activity that might not
                        otherwise be detectable from the plain log information. Code that
                        wishes to add additional log information should use code like
                        <literal>env.setdefault('swift.log_info', []).append(your_info)</literal> so as to
                        not disturb others’ log information.</para>
      </listitem>
      <listitem>
        <para>Values that are missing (e.g. due to a header not being present) or zero
                        are generally represented by a single hyphen (‘-‘).</para>
      </listitem>
    </itemizedlist>
    <para>The proxy-logging can be used twice in the proxy server’s pipeline when there
                is middleware installed that can return custom responses that don’t follow the
                standard pipeline to the proxy server.</para>
    <para>For example, with staticweb, the middleware might intercept a request to
                /v1/AUTH_acc/cont/, make a subrequest to the proxy to retrieve
                /v1/AUTH_acc/cont/index.html and, in effect, respond to the client’s original
                request using the 2nd request’s body. In this instance the subrequest will be
                logged by the rightmost middleware (with a swift.source set) and the outgoing
                request (with body overridden) will be logged by leftmost middleware.</para>
    <para>Requests that follow the normal pipeline (use the same wsgi environment
                throughout) will not be double logged because an environment variable
                (swift.proxy_access_log_made) is checked/set when a log is made.</para>
    <para>All middleware making subrequests should take care to set swift.source when
                needed. With the doubled proxy logs, any consumer/processor of swift’s proxy
                logs should look at the swift.source field, the rightmost log value, to decide
                if this is a middleware subrequest or not. A log processor calculating
                bandwidth usage will want to only sum up logs with no swift.source.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.proxy_logging.ProxyLoggingMiddleware">
        <term>
          <literal>swift.common.middleware.proxy_logging.ProxyLoggingMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Middleware that logs Swift proxy requests in the swift log format.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.proxy_logging.ProxyLoggingMiddleware.log_request">
              <term>
                <property>swift.common.middleware.proxy_logging.ProxyLoggingMiddleware.log_request</property>
              </term>
              <listitem>
                <para>Log a request.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="ratelimit">
    <title>Ratelimit</title>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.ratelimit.MaxSleepTimeHitError">
        <term>
          <literal>swift.common.middleware.ratelimit.MaxSleepTimeHitError</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.ratelimit.RateLimitMiddleware">
        <term>
          <literal>swift.common.middleware.ratelimit.RateLimitMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Rate limiting middleware</para>
          <para>Rate limits requests on both an Account and Container level.  Limits are
                        configurable.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.ratelimit.RateLimitMiddleware.get_ratelimitable_key_tuples">
              <term>
                <property>swift.common.middleware.ratelimit.RateLimitMiddleware.get_ratelimitable_key_tuples</property>
              </term>
              <listitem>
                <para>Returns a list of key (used in memcache), ratelimit tuples. Keys
                                should be checked in order.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.ratelimit.RateLimitMiddleware.handle_ratelimit">
              <term>
                <property>swift.common.middleware.ratelimit.RateLimitMiddleware.handle_ratelimit</property>
              </term>
              <listitem>
                <para>Performs rate limiting and account white/black listing.  Sleeps
                                if necessary. If self.memcache_client is not set, immediately returns
                                None.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.ratelimit.filter_factory">
        <term>
          <function>swift.common.middleware.ratelimit.filter_factory</function>
        </term>
        <listitem>
          <para>paste.deploy app factory for creating WSGI proxy apps.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.ratelimit.get_maxrate">
        <term>
          <function>swift.common.middleware.ratelimit.get_maxrate</function>
        </term>
        <listitem>
          <para>Returns number of requests allowed per second for given size.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.ratelimit.interpret_conf_limits">
        <term>
          <function>swift.common.middleware.ratelimit.interpret_conf_limits</function>
        </term>
        <listitem>
          <para>Parses general parms for rate limits looking for things that
                        start with the provided name_prefix within the provided conf
                        and returns lists for both internal use and for /info</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="recon">
    <title>Recon</title>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware">
        <term>
          <literal>swift.common.middleware.recon.ReconMiddleware</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Recon middleware used for monitoring.</para>
          <para>/recon/load|mem|async… will return various system metrics.</para>
          <para>Needs to be added to the pipeline and requires a filter
                        declaration in the object-server.conf:</para>
          <para>[filter:recon]
                        use = egg:swift#recon
                        recon_cache_path = /var/cache/swift</para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_async_info">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_async_info</property>
              </term>
              <listitem>
                <para>get # of async pendings</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_auditor_info">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_auditor_info</property>
              </term>
              <listitem>
                <para>get auditor info</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_device_info">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_device_info</property>
              </term>
              <listitem>
                <para>get devices</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_diskusage">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_diskusage</property>
              </term>
              <listitem>
                <para>get disk utilization statistics</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_driveaudit_error">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_driveaudit_error</property>
              </term>
              <listitem>
                <para>get # of drive audit errors</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_expirer_info">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_expirer_info</property>
              </term>
              <listitem>
                <para>get expirer info</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_load">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_load</property>
              </term>
              <listitem>
                <para>get info from /proc/loadavg</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_mem">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_mem</property>
              </term>
              <listitem>
                <para>get info from /proc/meminfo</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_mounted">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_mounted</property>
              </term>
              <listitem>
                <para>get ALL mounted fs from /proc/mounts</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_quarantine_count">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_quarantine_count</property>
              </term>
              <listitem>
                <para>get obj/container/account quarantine counts</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_replication_info">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_replication_info</property>
              </term>
              <listitem>
                <para>get replication info</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_ring_md5">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_ring_md5</property>
              </term>
              <listitem>
                <para>get all ring md5sum’s</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_socket_info">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_socket_info</property>
              </term>
              <listitem>
                <para>get info from /proc/net/sockstat and sockstat6</para>
                <para>Note: The mem value is actually kernel pages, but we return bytes
                                allocated based on the systems page size.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_swift_conf_md5">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_swift_conf_md5</property>
              </term>
              <listitem>
                <para>get md5 of swift.conf</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_time">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_time</property>
              </term>
              <listitem>
                <para>get current time</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_unmounted">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_unmounted</property>
              </term>
              <listitem>
                <para>list unmounted (failed?) devices</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_updater_info">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_updater_info</property>
              </term>
              <listitem>
                <para>get updater info</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.recon.ReconMiddleware.get_version">
              <term>
                <property>swift.common.middleware.recon.ReconMiddleware.get_version</property>
              </term>
              <listitem>
                <para>get swift version</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="copy">
    <title>Server Side Copy</title>
    <para>Server side copy is a feature that enables users/clients to COPY objects
                between accounts and containers without the need to download and then
                re-upload objects, thus eliminating additional bandwidth consumption and
                also saving time. This may be used when renaming/moving an object which
                in Swift is a (COPY + DELETE) operation.</para>
    <para>The server side copy middleware should be inserted in the pipeline after auth
                and before the quotas and large object middlewares. If it is not present in the
                pipeline in the proxy-server configuration file, it will be inserted
                automatically. There is no configurable option provided to turn off server
                side copy.</para>
    <section>
      <title>Metadata</title>
      <itemizedlist>
        <listitem>
          <para>All metadata of source object is preserved during object copy.</para>
        </listitem>
        <listitem>
          <para>One can also provide additional metadata during PUT/COPY request. This will
                            over-write any existing conflicting keys.</para>
        </listitem>
        <listitem>
          <para>Server side copy can also be used to change content-type of an existing
                            object.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Object Copy</title>
      <itemizedlist>
        <listitem>
          <para>The destination container must exist before requesting copy of the object.</para>
        </listitem>
        <listitem>
          <para>When several replicas exist, the system copies from the most recent replica.
                            That is, the copy operation behaves as though the X-Newest header is in the
                            request.</para>
        </listitem>
        <listitem>
          <para>The request to copy an object should have no body (i.e. content-length of the
                            request must be zero).</para>
        </listitem>
      </itemizedlist>
      <para>There are two ways in which an object can be copied:</para>
      <procedure>
        <step>
          <para>Send a PUT request to the new object (destination/target) with an additional
                            header named <literal>X-Copy-From</literal> specifying the source object
                            (in ‘/container/object’ format). Example:</para>
          <screen>curl -i -X PUT http://&lt;storage_url&gt;/container1/destination_obj
 -H 'X-Auth-Token: &lt;token&gt;'
 -H 'X-Copy-From: /container2/source_obj'
 -H 'Content-Length: 0'</screen>
        </step>
        <step>
          <para>Send a COPY request with an existing object in URL with an additional header
                            named <literal>Destination</literal> specifying the destination/target object
                            (in ‘/container/object’ format). Example:</para>
          <screen>curl -i -X COPY http://&lt;storage_url&gt;/container2/source_obj
 -H 'X-Auth-Token: &lt;token&gt;'
 -H 'Destination: /container1/destination_obj'
 -H 'Content-Length: 0'</screen>
        </step>
      </procedure>
      <para>Note that if the incoming request has some conditional headers (e.g. <literal>Range</literal>,
                    <literal>If-Match</literal>), the <emphasis>source</emphasis> object will be evaluated for these headers (i.e. if
                    PUT with both <literal>X-Copy-From</literal> and <literal>Range</literal>, Swift will make a partial copy to
                    the destination object).</para>
    </section>
    <section>
      <title>Cross Account Object Copy</title>
      <para>Objects can also be copied from one account to another account if the user
                    has the necessary permissions (i.e. permission to read from container
                    in source account and permission to write to container in destination account).</para>
      <para>Similar to examples mentioned above, there are two ways to copy objects across
                    accounts:</para>
      <procedure>
        <step>
          <para>Like the example above, send PUT request to copy object but with an
                            additional header named <literal>X-Copy-From-Account</literal> specifying the source
                            account. Example:</para>
          <screen>curl -i -X PUT http://&lt;host&gt;:&lt;port&gt;/v1/AUTH_test1/container/destination_obj
 -H 'X-Auth-Token: &lt;token&gt;'
 -H 'X-Copy-From: /container/source_obj'
 -H 'X-Copy-From-Account: AUTH_test2'
 -H 'Content-Length: 0'</screen>
        </step>
        <step>
          <para>Like the previous example, send a COPY request but with an additional header
                            named <literal>Destination-Account</literal> specifying the name of destination account.
                            Example:</para>
          <screen>curl -i -X COPY http://&lt;host&gt;:&lt;port&gt;/v1/AUTH_test2/container/source_obj
 -H 'X-Auth-Token: &lt;token&gt;'
 -H 'Destination: /container/destination_obj'
 -H 'Destination-Account: AUTH_test1'
 -H 'Content-Length: 0'</screen>
        </step>
      </procedure>
    </section>
    <section>
      <title>Large Object Copy</title>
      <para>The best option to copy a large object is to copy segments individually.
                    To copy the manifest object of a large object, add the query parameter to
                    the copy request:</para>
      <screen>?multipart-manifest=get</screen>
      <para>If a request is sent without the query parameter, an attempt will be made to
                    copy the whole object but will fail if the object size is
                    greater than 5GB.</para>
    </section>
    <section>
      <title>Object Post as Copy</title>
      <para>Historically, this has been a feature (and a configurable option with default
                    set to True) in proxy server configuration. This has been moved to server side
                    copy middleware and the default changed to False.</para>
      <para>When <literal>object_post_as_copy</literal> is set to <literal>true</literal>, an incoming POST request is
                    morphed into a COPY request where source and destination objects are same.</para>
      <para>This feature was necessary because of a previous behavior where POSTS would
                    update the metadata on the object but not on the container. As a result,
                    features like container sync would not work correctly. This is no longer the
                    case and this option is now deprecated. It will be removed in a future release.</para>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.copy.ServerSideCopyWebContext">
          <term>
            <literal>swift.common.middleware.copy.ServerSideCopyWebContext</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.common.wsgi.WSGIContext"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.copy.check_account_format">
          <term>
            <function>swift.common.middleware.copy.check_account_format</function>
          </term>
          <listitem>
            <para>Validate that the header contains valid account or container name.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section xml:id="static-large-objects">
    <title>Static Large Objects</title>
    <para>Please see
                the SLO docs for <xref linkend="slo-doc"/> further details.</para>
  </section>
  <section xml:id="staticweb">
    <title>StaticWeb</title>
    <para>This StaticWeb WSGI middleware will serve container data as a static web site
                with index file and error file resolution and optional file listings. This mode
                is normally only active for anonymous requests. When using keystone for
                authentication set <literal>delay_auth_decision = true</literal> in the authtoken middleware
                configuration in your <literal>/etc/swift/proxy-server.conf</literal> file.  If you want to
                use it with authenticated requests, set the <literal>X-Web-Mode: true</literal> header on the
                request.</para>
    <para>The <literal>staticweb</literal> filter should be added to the pipeline in your
                <literal>/etc/swift/proxy-server.conf</literal> file just after any auth middleware. Also, the
                configuration section for the <literal>staticweb</literal> middleware itself needs to be
                added. For example:</para>
    <screen>[DEFAULT]
...

[pipeline:main]
pipeline = catch_errors healthcheck proxy-logging cache ratelimit tempauth
           staticweb proxy-logging proxy-server

...

[filter:staticweb]
use = egg:swift#staticweb</screen>
    <para>Any publicly readable containers (for example, <literal>X-Container-Read: .r:*</literal>, see
                <xref linkend="acls"/> for more information on this) will be checked for
                X-Container-Meta-Web-Index and X-Container-Meta-Web-Error header values:</para>
    <screen>X-Container-Meta-Web-Index  &lt;index.name&gt;
X-Container-Meta-Web-Error  &lt;error.name.suffix&gt;</screen>
    <para>If X-Container-Meta-Web-Index is set, any &lt;index.name&gt; files will be served
                without having to specify the &lt;index.name&gt; part. For instance, setting
                <literal>X-Container-Meta-Web-Index: index.html</literal> will be able to serve the object
                …/pseudo/path/index.html with just …/pseudo/path or …/pseudo/path/</para>
    <para>If X-Container-Meta-Web-Error is set, any errors (currently just 401
                Unauthorized and 404 Not Found) will instead serve the
                …/&lt;status.code&gt;&lt;error.name.suffix&gt; object. For instance, setting
                <literal>X-Container-Meta-Web-Error: error.html</literal> will serve …/404error.html for
                requests for paths not found.</para>
    <para>For pseudo paths that have no &lt;index.name&gt;, this middleware can serve HTML file
                listings if you set the <literal>X-Container-Meta-Web-Listings: true</literal> metadata item
                on the container.</para>
    <para>If listings are enabled, the listings can have a custom style sheet by setting
                the X-Container-Meta-Web-Listings-CSS header. For instance, setting
                <literal>X-Container-Meta-Web-Listings-CSS: listing.css</literal> will make listings link to
                the …/listing.css style sheet. If you “view source” in your browser on a
                listing page, you will see the well defined document structure that can be
                styled.</para>
    <para>By default, the listings will be rendered with a label of
                “Listing of /v1/account/container/path”.  This can be altered by
                setting a <literal>X-Container-Meta-Web-Listings-Label: &lt;label&gt;</literal>.  For example,
                if the label is set to “example.com”, a label of
                “Listing of example.com/path” will be used instead.</para>
    <para>The content-type of directory marker objects can be modified by setting
                the <literal>X-Container-Meta-Web-Directory-Type</literal> header.  If the header is not set,
                application/directory is used by default.  Directory marker objects are
                0-byte objects that represent directories to create a simulated hierarchical
                structure.</para>
    <para>Example usage of this middleware via <literal>swift</literal>:</para>
    <para>Make the container publicly readable:</para>
    <screen>swift post -r '.r:*' container</screen>
    <para>You should be able to get objects directly, but no index.html resolution or
                    listings.</para>
    <para>Set an index file directive:</para>
    <screen>swift post -m 'web-index:index.html' container</screen>
    <para>You should be able to hit paths that have an index.html without needing to
                    type the index.html part.</para>
    <para>Turn on listings:</para>
    <screen>swift post -r '.r:*,.rlistings' container
swift post -m 'web-listings: true' container</screen>
    <para>Now you should see object listings for paths and pseudo paths that have no
                    index.html.</para>
    <para>Enable a custom listings style sheet:</para>
    <screen>swift post -m 'web-listings-css:listings.css' container</screen>
    <para>Set an error file:</para>
    <screen>swift post -m 'web-error:error.html' container</screen>
    <para>Now 401’s should load 401error.html, 404’s should load 404error.html, etc.</para>
    <para>Set Content-Type of directory marker object:</para>
    <screen>swift post -m 'web-directory-type:text/directory' container</screen>
    <para>Now 0-byte objects with a content-type of text/directory will be treated
                    as directories rather than objects.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.staticweb.StaticWeb">
        <term>
          <literal>swift.common.middleware.staticweb.StaticWeb</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>The Static Web WSGI middleware filter; serves container data as a static
                        web site. See <xref linkend="staticweb"/> for an overview.</para>
          <para>The proxy logs created for any subrequests made will have swift.source set
                        to “SW”.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.staticweb.StaticWeb.app">
              <term>
                <property>swift.common.middleware.staticweb.StaticWeb.app</property>
              </term>
              <listitem>
                <para>The next WSGI application/filter in the paste.deploy pipeline.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.middleware.staticweb.StaticWeb.conf">
              <term>
                <property>swift.common.middleware.staticweb.StaticWeb.conf</property>
              </term>
              <listitem>
                <para>The filter configuration dict. Only used in tests.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.staticweb.filter_factory">
        <term>
          <function>swift.common.middleware.staticweb.filter_factory</function>
        </term>
        <listitem>
          <para>Returns a Static Web WSGI filter for use with paste.deploy.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="common-tempauth">
    <title>TempAuth</title>
    <para>Test authentication and authorization system.</para>
    <para>Add to your pipeline in proxy-server.conf, such as:</para>
    <screen>[pipeline:main]
pipeline = catch_errors cache tempauth proxy-server</screen>
    <para>Set account auto creation to true in proxy-server.conf:</para>
    <screen>[app:proxy-server]
account_autocreate = true</screen>
    <para>And add a tempauth filter section, such as:</para>
    <screen>[filter:tempauth]
use = egg:swift#tempauth
user_admin_admin = admin .admin .reseller_admin
user_test_tester = testing .admin
user_test2_tester2 = testing2 .admin
user_test_tester3 = testing3
# To allow accounts/users with underscores you can base64 encode them.
# Here is the account "under_score" and username "a_b" (note the lack
# of padding equal signs):
user64_dW5kZXJfc2NvcmU_YV9i = testing4</screen>
    <para>See the proxy-server.conf-sample for more information.</para>
    <section>
      <title>Account/User List</title>
      <para>All accounts/users are listed in the filter section. The format is:</para>
      <screen>user_&lt;account&gt;_&lt;user&gt; = &lt;key&gt; [group] [group] [...] [storage_url]</screen>
      <para>If you want to be able to include underscores in the <literal>&lt;account&gt;</literal> or
                    <literal>&lt;user&gt;</literal> portions, you can base64 encode them (with <emphasis>no</emphasis> equal signs)
                    in a line like this:</para>
      <screen>user64_&lt;account_b64&gt;_&lt;user_b64&gt; = &lt;key&gt; [group] [...] [storage_url]</screen>
      <para>There are two special groups:</para>
      <itemizedlist>
        <listitem>
          <para><literal>.reseller_admin</literal> – can do anything to any account for this auth</para>
        </listitem>
        <listitem>
          <para><literal>.admin</literal> – can do anything within the account</para>
        </listitem>
      </itemizedlist>
      <para>If neither of these groups are specified, the user can only access
                    containers that have been explicitly allowed for them by a <literal>.admin</literal> or
                    <literal>.reseller_admin</literal>.</para>
      <para>The trailing optional <literal>storage_url</literal> allows you to specify an alternate
                    URL to hand back to the user upon authentication. If not specified, this
                    defaults to:</para>
      <screen>$HOST/v1/&lt;reseller_prefix&gt;_&lt;account&gt;</screen>
      <para>Where <literal>$HOST</literal> will do its best to resolve to what the requester would
                    need to use to reach this host, <literal>&lt;reseller_prefix&gt;</literal> is from this section,
                    and <literal>&lt;account&gt;</literal> is from the <literal>user_&lt;account&gt;_&lt;user&gt;</literal> name. Note that
                    <literal>$HOST</literal> cannot possibly handle when you have a load balancer in front of
                    it that does https while TempAuth itself runs with http; in such a case,
                    you’ll have to specify the  <literal>storage_url_scheme</literal> configuration value as
                    an override.</para>
    </section>
    <section>
      <title>Multiple Reseller Prefix Items</title>
      <para>The reseller prefix specifies which parts of the account namespace this
                    middleware is responsible for managing authentication and authorization.
                    By default, the prefix is ‘AUTH’ so accounts and tokens are prefixed
                    by ‘AUTH_’. When a request’s token and/or path start with ‘AUTH_’, this
                    middleware knows it is responsible.</para>
      <para>We allow the reseller prefix to be a list. In tempauth, the first item
                    in the list is used as the prefix for tokens and user groups. The
                    other prefixes provide alternate accounts that user’s can access. For
                    example if the reseller prefix list is ‘AUTH, OTHER’, a user with
                    admin access to ‘AUTH_account’ also has admin access to
                    ‘OTHER_account’.</para>
    </section>
    <section>
      <title>Required Group</title>
      <para>The group <literal>.admin</literal> is normally needed to access an account (ACLs provide
                    an additional way to access an account). You can specify the
                    <literal>require_group</literal> parameter. This means that you also need the named group
                    to access an account. If you have several reseller prefix items, prefix
                    the <literal>require_group</literal> parameter with the appropriate prefix.</para>
    </section>
    <section>
      <title>X-Service-Token</title>
      <para>If an <literal>X-Service-Token</literal> is presented in the request headers, the groups
                    derived from the token are appended to the roles derived from
                    <literal>X-Auth-Token</literal>. If <literal>X-Auth-Token</literal> is missing or invalid,
                    <literal>X-Service-Token</literal> is not processed.</para>
      <para>The <literal>X-Service-Token</literal> is useful when combined with multiple reseller
                    prefix items. In the following configuration, accounts prefixed
                    <literal>SERVICE\_</literal> are only accessible if <literal>X-Auth-Token</literal> is from the end-user
                    and <literal>X-Service-Token</literal> is from the <literal>glance</literal> user:</para>
      <screen>[filter:tempauth]
use = egg:swift#tempauth
reseller_prefix = AUTH, SERVICE
SERVICE_require_group = .service
user_admin_admin = admin .admin .reseller_admin
user_joeacct_joe = joepw .admin
user_maryacct_mary = marypw .admin
user_glance_glance = glancepw .service</screen>
      <para>The name <literal>.service</literal> is an example. Unlike <literal>.admin</literal> and
                    <literal>.reseller_admin</literal> it is not a reserved name.</para>
      <para>Please note that ACLs can be set on service accounts and are matched
                    against the identity validated by <literal>X-Auth-Token</literal>. As such ACLs can grant
                    access to a service account’s container without needing to provide a
                    service token, just like any other cross-reseller request using ACLs.</para>
    </section>
    <section xml:id="account-acls">
      <title>Account ACLs</title>
      <para>If a swift_owner issues a POST or PUT to the account with the
                    <literal>X-Account-Access-Control</literal> header set in the request, then this may
                    allow certain types of access for additional users.</para>
      <itemizedlist>
        <listitem>
          <para>Read-Only: Users with read-only access can list containers in the
                            account, list objects in any container, retrieve objects, and view
                            unprivileged account/container/object metadata.</para>
        </listitem>
        <listitem>
          <para>Read-Write: Users with read-write access can (in addition to the
                            read-only privileges) create objects, overwrite existing objects,
                            create new containers, and set unprivileged container/object
                            metadata.</para>
        </listitem>
        <listitem>
          <para>Admin: Users with admin access are swift_owners and can perform
                            any action, including viewing/setting privileged metadata (e.g.
                            changing account ACLs).</para>
        </listitem>
      </itemizedlist>
      <para>To generate headers for setting an account ACL:</para>
      <screen>from swift.common.middleware.acl import format_acl
acl_data = { 'admin': ['alice'], 'read-write': ['bob', 'carol'] }
header_value = format_acl(version=2, acl_dict=acl_data)</screen>
      <para>To generate a curl command line from the above:</para>
      <screen>token=...
storage_url=...
python -c '
  from swift.common.middleware.acl import format_acl
  acl_data = { 'admin': ['alice'], 'read-write': ['bob', 'carol'] }
  headers = {'X-Account-Access-Control':
             format_acl(version=2, acl_dict=acl_data)}
  header_str = ' '.join(["-H '%s: %s'" % (k, v)
                         for k, v in headers.items()])
  print('curl -D- -X POST -H "x-auth-token: $token" %s '
        '$storage_url' % header_str)
'</screen>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.tempauth.TempAuth">
          <term>
            <literal>swift.common.middleware.tempauth.TempAuth</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempauth.TempAuth.account_acls">
                <term>
                  <property>swift.common.middleware.tempauth.TempAuth.account_acls</property>
                </term>
                <listitem>
                  <para>Return a dict of ACL data from the account server via get_account_info.</para>
                  <para>Auth systems may define their own format, serialization, structure,
                                    and capabilities implemented in the ACL headers and persisted in the
                                    sysmeta data.  However, auth systems are strongly encouraged to be
                                    interoperable with Tempauth.</para>
                  <variablelist>
                    <varlistentry>
                      <term>Account ACLs are set and retrieved via the header</term>
                      <listitem>
                        <para>X-Account-Access-Control</para>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>For header format and syntax, see:</term>
                      <listitem>
                        <itemizedlist>
                          <listitem>
                            <para>
                              <xref linkend="swift.common.middleware.acl.parse_acl"/>
                            </para>
                          </listitem>
                          <listitem>
                            <para>
                              <xref linkend="swift.common.middleware.acl.format_acl"/>
                            </para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempauth.TempAuth.authorize">
                <term>
                  <property>swift.common.middleware.tempauth.TempAuth.authorize</property>
                </term>
                <listitem>
                  <para>Returns None if the request is authorized to continue or a standard
                                    WSGI response callable if not.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempauth.TempAuth.denied_response">
                <term>
                  <property>swift.common.middleware.tempauth.TempAuth.denied_response</property>
                </term>
                <listitem>
                  <para>Returns a standard WSGI response callable with the status of 403 or 401
                                    depending on whether the REMOTE_USER is set or not.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempauth.TempAuth.extract_acl_and_report_errors">
                <term>
                  <property>swift.common.middleware.tempauth.TempAuth.extract_acl_and_report_errors</property>
                </term>
                <listitem>
                  <para>Return a user-readable string indicating the errors in the input ACL,
                                    or None if there are no errors.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempauth.TempAuth.get_groups">
                <term>
                  <property>swift.common.middleware.tempauth.TempAuth.get_groups</property>
                </term>
                <listitem>
                  <para>Get groups for the given token.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempauth.TempAuth.handle">
                <term>
                  <property>swift.common.middleware.tempauth.TempAuth.handle</property>
                </term>
                <listitem>
                  <para>WSGI entry point for auth requests (ones that match the
                                    self.auth_prefix).
                                    Wraps env in swob.Request object and passes it down.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempauth.TempAuth.handle_get_token">
                <term>
                  <property>swift.common.middleware.tempauth.TempAuth.handle_get_token</property>
                </term>
                <listitem>
                  <para>Handles the various <literal>request for token and service end point(s)</literal> calls.
                                    There are various formats to support the various auth servers in the
                                    past. Examples:</para>
                  <screen>GET &lt;auth-prefix&gt;/v1/&lt;act&gt;/auth
    X-Auth-User: &lt;act&gt;:&lt;usr&gt;  or  X-Storage-User: &lt;usr&gt;
    X-Auth-Key: &lt;key&gt;         or  X-Storage-Pass: &lt;key&gt;
GET &lt;auth-prefix&gt;/auth
    X-Auth-User: &lt;act&gt;:&lt;usr&gt;  or  X-Storage-User: &lt;act&gt;:&lt;usr&gt;
    X-Auth-Key: &lt;key&gt;         or  X-Storage-Pass: &lt;key&gt;
GET &lt;auth-prefix&gt;/v1.0
    X-Auth-User: &lt;act&gt;:&lt;usr&gt;  or  X-Storage-User: &lt;act&gt;:&lt;usr&gt;
    X-Auth-Key: &lt;key&gt;         or  X-Storage-Pass: &lt;key&gt;</screen>
                  <para>On successful authentication, the response will have X-Auth-Token and
                                    X-Storage-Token set to the token to use with Swift and X-Storage-URL
                                    set to the URL to the default Swift cluster to use.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempauth.TempAuth.handle_request">
                <term>
                  <property>swift.common.middleware.tempauth.TempAuth.handle_request</property>
                </term>
                <listitem>
                  <para>Entry point for auth requests (ones that match the self.auth_prefix).
                                    Should return a WSGI-style callable (such as swob.Response).</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.tempauth.filter_factory">
          <term>
            <function>swift.common.middleware.tempauth.filter_factory</function>
          </term>
          <listitem>
            <para>Returns a WSGI filter app for use with paste.deploy.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section xml:id="tempurl">
    <title>TempURL</title>
    <para>TempURL Middleware</para>
    <para>Allows the creation of URLs to provide temporary access to objects.</para>
    <para>For example, a website may wish to provide a link to download a large
                object in Swift, but the Swift account has no public access. The
                website can generate a URL that will provide GET access for a limited
                time to the resource. When the web browser user clicks on the link,
                the browser will download the object directly from Swift, obviating
                the need for the website to act as a proxy for the request.</para>
    <para>If the user were to share the link with all his friends, or
                accidentally post it on a forum, etc. the direct access would be
                limited to the expiration time set when the website created the link.</para>
    <para>Beyond that, the middleware provides the ability to create URLs, which
                contain signatures which are valid for all objects which share a
                common prefix. These prefix-based URLs are useful for sharing a set
                of objects.</para>
    <section>
      <title>Client Usage</title>
      <para>To create temporary URLs, first an <literal>X-Account-Meta-Temp-URL-Key</literal>
                    header must be set on the Swift account. Then, an HMAC-SHA1 (RFC 2104)
                    signature is generated using the HTTP method to allow (<literal>GET</literal>, <literal>PUT</literal>,
                    <literal>DELETE</literal>, etc.), the Unix timestamp the access should be allowed until,
                    the full path to the object, and the key set on the account.</para>
      <para>For example, here is code generating the signature for a <literal>GET</literal> for 60
                    seconds on <literal>/v1/AUTH_account/container/object</literal>:</para>
      <screen>import hmac
from hashlib import sha1
from time import time
method = 'GET'
expires = int(time() + 60)
path = '/v1/AUTH_account/container/object'
key = 'mykey'
hmac_body = '%s\n%s\n%s' % (method, expires, path)
sig = hmac.new(key, hmac_body, sha1).hexdigest()</screen>
      <para>Be certain to use the full path, from the <literal>/v1/</literal> onward.</para>
      <para>Let’s say <literal>sig</literal> ends up equaling
                    <literal>da39a3ee5e6b4b0d3255bfef95601890afd80709</literal> and <literal>expires</literal> ends up
                    <literal>1323479485</literal>. Then, for example, the website could provide a link to:</para>
      <screen>https://swift-cluster.example.com/v1/AUTH_account/container/object?
temp_url_sig=da39a3ee5e6b4b0d3255bfef95601890afd80709&amp;
temp_url_expires=1323479485</screen>
      <para>You may also use ISO 8601 UTC timestamps with the format
                    <literal>"%Y-%m-%dT%H:%M:%SZ"</literal> instead of UNIX timestamps in the URL
                    (but NOT in the code above for generating the signature!).
                    So, the latter URL could also be formulated as:</para>
      <para><link xlink:href="https://swift-cluster.example.com/v1/AUTH_account/container/object"/>?
                        temp_url_sig=da39a3ee5e6b4b0d3255bfef95601890afd80709&amp;
                        temp_url_expires=2011-12-10T01:11:25Z</para>
      <para>If a prefix-based signature with the prefix <literal>pre</literal> is desired, set path to:</para>
      <screen>path = 'prefix:/v1/AUTH_account/container/pre'</screen>
      <para>The generated signature would be valid for all objects starting
                    with <literal>pre</literal>. The middleware detects a prefix-based temporary URL by
                    a query parameter called <literal>temp_url_prefix</literal>. So, if <literal>sig</literal> and <literal>expires</literal>
                    would end up like above, following URL would be valid:</para>
      <screen>https://swift-cluster.example.com/v1/AUTH_account/container/pre/object?
temp_url_sig=da39a3ee5e6b4b0d3255bfef95601890afd80709&amp;
temp_url_expires=1323479485&amp;
temp_url_prefix=pre</screen>
      <para>Another valid URL:</para>
      <screen>https://swift-cluster.example.com/v1/AUTH_account/container/pre/
subfolder/another_object?
temp_url_sig=da39a3ee5e6b4b0d3255bfef95601890afd80709&amp;
temp_url_expires=1323479485&amp;
temp_url_prefix=pre</screen>
      <para>Any alteration of the resource path or query arguments of a temporary URL
                    would result in <literal>401 Unauthorized</literal>. Similarly, a <literal>PUT</literal> where <literal>GET</literal> was
                    the allowed method would be rejected with <literal>401 Unauthorized</literal>.
                    However, <literal>HEAD</literal> is allowed if <literal>GET</literal>, <literal>PUT</literal>, or <literal>POST</literal> is allowed.</para>
      <para>Using this in combination with browser form post translation
                    middleware could also allow direct-from-browser uploads to specific
                    locations in Swift.</para>
      <para>TempURL supports both account and container level keys.  Each allows up to two
                    keys to be set, allowing key rotation without invalidating all existing
                    temporary URLs.  Account keys are specified by <literal>X-Account-Meta-Temp-URL-Key</literal>
                    and <literal>X-Account-Meta-Temp-URL-Key-2</literal>, while container keys are specified by
                    <literal>X-Container-Meta-Temp-URL-Key</literal> and <literal>X-Container-Meta-Temp-URL-Key-2</literal>.
                    Signatures are checked against account and container keys, if
                    present.</para>
      <para>With <literal>GET</literal> TempURLs, a <literal>Content-Disposition</literal> header will be set on the
                    response so that browsers will interpret this as a file attachment to
                    be saved. The filename chosen is based on the object name, but you
                    can override this with a filename query parameter. Modifying the
                    above example:</para>
      <screen>https://swift-cluster.example.com/v1/AUTH_account/container/object?
temp_url_sig=da39a3ee5e6b4b0d3255bfef95601890afd80709&amp;
temp_url_expires=1323479485&amp;filename=My+Test+File.pdf</screen>
      <para>If you do not want the object to be downloaded, you can cause
                    <literal>Content-Disposition: inline</literal> to be set on the response by adding the
                    <literal>inline</literal> parameter to the query string, like so:</para>
      <screen>https://swift-cluster.example.com/v1/AUTH_account/container/object?
temp_url_sig=da39a3ee5e6b4b0d3255bfef95601890afd80709&amp;
temp_url_expires=1323479485&amp;inline</screen>
      <para>In some cases, the client might not able to present the content of the object,
                    but you still want the content able to save to local with the specific
                    filename. So you can cause <literal>Content-Disposition: inline; filename=...</literal> to be
                    set on the response by adding the <literal>inline&amp;filename=...</literal> parameter to the
                    query string, like so:</para>
      <screen>https://swift-cluster.example.com/v1/AUTH_account/container/object?
temp_url_sig=da39a3ee5e6b4b0d3255bfef95601890afd80709&amp;
temp_url_expires=1323479485&amp;inline&amp;filename=My+Test+File.pdf</screen>
    </section>
    <section>
      <title>Cluster Configuration</title>
      <para>This middleware understands the following configuration settings:</para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>incoming_remove_headers</literal>
          </term>
          <listitem>
            <para>A whitespace-delimited list of the headers to remove from
                                incoming requests. Names may optionally end with <literal>*</literal> to
                                indicate a prefix match. <literal>incoming_allow_headers</literal> is a
                                list of exceptions to these removals.
                                Default: <literal>x-timestamp</literal></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>incoming_allow_headers</literal>
          </term>
          <listitem>
            <para>A whitespace-delimited list of the headers allowed as
                                exceptions to <literal>incoming_remove_headers</literal>. Names may
                                optionally end with <literal>*</literal> to indicate a prefix match.</para>
            <para>Default: None</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>outgoing_remove_headers</literal>
          </term>
          <listitem>
            <para>A whitespace-delimited list of the headers to remove from
                                outgoing responses. Names may optionally end with <literal>*</literal> to
                                indicate a prefix match. <literal>outgoing_allow_headers</literal> is a
                                list of exceptions to these removals.</para>
            <para>Default: <literal>x-object-meta-*</literal></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>outgoing_allow_headers</literal>
          </term>
          <listitem>
            <para>A whitespace-delimited list of the headers allowed as
                                exceptions to <literal>outgoing_remove_headers</literal>. Names may
                                optionally end with <literal>*</literal> to indicate a prefix match.</para>
            <para>Default: <literal>x-object-meta-public-*</literal></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>methods</literal>
          </term>
          <listitem>
            <para>A whitespace delimited list of request methods that are
                                allowed to be used with a temporary URL.</para>
            <para>Default: <literal>GET HEAD PUT POST DELETE</literal></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.tempurl.TempURL">
          <term>
            <literal>swift.common.middleware.tempurl.TempURL</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <para>WSGI Middleware to grant temporary URLs specific access to Swift
                            resources. See the overview for more information.</para>
            <para>The proxy logs created for any subrequests made will have swift.source set
                            to “TU”.</para>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.agent">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.agent</property>
                </term>
                <listitem>
                  <para>HTTP user agent to use for subrequests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.app">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.app</property>
                </term>
                <listitem>
                  <para>The next WSGI application/filter in the paste.deploy pipeline.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.conf">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.conf</property>
                </term>
                <listitem>
                  <para>The filter configuration dict.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.incoming_allow_headers">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.incoming_allow_headers</property>
                </term>
                <listitem>
                  <para>Headers to allow in incoming requests. Uppercase WSGI env style,
                                    like <literal>HTTP_X_MATCHES_REMOVE_PREFIX_BUT_OKAY</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.incoming_allow_headers_startswith">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.incoming_allow_headers_startswith</property>
                </term>
                <listitem>
                  <para>Header with match prefixes to allow in incoming requests. Uppercase
                                    WSGI env style, like <literal>HTTP_X_MATCHES_REMOVE_PREFIX_BUT_OKAY_*</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.incoming_remove_headers">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.incoming_remove_headers</property>
                </term>
                <listitem>
                  <para>Headers to remove from incoming requests. Uppercase WSGI env style,
                                    like <literal>HTTP_X_PRIVATE</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.incoming_remove_headers_startswith">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.incoming_remove_headers_startswith</property>
                </term>
                <listitem>
                  <para>Header with match prefixes to remove from incoming requests.
                                    Uppercase WSGI env style, like <literal>HTTP_X_SENSITIVE_*</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.outgoing_allow_headers">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.outgoing_allow_headers</property>
                </term>
                <listitem>
                  <para>Headers to allow in outgoing responses. Lowercase, like
                                    <literal>x-matches-remove-prefix-but-okay</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.outgoing_allow_headers_startswith">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.outgoing_allow_headers_startswith</property>
                </term>
                <listitem>
                  <para>Header with match prefixes to allow in outgoing responses.
                                    Lowercase, like <literal>x-matches-remove-prefix-but-okay-*</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.outgoing_remove_headers">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.outgoing_remove_headers</property>
                </term>
                <listitem>
                  <para>Headers to remove from outgoing responses. Lowercase, like
                                    <literal>x-account-meta-temp-url-key</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.tempurl.TempURL.outgoing_remove_headers_startswith">
                <term>
                  <property>swift.common.middleware.tempurl.TempURL.outgoing_remove_headers_startswith</property>
                </term>
                <listitem>
                  <para>Header with match prefixes to remove from outgoing responses.
                                    Lowercase, like <literal>x-account-meta-private-*</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.tempurl.filter_factory">
          <term>
            <function>swift.common.middleware.tempurl.filter_factory</function>
          </term>
          <listitem>
            <para>Returns the WSGI filter for use with paste.deploy.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.tempurl.DEFAULT_INCOMING_REMOVE_HEADERS">
          <term>
            <literal>swift.common.middleware.tempurl.DEFAULT_INCOMING_REMOVE_HEADERS</literal>
          </term>
          <listitem>
            <para>Default headers to remove from incoming requests. Simply a whitespace
                            delimited list of header names and names can optionally end with ‘*’ to
                            indicate a prefix match. DEFAULT_INCOMING_ALLOW_HEADERS is a list of
                            exceptions to these removals.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.tempurl.DEFAULT_INCOMING_ALLOW_HEADERS">
          <term>
            <literal>swift.common.middleware.tempurl.DEFAULT_INCOMING_ALLOW_HEADERS</literal>
          </term>
          <listitem>
            <para>Default headers as exceptions to DEFAULT_INCOMING_REMOVE_HEADERS. Simply a
                            whitespace delimited list of header names and names can optionally end with
                            ‘*’ to indicate a prefix match.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.tempurl.DEFAULT_OUTGOING_REMOVE_HEADERS">
          <term>
            <literal>swift.common.middleware.tempurl.DEFAULT_OUTGOING_REMOVE_HEADERS</literal>
          </term>
          <listitem>
            <para>Default headers to remove from outgoing responses. Simply a whitespace
                            delimited list of header names and names can optionally end with ‘*’ to
                            indicate a prefix match. DEFAULT_OUTGOING_ALLOW_HEADERS is a list of
                            exceptions to these removals.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.tempurl.DEFAULT_OUTGOING_ALLOW_HEADERS">
          <term>
            <literal>swift.common.middleware.tempurl.DEFAULT_OUTGOING_ALLOW_HEADERS</literal>
          </term>
          <listitem>
            <para>Default headers as exceptions to DEFAULT_OUTGOING_REMOVE_HEADERS. Simply a
                            whitespace delimited list of header names and names can optionally end with
                            ‘*’ to indicate a prefix match.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section>
    <title>XProfile</title>
  </section>
</section>
