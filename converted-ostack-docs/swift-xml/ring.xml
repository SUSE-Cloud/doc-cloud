<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Partitioned Consistent Hash Ring</title>
  <section>
    <title>Ring</title>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.ring.Ring">
        <term>
          <literal>swift.common.ring.ring.Ring</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Partitioned consistent hashing ring.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.devs">
              <term>
                <property>swift.common.ring.ring.Ring.devs</property>
              </term>
              <listitem>
                <para>devices in the ring</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.get_more_nodes">
              <term>
                <property>swift.common.ring.ring.Ring.get_more_nodes</property>
              </term>
              <listitem>
                <para>Generator to get extra nodes for a partition for hinted handoff.</para>
                <para>The handoff nodes will try to be in zones other than the
                                primary zones, will take into account the device weights, and
                                will usually keep the same sequences of handoffs even with
                                ring changes.</para>
                <para>See <xref linkend="swift.common.ring.ring.Ring.get_nodes"/> for a description of the node dicts.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.get_nodes">
              <term>
                <property>swift.common.ring.ring.Ring.get_nodes</property>
              </term>
              <listitem>
                <para>Get the partition and nodes for an account/container/object.
                                If a node is responsible for more than one replica, it will
                                only appear in the output once.</para>
                <para>Each node dict will have at least the following keys:</para>
                <informaltable>
                  <tgroup cols="2">
                    <colspec colname="c1" colwidth="8.7*"/>
                    <colspec colname="c2" colwidth="91.3*"/>
                    <tbody>
                      <row>
                        <entry>
                          <para>id</para>
                        </entry>
                        <entry>
                          <para>unique integer identifier amongst devices</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>index</para>
                        </entry>
                        <entry>
                          <para>offset into the primary node list for the partition</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>weight</para>
                        </entry>
                        <entry>
                          <para>a float of the relative weight of this device as compared to
                                                    others; this indicates how many partitions the builder will try
                                                    to assign to this device</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>zone</para>
                        </entry>
                        <entry>
                          <para>integer indicating which zone the device is in; a given
                                                    partition will not be assigned to multiple devices within the
                                                    same zone</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>ip</para>
                        </entry>
                        <entry>
                          <para>the ip address of the device</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>port</para>
                        </entry>
                        <entry>
                          <para>the tcp port of the device</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>device</para>
                        </entry>
                        <entry>
                          <para>the device’s name on disk (sdb1, for example)</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>meta</para>
                        </entry>
                        <entry>
                          <para>general use ‘extra’ field; for example: the online date, the
                                                    hardware description</para>
                        </entry>
                      </row>
                    </tbody>
                  </tgroup>
                </informaltable>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.get_part">
              <term>
                <property>swift.common.ring.ring.Ring.get_part</property>
              </term>
              <listitem>
                <para>Get the partition for an account/container/object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.get_part_nodes">
              <term>
                <property>swift.common.ring.ring.Ring.get_part_nodes</property>
              </term>
              <listitem>
                <para>Get the nodes that are responsible for the partition. If one
                                node is responsible for more than one replica of the same
                                partition, it will only appear in the output once.</para>
                <para>See <xref linkend="swift.common.ring.ring.Ring.get_nodes"/> for a description of the node dicts.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.has_changed">
              <term>
                <property>swift.common.ring.ring.Ring.has_changed</property>
              </term>
              <listitem>
                <para>Check to see if the ring on disk is different than the current one in
                                memory.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.next_part_power">
              <term>
                <property>swift.common.ring.ring.Ring.next_part_power</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.part_power">
              <term>
                <property>swift.common.ring.ring.Ring.part_power</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.partition_count">
              <term>
                <property>swift.common.ring.ring.Ring.partition_count</property>
              </term>
              <listitem>
                <para>Number of partitions in the ring.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.Ring.replica_count">
              <term>
                <property>swift.common.ring.ring.Ring.replica_count</property>
              </term>
              <listitem>
                <para>Number of replicas (full or partial) used in the ring.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.ring.RingData">
        <term>
          <literal>swift.common.ring.ring.RingData</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Partitioned consistent hashing ring data (used for serialization).</para>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.RingData.deserialize_v1">
              <term>
                <property>swift.common.ring.ring.RingData.deserialize_v1</property>
              </term>
              <listitem>
                <para>Deserialize a v1 ring file into a dictionary with <literal>devs</literal>, <literal>part_shift</literal>,
                                and <literal>replica2part2dev_id</literal> keys.</para>
                <para>If the optional kwarg <literal>metadata_only</literal> is True, then the
                                <literal>replica2part2dev_id</literal> is not loaded and that key in the returned
                                dictionary just has the value <literal>[]</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.RingData.load">
              <term>
                <property>swift.common.ring.ring.RingData.load</property>
              </term>
              <listitem>
                <para>Load ring data from a file.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.RingData.save">
              <term>
                <property>swift.common.ring.ring.RingData.save</property>
              </term>
              <listitem>
                <para>Serialize this RingData instance to disk.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.RingData.serialize_v1">
              <term>
                <property>swift.common.ring.ring.RingData.serialize_v1</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.ring.RingData.to_dict">
              <term>
                <property>swift.common.ring.ring.RingData.to_dict</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="ring-builder">
    <title>Ring Builder</title>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.builder.RingBuilder">
        <term>
          <literal>swift.common.ring.builder.RingBuilder</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Used to build swift.common.ring.RingData instances to be written to disk
                        and used with swift.common.ring.Ring instances. See bin/swift-ring-builder
                        for example usage.</para>
          <para>The instance variable devs_changed indicates if the device information has
                        changed since the last balancing. This can be used by tools to know whether
                        a rebalance request is an isolated request or due to added, changed, or
                        removed devices.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.add_dev">
              <term>
                <property>swift.common.ring.builder.RingBuilder.add_dev</property>
              </term>
              <listitem>
                <para>Add a device to the ring. This device dict should have a minimum of the
                                following keys:</para>
                <informaltable>
                  <tgroup cols="2">
                    <colspec colname="c1" colwidth="8.7*"/>
                    <colspec colname="c2" colwidth="91.3*"/>
                    <tbody>
                      <row>
                        <entry>
                          <para>id</para>
                        </entry>
                        <entry>
                          <para>unique integer identifier amongst devices. Defaults to the next
                                                    id if the ‘id’ key is not provided in the dict</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>weight</para>
                        </entry>
                        <entry>
                          <para>a float of the relative weight of this device as compared to
                                                    others; this indicates how many partitions the builder will try
                                                    to assign to this device</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>region</para>
                        </entry>
                        <entry>
                          <para>integer indicating which region the device is in</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>zone</para>
                        </entry>
                        <entry>
                          <para>integer indicating which zone the device is in; a given
                                                    partition will not be assigned to multiple devices within the
                                                    same (region, zone) pair if there is any alternative</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>ip</para>
                        </entry>
                        <entry>
                          <para>the ip address of the device</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>port</para>
                        </entry>
                        <entry>
                          <para>the tcp port of the device</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>device</para>
                        </entry>
                        <entry>
                          <para>the device’s name on disk (sdb1, for example)</para>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <para>meta</para>
                        </entry>
                        <entry>
                          <para>general use ‘extra’ field; for example: the online date, the
                                                    hardware description</para>
                        </entry>
                      </row>
                    </tbody>
                  </tgroup>
                </informaltable>
                <note>
                  <para>This will not rebalance the ring immediately as you may want to
                                    make multiple changes for a single rebalance.</para>
                </note>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.cancel_increase_partition_power">
              <term>
                <property>swift.common.ring.builder.RingBuilder.cancel_increase_partition_power</property>
              </term>
              <listitem>
                <para>Cancels a ring partition power increasement.</para>
                <para>This sets the next_part_power to the current part_power. Object
                                replicators will still skip replication, and a cleanup is still
                                required. Finally, a finish_increase_partition_power needs to be run.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.change_min_part_hours">
              <term>
                <property>swift.common.ring.builder.RingBuilder.change_min_part_hours</property>
              </term>
              <listitem>
                <para>Changes the value used to decide if a given partition can be moved
                                again. This restriction is to give the overall system enough time to
                                settle a partition to its new location before moving it to yet another
                                location. While no data would be lost if a partition is moved several
                                times quickly, it could make that data unreachable for a short period
                                of time.</para>
                <para>This should be set to at least the average full partition replication
                                time. Starting it at 24 hours and then lowering it to what the
                                replicator reports as the longest partition cycle is best.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.copy_from">
              <term>
                <property>swift.common.ring.builder.RingBuilder.copy_from</property>
              </term>
              <listitem>
                <para>Reinitializes this RingBuilder instance from data obtained from the
                                builder dict given. Code example:</para>
                <screen>b = RingBuilder(1, 1, 1)  # Dummy values
b.copy_from(builder)</screen>
                <para>This is to restore a RingBuilder that has had its b.to_dict()
                                previously saved.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.debug">
              <term>
                <property>swift.common.ring.builder.RingBuilder.debug</property>
              </term>
              <listitem>
                <para>Temporarily enables debug logging, useful in tests, e.g.</para>
                <variablelist>
                  <varlistentry>
                    <term>with rb.debug():</term>
                    <listitem>
                      <para>rb.rebalance()</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.ever_rebalanced">
              <term>
                <property>swift.common.ring.builder.RingBuilder.ever_rebalanced</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.finish_increase_partition_power">
              <term>
                <property>swift.common.ring.builder.RingBuilder.finish_increase_partition_power</property>
              </term>
              <listitem>
                <para>Finish the partition power increase.</para>
                <para>The hard links from the old object locations should be removed by now.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.from_dict">
              <term>
                <property>swift.common.ring.builder.RingBuilder.from_dict</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.get_balance">
              <term>
                <property>swift.common.ring.builder.RingBuilder.get_balance</property>
              </term>
              <listitem>
                <para>Get the balance of the ring. The balance value is the highest
                                percentage of the desired amount of partitions a given device
                                wants. For instance, if the “worst” device wants (based on its
                                weight relative to the sum of all the devices’ weights) 123
                                partitions and it has 124 partitions, the balance value would
                                be 0.83 (1 extra / 123 wanted * 100 for percentage).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.get_part_devices">
              <term>
                <property>swift.common.ring.builder.RingBuilder.get_part_devices</property>
              </term>
              <listitem>
                <para>Get the devices that are responsible for the partition,
                                filtering out duplicates.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.get_required_overload">
              <term>
                <property>swift.common.ring.builder.RingBuilder.get_required_overload</property>
              </term>
              <listitem>
                <para>Returns the minimum overload value required to make the ring maximally
                                dispersed.</para>
                <para>The required overload is the largest percentage change of any single
                                device from its weighted replicanth to its wanted replicanth (note:
                                under weighted devices have a negative percentage change) to archive
                                dispersion - that is to say a single device that must be overloaded by
                                5% is worse than 5 devices in a single tier overloaded by 1%.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.get_ring">
              <term>
                <property>swift.common.ring.builder.RingBuilder.get_ring</property>
              </term>
              <listitem>
                <para>Get the ring, or more specifically, the swift.common.ring.RingData.
                                This ring data is the minimum required for use of the ring. The ring
                                builder itself keeps additional data such as when partitions were last
                                moved.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.id">
              <term>
                <property>swift.common.ring.builder.RingBuilder.id</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.increase_partition_power">
              <term>
                <property>swift.common.ring.builder.RingBuilder.increase_partition_power</property>
              </term>
              <listitem>
                <para>Increases ring partition power by one.</para>
                <para>Devices will be assigned to partitions like this:</para>
                <para>OLD: 0, 3, 7, 5, 2, 1, …
                                NEW: 0, 0, 3, 3, 7, 7, 5, 5, 2, 2, 1, 1, …</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.load">
              <term>
                <property>swift.common.ring.builder.RingBuilder.load</property>
              </term>
              <listitem>
                <para>Obtain RingBuilder instance of the provided builder file</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.min_part_seconds_left">
              <term>
                <property>swift.common.ring.builder.RingBuilder.min_part_seconds_left</property>
              </term>
              <listitem>
                <para>Get the total seconds until a rebalance can be performed</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.part_shift">
              <term>
                <property>swift.common.ring.builder.RingBuilder.part_shift</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.prepare_increase_partition_power">
              <term>
                <property>swift.common.ring.builder.RingBuilder.prepare_increase_partition_power</property>
              </term>
              <listitem>
                <para>Prepares a ring for partition power increase.</para>
                <para>This makes it possible to compute the future location of any object
                                based on the next partition power.</para>
                <para>In this phase object servers should create hard links when finalizing a
                                write to the new location as well. A relinker will be run after
                                restarting object-servers, creating hard links to all existing objects
                                in their future location.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.pretend_min_part_hours_passed">
              <term>
                <property>swift.common.ring.builder.RingBuilder.pretend_min_part_hours_passed</property>
              </term>
              <listitem>
                <para>Override min_part_hours by marking all partitions as having been moved
                                255 hours ago and last move epoch to ‘the beginning of time’. This can
                                be used to force a full rebalance on the next call to rebalance.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.rebalance">
              <term>
                <property>swift.common.ring.builder.RingBuilder.rebalance</property>
              </term>
              <listitem>
                <para>Rebalance the ring.</para>
                <para>This is the main work function of the builder, as it will assign and
                                reassign partitions to devices in the ring based on weights, distinct
                                zones, recent reassignments, etc.</para>
                <para>The process doesn’t always perfectly assign partitions (that’d take a
                                lot more analysis and therefore a lot more time – I had code that did
                                that before). Because of this, it keeps rebalancing until the device
                                skew (number of partitions a device wants compared to what it has) gets
                                below 1% or doesn’t change by more than 1% (only happens with a ring
                                that can’t be balanced no matter what).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.remove_dev">
              <term>
                <property>swift.common.ring.builder.RingBuilder.remove_dev</property>
              </term>
              <listitem>
                <para>Remove a device from the ring.</para>
                <note>
                  <para>This will not rebalance the ring immediately as you may want to
                                    make multiple changes for a single rebalance.</para>
                </note>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.save">
              <term>
                <property>swift.common.ring.builder.RingBuilder.save</property>
              </term>
              <listitem>
                <para>Serialize this RingBuilder instance to disk.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.search_devs">
              <term>
                <property>swift.common.ring.builder.RingBuilder.search_devs</property>
              </term>
              <listitem>
                <para>Search devices by parameters.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.set_dev_weight">
              <term>
                <property>swift.common.ring.builder.RingBuilder.set_dev_weight</property>
              </term>
              <listitem>
                <para>Set the weight of a device. This should be called rather than just
                                altering the weight key in the device dict directly, as the builder
                                will need to rebuild some internal state to reflect the change.</para>
                <note>
                  <para>This will not rebalance the ring immediately as you may want to
                                    make multiple changes for a single rebalance.</para>
                </note>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.set_overload">
              <term>
                <property>swift.common.ring.builder.RingBuilder.set_overload</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.set_replicas">
              <term>
                <property>swift.common.ring.builder.RingBuilder.set_replicas</property>
              </term>
              <listitem>
                <para>Changes the number of replicas in this ring.</para>
                <para>If the new replica count is sufficiently different that
                                self._replica2part2dev will change size, sets
                                self.devs_changed. This is so tools like
                                bin/swift-ring-builder can know to write out the new ring
                                rather than bailing out due to lack of balance change.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.to_dict">
              <term>
                <property>swift.common.ring.builder.RingBuilder.to_dict</property>
              </term>
              <listitem>
                <para>Returns a dict that can be used later with copy_from to
                                restore a RingBuilder. swift-ring-builder uses this to
                                pickle.dump the dict to a file and later load that dict into
                                copy_from.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.validate">
              <term>
                <property>swift.common.ring.builder.RingBuilder.validate</property>
              </term>
              <listitem>
                <para>Validate the ring.</para>
                <para>This is a safety function to try to catch any bugs in the building
                                process. It ensures partitions have been assigned to real devices,
                                aren’t doubly assigned, etc. It can also optionally check the even
                                distribution of partitions across devices.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.builder.RingBuilder.weight_of_one_part">
              <term>
                <property>swift.common.ring.builder.RingBuilder.weight_of_one_part</property>
              </term>
              <listitem>
                <para>Returns the weight of each partition as calculated from the
                                total weight of all the devices.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.builder.RingValidationWarning">
        <term>
          <literal>swift.common.ring.builder.RingValidationWarning</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Warning</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Composite Ring Builder</title>
    <para>A standard ring built using the <xref linkend="ring-builder"/> will attempt
                to randomly disperse replicas or erasure-coded fragments across failure
                domains, but does not provide any guarantees such as placing at least one
                replica of every partition into each region. Composite rings are intended to
                provide operators with greater control over the dispersion of object replicas
                or fragments across a cluster, in particular when there is a desire to
                have strict guarantees that some replicas or fragments are placed in certain
                failure domains. This is particularly important for policies with duplicated
                erasure-coded fragments.</para>
    <para>A composite ring comprises two or more component rings that are combined to
                form a single ring with a replica count equal to the sum of replica counts
                from the component rings. The component rings are built independently, using
                distinct devices in distinct regions, which means that the dispersion of
                replicas between the components can be guaranteed. The <literal>composite_builder</literal>
                utilities may then be used to combine components into a composite ring.</para>
    <para>For example, consider a normal ring <literal>ring0</literal> with replica count of 4 and
                devices in two regions <literal>r1</literal> and <literal>r2</literal>. Despite the best efforts of the
                ring-builder, it is possible for there to be three replicas of a particular
                partition placed in one region and only one replica placed in the other region.
                For example:</para>
    <screen>part_n -&gt; r1z1h110/sdb r1z2h12/sdb r1z3h13/sdb r2z1h21/sdb</screen>
    <para>Now consider two normal rings each with replica count of 2: <literal>ring1</literal> has
                devices in only <literal>r1</literal>; <literal>ring2</literal> has devices in only <literal>r2</literal>.
                When these rings are combined into a composite ring then every partition is
                guaranteed to be mapped to two devices in each of <literal>r1</literal> and <literal>r2</literal>, for
                example:</para>
    <screen>part_n -&gt; r1z1h10/sdb r1z2h20/sdb  r2z1h21/sdb r2z2h22/sdb
          |_____________________|  |_____________________|
                     |                        |
                   ring1                    ring2</screen>
    <para>The dispersion of partition replicas across failure domains within each of the
                two component rings may change as they are modified and rebalanced, but the
                dispersion of replicas between the two regions is guaranteed by the use of a
                composite ring.</para>
    <para>For rings to be formed into a composite they must satisfy the following
                requirements:</para>
    <itemizedlist>
      <listitem>
        <para>All component rings must have the same part power (and therefore number of
                        partitions)</para>
      </listitem>
      <listitem>
        <para>All component rings must have an integer replica count</para>
      </listitem>
      <listitem>
        <para>Each region may only be used in one component ring</para>
      </listitem>
      <listitem>
        <para>Each device may only be used in one component ring</para>
      </listitem>
    </itemizedlist>
    <para>Under the hood, the composite ring has a <literal>_replica2part2dev_id</literal> table that is
                the union of the tables from the component rings. Whenever the component rings
                are rebalanced, the composite ring must be rebuilt. There is no dynamic
                rebuilding of the composite ring.</para>
    <note>
      <para>The order in which component rings are combined into a composite ring is
                    very significant because it determines the order in which the
                    Ring.get_part_nodes() method will provide primary nodes for the composite
                    ring and consequently the node indexes assigned to the primary nodes. For
                    an erasure-coded policy, inadvertent changes to the primary node indexes
                    could result in large amounts of data movement due to fragments being moved
                    to their new correct primary.</para>
      <para>The <literal>id</literal> of each component RingBuilder is therefore stored in metadata of
                    the composite and used to check for the component ordering when the same
                    composite ring is re-composed. RingBuilder <literal>id</literal>s are normally assigned
                    when a RingBuilder instance is first saved. Older RingBuilder instances
                    loaded from file may not have an <literal>id</literal> assigned and will need to be saved
                    before they can be used as components of a composite ring. This can be
                    achieved by, for example:</para>
      <screen>swift-ring-builder &lt;builder-file&gt; rebalance --force</screen>
    </note>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.composite_builder.CompositeRingBuilder">
        <term>
          <literal>swift.common.ring.composite_builder.CompositeRingBuilder</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Provides facility to create, persist, load, rebalance  and update composite
                        rings, for example:</para>
          <screen># create a CompositeRingBuilder instance with a list of
# component builder files
crb = CompositeRingBuilder(["region1.builder", "region2.builder"])

# perform a cooperative rebalance of the component builders
crb.rebalance()

# call compose which will make a new RingData instance
ring_data = crb.compose()

# save the composite ring file
ring_data.save("composite_ring.gz")

# save the composite metadata file
crb.save("composite_builder.composite")

# load the persisted composite metadata file
crb = CompositeRingBuilder.load("composite_builder.composite")

# compose (optionally update the paths to the component builder files)
crb.compose(["/path/to/region1.builder", "/path/to/region2.builder"])</screen>
          <para>Composite ring metadata is persisted to file in JSON format. The metadata
                        has the structure shown below (using example values):</para>
          <screen>{
  "version": 4,
  "components": [
    {
      "version": 3,
      "id": "8e56f3b692d43d9a666440a3d945a03a",
      "replicas": 1
    },
    {
      "version": 5,
      "id": "96085923c2b644999dbfd74664f4301b",
      "replicas": 1
    }
  ]
  "component_builder_files": {
      "8e56f3b692d43d9a666440a3d945a03a": "/etc/swift/region1.builder",
      "96085923c2b644999dbfd74664f4301b": "/etc/swift/region2.builder",
  }
  "serialization_version": 1,
  "saved_path": "/etc/swift/multi-ring-1.composite",
}</screen>
          <para><literal>version</literal> is an integer representing the current version of the composite
                        ring, which increments each time the ring is successfully (re)composed.</para>
          <para><literal>components</literal> is a list of dicts, each of which describes relevant
                        properties of a component ring</para>
          <para><literal>component_builder_files</literal> is a dict that maps component ring builder ids to
                        the file from which that component ring builder was loaded.</para>
          <para><literal>serialization_version</literal> is an integer constant.</para>
          <para><literal>saved_path</literal> is the path to which the metadata was written.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CompositeRingBuilder.can_part_move">
              <term>
                <property>swift.common.ring.composite_builder.CompositeRingBuilder.can_part_move</property>
              </term>
              <listitem>
                <para>Check with all component builders that it is ok to move a partition.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CompositeRingBuilder.compose">
              <term>
                <property>swift.common.ring.composite_builder.CompositeRingBuilder.compose</property>
              </term>
              <listitem>
                <para>Builds a composite ring using component ring builders loaded from a
                                list of builder files and updates composite ring metadata.</para>
                <para>If a list of component ring builder files is given then that will be
                                used to load component ring builders. Otherwise, component ring
                                builders will be loaded using the list of builder files that was set
                                when the instance was constructed.</para>
                <para>In either case, if metadata for an existing composite ring has been
                                loaded then the component ring builders are verified for consistency
                                with the existing composition of builders, unless the optional
                                <literal>force</literal> flag if set True.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CompositeRingBuilder.load">
              <term>
                <property>swift.common.ring.composite_builder.CompositeRingBuilder.load</property>
              </term>
              <listitem>
                <para>Load composite ring metadata.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CompositeRingBuilder.load_components">
              <term>
                <property>swift.common.ring.composite_builder.CompositeRingBuilder.load_components</property>
              </term>
              <listitem>
                <para>Loads component ring builders from builder files. Previously loaded
                                component ring builders will discarded and reloaded.</para>
                <para>If a list of component ring builder files is given then that will be
                                used to load component ring builders. Otherwise, component ring
                                builders will be loaded using the list of builder files that was set
                                when the instance was constructed.</para>
                <para>In either case, if metadata for an existing composite ring has been
                                loaded then the component ring builders are verified for consistency
                                with the existing composition of builders, unless the optional
                                <literal>force</literal> flag if set True.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CompositeRingBuilder.rebalance">
              <term>
                <property>swift.common.ring.composite_builder.CompositeRingBuilder.rebalance</property>
              </term>
              <listitem>
                <para>Cooperatively rebalances all component ring builders.</para>
                <para>This method does not change the state of the composite ring; a
                                subsequent call to <xref linkend="swift.common.ring.composite_builder.CompositeRingBuilder.compose"/> is required to generate updated
                                composite <literal>RingData</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CompositeRingBuilder.save">
              <term>
                <property>swift.common.ring.composite_builder.CompositeRingBuilder.save</property>
              </term>
              <listitem>
                <para>Save composite ring metadata to given file. See
                                <xref linkend="swift.common.ring.composite_builder.CompositeRingBuilder"/> for details of the persisted metadata
                                format.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CompositeRingBuilder.to_dict">
              <term>
                <property>swift.common.ring.composite_builder.CompositeRingBuilder.to_dict</property>
              </term>
              <listitem>
                <para>Transform the composite ring attributes to a dict. See
                                <xref linkend="swift.common.ring.composite_builder.CompositeRingBuilder"/> for details of the persisted metadata
                                format.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CompositeRingBuilder.update_last_part_moves">
              <term>
                <property>swift.common.ring.composite_builder.CompositeRingBuilder.update_last_part_moves</property>
              </term>
              <listitem>
                <para>Updates the record of how many hours ago each partition was moved in
                                all component builders.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.composite_builder.CooperativeRingBuilder">
        <term>
          <literal>swift.common.ring.composite_builder.CooperativeRingBuilder</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.ring.builder.RingBuilder"/></para>
          <para>A subclass of <literal>RingBuilder</literal> that participates in cooperative
                        rebalance.</para>
          <para>During rebalance this subclass will consult with its <literal>parent_builder</literal>
                        before moving a partition. The <literal>parent_builder</literal> may in turn check with
                        co-builders (including this instance) to verify that none have moved that
                        partition in the last <literal>min_part_hours</literal>.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CooperativeRingBuilder.can_part_move">
              <term>
                <property>swift.common.ring.composite_builder.CooperativeRingBuilder.can_part_move</property>
              </term>
              <listitem>
                <para>Check that in the context of this builder alone it is ok to move a
                                partition.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.ring.composite_builder.CooperativeRingBuilder.update_last_part_moves">
              <term>
                <property>swift.common.ring.composite_builder.CooperativeRingBuilder.update_last_part_moves</property>
              </term>
              <listitem>
                <para>Updates the record of how many hours ago each partition was moved in
                                in this builder.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.composite_builder.check_against_existing">
        <term>
          <function>swift.common.ring.composite_builder.check_against_existing</function>
        </term>
        <listitem>
          <para>Check that the given builders and their order are the same as that
                        used to build an existing composite ring. Return True if any of the given
                        builders has been modified with respect to its state when the given
                        component_meta was created.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.composite_builder.check_builder_ids">
        <term>
          <function>swift.common.ring.composite_builder.check_builder_ids</function>
        </term>
        <listitem>
          <para>Check that all builders in the given list have id’s assigned and that no
                        id appears more than once in the list.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.composite_builder.check_for_dev_uniqueness">
        <term>
          <function>swift.common.ring.composite_builder.check_for_dev_uniqueness</function>
        </term>
        <listitem>
          <para>Check that no device appears in more than one of the given list of
                        builders.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.composite_builder.check_same_builder">
        <term>
          <function>swift.common.ring.composite_builder.check_same_builder</function>
        </term>
        <listitem>
          <para>Check that the given new_component metadata describes the same builder as
                        the given old_component metadata. The new_component builder does not
                        necessarily need to be in the same state as when the old_component metadata
                        was created to satisfy this check e.g. it may have changed devs and been
                        rebalanced.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.composite_builder.compose_rings">
        <term>
          <function>swift.common.ring.composite_builder.compose_rings</function>
        </term>
        <listitem>
          <para>Given a list of component ring builders, perform validation on the list of
                        builders and return a composite RingData instance.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.composite_builder.is_builder_newer">
        <term>
          <function>swift.common.ring.composite_builder.is_builder_newer</function>
        </term>
        <listitem>
          <para>Return True if the given builder has been modified with respect to its
                        state when the given component_meta was created.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.ring.composite_builder.pre_validate_all_builders">
        <term>
          <function>swift.common.ring.composite_builder.pre_validate_all_builders</function>
        </term>
        <listitem>
          <para>Pre-validation for all component ring builders that are to be included in
                        the composite ring. Checks that all component rings are valid with respect
                        to each other.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
</section>
