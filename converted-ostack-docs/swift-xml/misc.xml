<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Misc</title>
  <section xml:id="acls">
    <title>ACLs</title>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.acl.acls_from_account_info">
        <term>
          <function>swift.common.middleware.acl.acls_from_account_info</function>
        </term>
        <listitem>
          <para>Extract the account ACLs from the given account_info, and return the ACLs.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.acl.clean_acl">
        <term>
          <function>swift.common.middleware.acl.clean_acl</function>
        </term>
        <listitem>
          <para>Returns a cleaned ACL header value, validating that it meets the formatting
                        requirements for standard Swift ACL strings.</para>
          <para>The ACL format is:</para>
          <screen>[item[,item...]]</screen>
          <para>Each item can be a group name to give access to or a referrer designation
                        to grant or deny based on the HTTP Referer header.</para>
          <para>The referrer designation format is:</para>
          <screen>.r:[-]value</screen>
          <para>The <literal>.r</literal> can also be <literal>.ref</literal>, <literal>.referer</literal>, or <literal>.referrer</literal>; though it
                        will be shortened to just <literal>.r</literal> for decreased character count usage.</para>
          <para>The value can be <literal>*</literal> to specify any referrer host is allowed access, a
                        specific host name like <literal>www.example.com</literal>, or if it has a leading period
                        <literal>.</literal> or leading <literal>*.</literal> it is a domain name specification, like
                        <literal>.example.com</literal> or <literal>*.example.com</literal>. The leading minus sign <literal>-</literal>
                        indicates referrer hosts that should be denied access.</para>
          <para>Referrer access is applied in the order they are specified. For example,
                        .r:.example.com,.r:-thief.example.com would allow all hosts ending with
                        .example.com except for the specific host thief.example.com.</para>
          <para>Example valid ACLs:</para>
          <screen>.r:*
.r:*,.r:-.thief.com
.r:*,.r:.example.com,.r:-thief.example.com
.r:*,.r:-.thief.com,bobs_account,sues_account:sue
bobs_account,sues_account:sue</screen>
          <para>Example invalid ACLs:</para>
          <screen>.r:
.r:-</screen>
          <para>By default, allowing read access via .r will not allow listing objects in
                        the container – just retrieving objects from the container. To turn on
                        listings, use the .rlistings directive.</para>
          <para>Also, .r designations aren’t allowed in headers whose names include the
                        word ‘write’.</para>
          <para>ACLs that are “messy” will be cleaned up. Examples:</para>
          <informaltable>
            <tgroup cols="2">
              <colspec colname="c1" colwidth="50.0*"/>
              <colspec colname="c2" colwidth="50.0*"/>
              <tbody>
                <row>
                  <entry>
                    <para>Original</para>
                  </entry>
                  <entry>
                    <para>Cleaned</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <literal>bob, sue</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <literal>bob,sue</literal>
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <literal>bob , sue</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <literal>bob,sue</literal>
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <literal>bob,,,sue</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <literal>bob,sue</literal>
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <literal>.referrer : *</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <literal>.r:*</literal>
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <literal>.ref:*.example.com</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <literal>.r:.example.com</literal>
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <literal>.r:*, .rlistings</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <literal>.r:*,.rlistings</literal>
                    </para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.acl.format_acl">
        <term>
          <function>swift.common.middleware.acl.format_acl</function>
        </term>
        <listitem>
          <para>Compatibility wrapper to help migrate ACL syntax from version 1 to 2.
                        Delegates to the appropriate version-specific format_acl method, defaulting
                        to version 1 for backward compatibility.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.acl.format_acl_v1">
        <term>
          <function>swift.common.middleware.acl.format_acl_v1</function>
        </term>
        <listitem>
          <para>Returns a standard Swift ACL string for the given inputs.</para>
          <para>Caller is responsible for ensuring that :referrers: parameter is only given
                        if the ACL is being generated for X-Container-Read.  (X-Container-Write
                        and the account ACL headers don’t support referrers.)</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.acl.format_acl_v2">
        <term>
          <function>swift.common.middleware.acl.format_acl_v2</function>
        </term>
        <listitem>
          <para>Returns a version-2 Swift ACL JSON string.</para>
          <variablelist>
            <varlistentry>
              <term>HTTP headers for Version 2 ACLs have the following form:</term>
              <listitem>
                <para>Header-Name: {“arbitrary”:”json”,”encoded”:”string”}</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>JSON will be forced ASCII (containing six-char uNNNN sequences rather
                        than UTF-8; UTF-8 is valid JSON but clients vary in their support for
                        UTF-8 headers), and without extraneous whitespace.</para>
          <para>Advantages over V1: forward compatibility (new keys don’t cause parsing
                        exceptions); Unicode support; no reserved words (you can have a user
                        named .rlistings if you want).</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.acl.parse_acl">
        <term>
          <function>swift.common.middleware.acl.parse_acl</function>
        </term>
        <listitem>
          <para>Compatibility wrapper to help migrate ACL syntax from version 1 to 2.
                        Delegates to the appropriate version-specific parse_acl method, attempting
                        to determine the version from the types of args/kwargs.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.acl.parse_acl_v1">
        <term>
          <function>swift.common.middleware.acl.parse_acl_v1</function>
        </term>
        <listitem>
          <para>Parses a standard Swift ACL string into a referrers list and groups list.</para>
          <para>See <xref linkend="swift.common.middleware.acl.clean_acl"/> for documentation of the standard Swift ACL format.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.acl.parse_acl_v2">
        <term>
          <function>swift.common.middleware.acl.parse_acl_v2</function>
        </term>
        <listitem>
          <para>Parses a version-2 Swift ACL string and returns a dict of ACL info.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.middleware.acl.referrer_allowed">
        <term>
          <function>swift.common.middleware.acl.referrer_allowed</function>
        </term>
        <listitem>
          <para>Returns True if the referrer should be allowed based on the referrer_acl
                        list (as returned by <xref linkend="swift.common.middleware.acl.parse_acl"/>).</para>
          <para>See <xref linkend="swift.common.middleware.acl.clean_acl"/> for documentation of the standard Swift ACL format.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Buffered HTTP</title>
    <para>Monkey Patch httplib.HTTPResponse to buffer reads of headers. This can improve
                performance when making large numbers of small HTTP requests.  This module
                also provides helper functions to make HTTP connections using
                BufferedHTTPResponse.</para>
    <warning>
      <para>If you use this, be sure that the libraries you are using do not access
                    the socket directly (xmlrpclib, I’m looking at you :/), and instead
                    make all calls through httplib.</para>
    </warning>
    <variablelist>
      <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPConnection">
        <term>
          <literal>swift.common.bufferedhttp.BufferedHTTPConnection</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.green.http.client.HTTPConnection</literal></para>
          <para>HTTPConnection class that uses BufferedHTTPResponse</para>
          <variablelist>
            <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPConnection.connect">
              <term>
                <property>swift.common.bufferedhttp.BufferedHTTPConnection.connect</property>
              </term>
              <listitem>
                <para>Connect to the host and port specified in __init__.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPConnection.getresponse">
              <term>
                <property>swift.common.bufferedhttp.BufferedHTTPConnection.getresponse</property>
              </term>
              <listitem>
                <para>Get the response from the server.</para>
                <para>If the HTTPConnection is in the correct state, returns an
                                instance of HTTPResponse or of whatever object is returned by
                                the response_class variable.</para>
                <para>If a request has not been sent or if a previous response has
                                not be handled, ResponseNotReady is raised.  If the HTTP
                                response indicates that the connection should be closed, then
                                it will be closed before the response is returned.  When the
                                connection is closed, the underlying socket is closed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPConnection.putrequest">
              <term>
                <property>swift.common.bufferedhttp.BufferedHTTPConnection.putrequest</property>
              </term>
              <listitem>
                <para>Send a request to the server.</para>
                <para>method’ specifies an HTTP request method, e.g. ‘GET’.
                                url’ specifies the object being requested, e.g. ‘/index.html’.
                                skip_host’ if True does not add automatically a ‘Host:’ header
                                skip_accept_encoding’ if True does not add automatically an</para>
                <para>‘Accept-Encoding:’ header</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPConnection.response_class">
              <term>
                <property>swift.common.bufferedhttp.BufferedHTTPConnection.response_class</property>
              </term>
              <listitem>
                <para>alias of <xref linkend="swift.common.bufferedhttp.BufferedHTTPResponse"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPResponse">
        <term>
          <literal>swift.common.bufferedhttp.BufferedHTTPResponse</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.green.http.client.HTTPResponse</literal></para>
          <para>HTTPResponse class that buffers reading of headers</para>
          <variablelist>
            <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPResponse.close">
              <term>
                <property>swift.common.bufferedhttp.BufferedHTTPResponse.close</property>
              </term>
              <listitem>
                <para>Flush and close the IO object.</para>
                <para>This method has no effect if the file is already closed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPResponse.nuke_from_orbit">
              <term>
                <property>swift.common.bufferedhttp.BufferedHTTPResponse.nuke_from_orbit</property>
              </term>
              <listitem>
                <para>Terminate the socket with extreme prejudice.</para>
                <para>Closes the underlying socket regardless of whether or not anyone else
                                has references to it. Use this when you are certain that nobody else
                                you care about has a reference to this socket.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPResponse.read">
              <term>
                <property>swift.common.bufferedhttp.BufferedHTTPResponse.read</property>
              </term>
              <listitem>
                <para>Read and return up to n bytes.</para>
                <para>If the argument is omitted, None, or negative, reads and
                                returns all data until EOF.</para>
                <para>If the argument is positive, and the underlying raw stream is
                                not ‘interactive’, multiple raw reads may be issued to satisfy
                                the byte count (unless EOF is reached first).  But for
                                interactive raw streams (as well as sockets and pipes), at most
                                one raw read will be issued, and a short result does not imply
                                that EOF is imminent.</para>
                <para>Returns an empty bytes object on EOF.</para>
                <para>Returns None if the underlying raw stream was open in non-blocking
                                mode and no data is available at the moment.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.bufferedhttp.BufferedHTTPResponse.readline">
              <term>
                <property>swift.common.bufferedhttp.BufferedHTTPResponse.readline</property>
              </term>
              <listitem>
                <para>Read and return a line from the stream.</para>
                <para>If size is specified, at most size bytes will be read.</para>
                <para>The line terminator is always b’n’ for binary files; for text
                                files, the newlines argument to open can be used to select the line
                                terminator(s) recognized.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.bufferedhttp.http_connect">
        <term>
          <function>swift.common.bufferedhttp.http_connect</function>
        </term>
        <listitem>
          <para>Helper function to create an HTTPConnection object. If ssl is set True,
                        HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection
                        will be used, which is buffered for backend Swift services.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.bufferedhttp.http_connect_raw">
        <term>
          <function>swift.common.bufferedhttp.http_connect_raw</function>
        </term>
        <listitem>
          <para>Helper function to create an HTTPConnection object. If ssl is set True,
                        HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection
                        will be used, which is buffered for backend Swift services.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Constraints</title>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.FORMAT2CONTENT_TYPE">
        <term>
          <literal>swift.common.constraints.FORMAT2CONTENT_TYPE</literal>
        </term>
        <listitem>
          <para>Query string format= values to their corresponding content-type values</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_account_format">
        <term>
          <function>swift.common.constraints.check_account_format</function>
        </term>
        <listitem>
          <para>Validate that the header contains valid account or container name.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_container_format">
        <term>
          <function>swift.common.constraints.check_container_format</function>
        </term>
        <listitem>
          <para>Validate that the header contains valid account or container name.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_delete_headers">
        <term>
          <function>swift.common.constraints.check_delete_headers</function>
        </term>
        <listitem>
          <para>Validate if ‘x-delete’ headers are have correct values
                        values should be positive integers and correspond to
                        a time in the future.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_dir">
        <term>
          <function>swift.common.constraints.check_dir</function>
        </term>
        <listitem>
          <para>Verify that the path to the device is a directory and is a lesser
                        constraint that is enforced when a full mount_check isn’t possible
                        with, for instance, a VM using loopback or partitions.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_float">
        <term>
          <function>swift.common.constraints.check_float</function>
        </term>
        <listitem>
          <para>Helper function for checking if a string can be converted to a float.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_metadata">
        <term>
          <function>swift.common.constraints.check_metadata</function>
        </term>
        <listitem>
          <para>Check metadata sent in the request headers.  This should only check
                        that the metadata in the request given is valid.  Checks against
                        account/container overall metadata should be forwarded on to its
                        respective server to be checked.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_mount">
        <term>
          <function>swift.common.constraints.check_mount</function>
        </term>
        <listitem>
          <para>Verify that the path to the device is a mount point and mounted.  This
                        allows us to fast fail on drives that have been unmounted because of
                        issues, and also prevents us for accidentally filling up the root
                        partition.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_name_format">
        <term>
          <function>swift.common.constraints.check_name_format</function>
        </term>
        <listitem>
          <para>Validate that the header contains valid account or container name.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_object_creation">
        <term>
          <function>swift.common.constraints.check_object_creation</function>
        </term>
        <listitem>
          <para>Check to ensure that everything is alright about an object to be created.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.check_utf8">
        <term>
          <function>swift.common.constraints.check_utf8</function>
        </term>
        <listitem>
          <para>Validate if a string is valid UTF-8 str or unicode and that it
                        does not contain any null character.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.reload_constraints">
        <term>
          <function>swift.common.constraints.reload_constraints</function>
        </term>
        <listitem>
          <para>Parse SWIFT_CONF_FILE and reset module level global constraint attrs,
                        populating OVERRIDE_CONSTRAINTS AND EFFECTIVE_CONSTRAINTS along the way.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.valid_api_version">
        <term>
          <function>swift.common.constraints.valid_api_version</function>
        </term>
        <listitem>
          <para>Checks if the requested version is valid.</para>
          <para>Currently Swift only supports “v1” and “v1.0”.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.constraints.valid_timestamp">
        <term>
          <function>swift.common.constraints.valid_timestamp</function>
        </term>
        <listitem>
          <para>Helper function to extract a timestamp from requests that require one.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Container Sync Realms</title>
    <variablelist>
      <varlistentry xml:id="swift.common.container_sync_realms.ContainerSyncRealms">
        <term>
          <literal>swift.common.container_sync_realms.ContainerSyncRealms</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Loads and parses the container-sync-realms.conf, occasionally
                        checking the file’s mtime to see if it needs to be reloaded.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.container_sync_realms.ContainerSyncRealms.clusters">
              <term>
                <property>swift.common.container_sync_realms.ContainerSyncRealms.clusters</property>
              </term>
              <listitem>
                <para>Returns a list of clusters for the realm.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.container_sync_realms.ContainerSyncRealms.endpoint">
              <term>
                <property>swift.common.container_sync_realms.ContainerSyncRealms.endpoint</property>
              </term>
              <listitem>
                <para>Returns the endpoint for the cluster in the realm.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.container_sync_realms.ContainerSyncRealms.get_sig">
              <term>
                <property>swift.common.container_sync_realms.ContainerSyncRealms.get_sig</property>
              </term>
              <listitem>
                <para>Returns the hexdigest string of the HMAC-SHA1 (RFC 2104) for
                                the information given.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.container_sync_realms.ContainerSyncRealms.key">
              <term>
                <property>swift.common.container_sync_realms.ContainerSyncRealms.key</property>
              </term>
              <listitem>
                <para>Returns the key for the realm.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.container_sync_realms.ContainerSyncRealms.key2">
              <term>
                <property>swift.common.container_sync_realms.ContainerSyncRealms.key2</property>
              </term>
              <listitem>
                <para>Returns the key2 for the realm.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.container_sync_realms.ContainerSyncRealms.realms">
              <term>
                <property>swift.common.container_sync_realms.ContainerSyncRealms.realms</property>
              </term>
              <listitem>
                <para>Returns a list of realms.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.container_sync_realms.ContainerSyncRealms.reload">
              <term>
                <property>swift.common.container_sync_realms.ContainerSyncRealms.reload</property>
              </term>
              <listitem>
                <para>Forces a reload of the conf file.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Direct Client</title>
    <para>Internal client library for making calls directly to the servers rather than
                through the proxy.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.DirectClientException">
        <term>
          <literal>swift.common.direct_client.DirectClientException</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.ClientException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_delete_account">
        <term>
          <function>swift.common.direct_client.direct_delete_account</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_delete_container">
        <term>
          <function>swift.common.direct_client.direct_delete_container</function>
        </term>
        <listitem>
          <para>Delete container directly from the container server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_delete_container_object">
        <term>
          <function>swift.common.direct_client.direct_delete_container_object</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_delete_object">
        <term>
          <function>swift.common.direct_client.direct_delete_object</function>
        </term>
        <listitem>
          <para>Delete object directly from the object server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_get_account">
        <term>
          <function>swift.common.direct_client.direct_get_account</function>
        </term>
        <listitem>
          <para>Get listings directly from the account server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_get_container">
        <term>
          <function>swift.common.direct_client.direct_get_container</function>
        </term>
        <listitem>
          <para>Get container listings directly from the container server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_get_object">
        <term>
          <function>swift.common.direct_client.direct_get_object</function>
        </term>
        <listitem>
          <para>Get object directly from the object server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_get_suffix_hashes">
        <term>
          <function>swift.common.direct_client.direct_get_suffix_hashes</function>
        </term>
        <listitem>
          <para>Get suffix hashes directly from the object server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_head_container">
        <term>
          <function>swift.common.direct_client.direct_head_container</function>
        </term>
        <listitem>
          <para>Request container information directly from the container server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_head_object">
        <term>
          <function>swift.common.direct_client.direct_head_object</function>
        </term>
        <listitem>
          <para>Request object information directly from the object server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_post_object">
        <term>
          <function>swift.common.direct_client.direct_post_object</function>
        </term>
        <listitem>
          <para>Direct update to object metadata on object server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_put_container_object">
        <term>
          <function>swift.common.direct_client.direct_put_container_object</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.direct_put_object">
        <term>
          <function>swift.common.direct_client.direct_put_object</function>
        </term>
        <listitem>
          <para>Put object directly from the object server.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.gen_headers">
        <term>
          <function>swift.common.direct_client.gen_headers</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.direct_client.retry">
        <term>
          <function>swift.common.direct_client.retry</function>
        </term>
        <listitem>
          <para>Helper function to retry a given function a number of times.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Exceptions</title>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.APIVersionError">
        <term>
          <literal>swift.common.exceptions.APIVersionError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ChunkReadError">
        <term>
          <literal>swift.common.exceptions.ChunkReadError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ChunkReadTimeout">
        <term>
          <literal>swift.common.exceptions.ChunkReadTimeout</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.timeout.Timeout</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ChunkWriteTimeout">
        <term>
          <literal>swift.common.exceptions.ChunkWriteTimeout</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.timeout.Timeout</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ClientException">
        <term>
          <literal>swift.common.exceptions.ClientException</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ConnectionTimeout">
        <term>
          <literal>swift.common.exceptions.ConnectionTimeout</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.timeout.Timeout</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DeviceUnavailable">
        <term>
          <literal>swift.common.exceptions.DeviceUnavailable</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileCollision">
        <term>
          <literal>swift.common.exceptions.DiskFileCollision</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.DiskFileError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileDeleted">
        <term>
          <literal>swift.common.exceptions.DiskFileDeleted</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.DiskFileNotExist"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileDeviceUnavailable">
        <term>
          <literal>swift.common.exceptions.DiskFileDeviceUnavailable</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.DiskFileError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileError">
        <term>
          <literal>swift.common.exceptions.DiskFileError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileExpired">
        <term>
          <literal>swift.common.exceptions.DiskFileExpired</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.DiskFileDeleted"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileNoSpace">
        <term>
          <literal>swift.common.exceptions.DiskFileNoSpace</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.DiskFileError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileNotExist">
        <term>
          <literal>swift.common.exceptions.DiskFileNotExist</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.DiskFileError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileNotOpen">
        <term>
          <literal>swift.common.exceptions.DiskFileNotOpen</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.DiskFileError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileQuarantined">
        <term>
          <literal>swift.common.exceptions.DiskFileQuarantined</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.DiskFileError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DiskFileXattrNotSupported">
        <term>
          <literal>swift.common.exceptions.DiskFileXattrNotSupported</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.DiskFileError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DriveNotMounted">
        <term>
          <literal>swift.common.exceptions.DriveNotMounted</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.DuplicateDeviceError">
        <term>
          <literal>swift.common.exceptions.DuplicateDeviceError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.RingBuilderError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.EmptyRingError">
        <term>
          <literal>swift.common.exceptions.EmptyRingError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.RingBuilderError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.EncryptionException">
        <term>
          <literal>swift.common.exceptions.EncryptionException</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.FileNotFoundError">
        <term>
          <literal>swift.common.exceptions.FileNotFoundError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.FooterNotSupported">
        <term>
          <literal>swift.common.exceptions.FooterNotSupported</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.InsufficientStorage">
        <term>
          <literal>swift.common.exceptions.InsufficientStorage</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.InvalidAccountInfo">
        <term>
          <literal>swift.common.exceptions.InvalidAccountInfo</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.InvalidPidFileException">
        <term>
          <literal>swift.common.exceptions.InvalidPidFileException</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.InvalidTimestamp">
        <term>
          <literal>swift.common.exceptions.InvalidTimestamp</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ListingIterError">
        <term>
          <literal>swift.common.exceptions.ListingIterError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ListingIterNotAuthorized">
        <term>
          <literal>swift.common.exceptions.ListingIterNotAuthorized</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.ListingIterError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ListingIterNotFound">
        <term>
          <literal>swift.common.exceptions.ListingIterNotFound</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.ListingIterError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.LockTimeout">
        <term>
          <literal>swift.common.exceptions.LockTimeout</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.MessageTimeout"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.MessageTimeout">
        <term>
          <literal>swift.common.exceptions.MessageTimeout</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.timeout.Timeout</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.MimeInvalid">
        <term>
          <literal>swift.common.exceptions.MimeInvalid</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.MultiphasePUTNotSupported">
        <term>
          <literal>swift.common.exceptions.MultiphasePUTNotSupported</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.PathNotDir">
        <term>
          <literal>swift.common.exceptions.PathNotDir</literal>
        </term>
        <listitem>
          <para>Bases: <literal>OSError</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.PermissionError">
        <term>
          <literal>swift.common.exceptions.PermissionError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.PutterConnectError">
        <term>
          <literal>swift.common.exceptions.PutterConnectError</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.RangeAlreadyComplete">
        <term>
          <literal>swift.common.exceptions.RangeAlreadyComplete</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ReplicationException">
        <term>
          <literal>swift.common.exceptions.ReplicationException</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ReplicationLockTimeout">
        <term>
          <literal>swift.common.exceptions.ReplicationLockTimeout</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.LockTimeout"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.ResponseTimeout">
        <term>
          <literal>swift.common.exceptions.ResponseTimeout</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.timeout.Timeout</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.RingBuilderError">
        <term>
          <literal>swift.common.exceptions.RingBuilderError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.RingLoadError">
        <term>
          <literal>swift.common.exceptions.RingLoadError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.RingValidationError">
        <term>
          <literal>swift.common.exceptions.RingValidationError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.RingBuilderError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.SegmentError">
        <term>
          <literal>swift.common.exceptions.SegmentError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.SuffixSyncError">
        <term>
          <literal>swift.common.exceptions.SuffixSyncError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.SwiftException">
        <term>
          <literal>swift.common.exceptions.SwiftException</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.exceptions.UnPicklingError">
        <term>
          <literal>swift.common.exceptions.UnPicklingError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.exceptions.SwiftException"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Internal Client</title>
    <variablelist>
      <varlistentry xml:id="swift.common.internal_client.CompressingFileReader">
        <term>
          <literal>swift.common.internal_client.CompressingFileReader</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Wrapper for file object to compress object while reading.</para>
          <para>Can be used to wrap file objects passed to InternalClient.upload_object().</para>
          <para>Used in testing of InternalClient.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.CompressingFileReader.next">
              <term>
                <property>swift.common.internal_client.CompressingFileReader.next</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.CompressingFileReader.read">
              <term>
                <property>swift.common.internal_client.CompressingFileReader.read</property>
              </term>
              <listitem>
                <para>Reads a chunk from the file object.</para>
                <para>Params are passed directly to the underlying file object’s read().</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.CompressingFileReader.seek">
              <term>
                <property>swift.common.internal_client.CompressingFileReader.seek</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.CompressingFileReader.set_initial_state">
              <term>
                <property>swift.common.internal_client.CompressingFileReader.set_initial_state</property>
              </term>
              <listitem>
                <para>Sets the object to the state needed for the first read.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.internal_client.InternalClient">
        <term>
          <literal>swift.common.internal_client.InternalClient</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>An internal client that uses a swift proxy app to make requests to Swift.</para>
          <para>This client will exponentially slow down for retries.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.account_ring">
              <term>
                <property>swift.common.internal_client.InternalClient.account_ring</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.auto_create_account_prefix">
              <term>
                <property>swift.common.internal_client.InternalClient.auto_create_account_prefix</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.container_exists">
              <term>
                <property>swift.common.internal_client.InternalClient.container_exists</property>
              </term>
              <listitem>
                <para>Checks to see if a container exists.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.container_ring">
              <term>
                <property>swift.common.internal_client.InternalClient.container_ring</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.create_container">
              <term>
                <property>swift.common.internal_client.InternalClient.create_container</property>
              </term>
              <listitem>
                <para>Creates container.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.delete_container">
              <term>
                <property>swift.common.internal_client.InternalClient.delete_container</property>
              </term>
              <listitem>
                <para>Deletes a container.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.delete_object">
              <term>
                <property>swift.common.internal_client.InternalClient.delete_object</property>
              </term>
              <listitem>
                <para>Deletes an object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.get_account_info">
              <term>
                <property>swift.common.internal_client.InternalClient.get_account_info</property>
              </term>
              <listitem>
                <para>Returns (container_count, object_count) for an account.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.get_account_metadata">
              <term>
                <property>swift.common.internal_client.InternalClient.get_account_metadata</property>
              </term>
              <listitem>
                <para>Gets account metadata.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.get_container_metadata">
              <term>
                <property>swift.common.internal_client.InternalClient.get_container_metadata</property>
              </term>
              <listitem>
                <para>Gets container metadata.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.get_object">
              <term>
                <property>swift.common.internal_client.InternalClient.get_object</property>
              </term>
              <listitem>
                <para>Returns a 3-tuple (status, headers, iterator of object body)</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.get_object_metadata">
              <term>
                <property>swift.common.internal_client.InternalClient.get_object_metadata</property>
              </term>
              <listitem>
                <para>Gets object metadata.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.get_object_ring">
              <term>
                <property>swift.common.internal_client.InternalClient.get_object_ring</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.iter_containers">
              <term>
                <property>swift.common.internal_client.InternalClient.iter_containers</property>
              </term>
              <listitem>
                <para>Returns an iterator of containers dicts from an account.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.iter_object_lines">
              <term>
                <property>swift.common.internal_client.InternalClient.iter_object_lines</property>
              </term>
              <listitem>
                <para>Returns an iterator of object lines from an uncompressed or compressed
                                text object.</para>
                <para>Uncompress object as it is read if the object’s name ends with ‘.gz’.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.iter_objects">
              <term>
                <property>swift.common.internal_client.InternalClient.iter_objects</property>
              </term>
              <listitem>
                <para>Returns an iterator of object dicts from a container.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.make_path">
              <term>
                <property>swift.common.internal_client.InternalClient.make_path</property>
              </term>
              <listitem>
                <para>Returns a swift path for a request quoting and utf-8 encoding the path
                                parts as need be.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.make_request">
              <term>
                <property>swift.common.internal_client.InternalClient.make_request</property>
              </term>
              <listitem>
                <para>Makes a request to Swift with retries.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.set_account_metadata">
              <term>
                <property>swift.common.internal_client.InternalClient.set_account_metadata</property>
              </term>
              <listitem>
                <para>Sets account metadata.  A call to this will add to the account
                                metadata and not overwrite all of it with values in the metadata dict.
                                To clear an account metadata value, pass an empty string as
                                the value for the key in the metadata dict.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.set_container_metadata">
              <term>
                <property>swift.common.internal_client.InternalClient.set_container_metadata</property>
              </term>
              <listitem>
                <para>Sets container metadata.  A call to this will add to the container
                                metadata and not overwrite all of it with values in the metadata dict.
                                To clear a container metadata value, pass an empty string as the value
                                for the key in the metadata dict.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.set_object_metadata">
              <term>
                <property>swift.common.internal_client.InternalClient.set_object_metadata</property>
              </term>
              <listitem>
                <para>Sets an object’s metadata.  The object’s metadata will be overwritten
                                by the values in the metadata dict.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.InternalClient.upload_object">
              <term>
                <property>swift.common.internal_client.InternalClient.upload_object</property>
              </term>
              <listitem/>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.internal_client.SimpleClient">
        <term>
          <literal>swift.common.internal_client.SimpleClient</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Simple client that is used in bin/swift-dispersion-* and container sync</para>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.SimpleClient.base_request">
              <term>
                <property>swift.common.internal_client.SimpleClient.base_request</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.SimpleClient.get_account">
              <term>
                <property>swift.common.internal_client.SimpleClient.get_account</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.SimpleClient.get_container">
              <term>
                <property>swift.common.internal_client.SimpleClient.get_container</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.SimpleClient.put_container">
              <term>
                <property>swift.common.internal_client.SimpleClient.put_container</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.SimpleClient.put_object">
              <term>
                <property>swift.common.internal_client.SimpleClient.put_object</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.internal_client.SimpleClient.retry_request">
              <term>
                <property>swift.common.internal_client.SimpleClient.retry_request</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.internal_client.UnexpectedResponse">
        <term>
          <literal>swift.common.internal_client.UnexpectedResponse</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
          <para>Exception raised on invalid responses to InternalClient.make_request().</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.internal_client.delete_object">
        <term>
          <function>swift.common.internal_client.delete_object</function>
        </term>
        <listitem>
          <para>For usage with container sync</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.internal_client.get_auth">
        <term>
          <function>swift.common.internal_client.get_auth</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.internal_client.head_object">
        <term>
          <function>swift.common.internal_client.head_object</function>
        </term>
        <listitem>
          <para>For usage with container sync</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.internal_client.put_object">
        <term>
          <function>swift.common.internal_client.put_object</function>
        </term>
        <listitem>
          <para>For usage with container sync</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Manager</title>
    <variablelist>
      <varlistentry xml:id="swift.common.manager.Manager">
        <term>
          <literal>swift.common.manager.Manager</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Main class for performing commands on groups of servers.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.force_reload">
              <term>
                <property>swift.common.manager.Manager.force_reload</property>
              </term>
              <listitem>
                <para>alias for reload</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.get_command">
              <term>
                <property>swift.common.manager.Manager.get_command</property>
              </term>
              <listitem>
                <para>Find and return the decorated method named like cmd</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.kill">
              <term>
                <property>swift.common.manager.Manager.kill</property>
              </term>
              <listitem>
                <para>stop a server (no error if not running)</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.list_commands">
              <term>
                <property>swift.common.manager.Manager.list_commands</property>
              </term>
              <listitem>
                <para>Get all publicly accessible commands</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.no_daemon">
              <term>
                <property>swift.common.manager.Manager.no_daemon</property>
              </term>
              <listitem>
                <para>start a server interactively</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.no_wait">
              <term>
                <property>swift.common.manager.Manager.no_wait</property>
              </term>
              <listitem>
                <para>spawn server and return immediately</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.once">
              <term>
                <property>swift.common.manager.Manager.once</property>
              </term>
              <listitem>
                <para>start server and run one pass on supporting daemons</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.reload">
              <term>
                <property>swift.common.manager.Manager.reload</property>
              </term>
              <listitem>
                <para>graceful shutdown then restart on supporting servers</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.restart">
              <term>
                <property>swift.common.manager.Manager.restart</property>
              </term>
              <listitem>
                <para>stops then restarts server</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.run_command">
              <term>
                <property>swift.common.manager.Manager.run_command</property>
              </term>
              <listitem>
                <para>Find the named command and run it</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.shutdown">
              <term>
                <property>swift.common.manager.Manager.shutdown</property>
              </term>
              <listitem>
                <para>allow current requests to finish on supporting servers</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.start">
              <term>
                <property>swift.common.manager.Manager.start</property>
              </term>
              <listitem>
                <para>starts a server</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.status">
              <term>
                <property>swift.common.manager.Manager.status</property>
              </term>
              <listitem>
                <para>display status of tracked pids for server</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Manager.stop">
              <term>
                <property>swift.common.manager.Manager.stop</property>
              </term>
              <listitem>
                <para>stops a server</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.manager.Server">
        <term>
          <literal>swift.common.manager.Server</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Manage operations on a server or group of servers of similar type</para>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.conf_files">
              <term>
                <property>swift.common.manager.Server.conf_files</property>
              </term>
              <listitem>
                <para>Get conf files for this server</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.get_conf_file_name">
              <term>
                <property>swift.common.manager.Server.get_conf_file_name</property>
              </term>
              <listitem>
                <para>Translate pid_file to a corresponding conf_file</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.get_pid_file_name">
              <term>
                <property>swift.common.manager.Server.get_pid_file_name</property>
              </term>
              <listitem>
                <para>Translate conf_file to a corresponding pid_file</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.get_running_pids">
              <term>
                <property>swift.common.manager.Server.get_running_pids</property>
              </term>
              <listitem>
                <para>Get running pids</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.interact">
              <term>
                <property>swift.common.manager.Server.interact</property>
              </term>
              <listitem>
                <para>wait on spawned procs to terminate</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.iter_pid_files">
              <term>
                <property>swift.common.manager.Server.iter_pid_files</property>
              </term>
              <listitem>
                <para>Generator, yields (pid_file, pids)</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.kill_running_pids">
              <term>
                <property>swift.common.manager.Server.kill_running_pids</property>
              </term>
              <listitem>
                <para>Kill running pids</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.launch">
              <term>
                <property>swift.common.manager.Server.launch</property>
              </term>
              <listitem>
                <para>Collect conf files and attempt to spawn the processes for this server</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.pid_files">
              <term>
                <property>swift.common.manager.Server.pid_files</property>
              </term>
              <listitem>
                <para>Get pid files for this server</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.signal_pids">
              <term>
                <property>swift.common.manager.Server.signal_pids</property>
              </term>
              <listitem>
                <para>Send a signal to pids for this server</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.spawn">
              <term>
                <property>swift.common.manager.Server.spawn</property>
              </term>
              <listitem>
                <para>Launch a subprocess for this server.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.status">
              <term>
                <property>swift.common.manager.Server.status</property>
              </term>
              <listitem>
                <para>Display status of server</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.stop">
              <term>
                <property>swift.common.manager.Server.stop</property>
              </term>
              <listitem>
                <para>Send stop signals to pids for this server</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.manager.Server.wait">
              <term>
                <property>swift.common.manager.Server.wait</property>
              </term>
              <listitem>
                <para>wait on spawned procs to start</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.manager.UnknownCommandError">
        <term>
          <literal>swift.common.manager.UnknownCommandError</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.manager.command">
        <term>
          <function>swift.common.manager.command</function>
        </term>
        <listitem>
          <para>Decorator to declare which methods are accessible as commands, commands
                        always return 1 or 0, where 0 should indicate success.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.manager.kill_group">
        <term>
          <function>swift.common.manager.kill_group</function>
        </term>
        <listitem>
          <para>Send signal to process group</para>
          <para>: param pid: process id
                        : param sig: signal to send</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.manager.safe_kill">
        <term>
          <function>swift.common.manager.safe_kill</function>
        </term>
        <listitem>
          <para>Send signal to process and check process name</para>
          <para>: param pid: process id
                        : param sig: signal to send
                        : param name: name to ensure target process</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.manager.setup_env">
        <term>
          <function>swift.common.manager.setup_env</function>
        </term>
        <listitem>
          <para>Try to increase resource limits of the OS. Move PYTHON_EGG_CACHE to /tmp</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.manager.watch_server_pids">
        <term>
          <function>swift.common.manager.watch_server_pids</function>
        </term>
        <listitem>
          <para>Monitor a collection of server pids yielding back those pids that
                        aren’t responding to signals.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>MemCacheD</title>
    <para>Why our own memcache client?
                By Michael Barton</para>
    <para>python-memcached doesn’t use consistent hashing, so adding or
                removing a memcache server from the pool invalidates a huge
                percentage of cached items.</para>
    <para>If you keep a pool of python-memcached client objects, each client
                object has its own connection to every memcached server, only one of
                which is ever in use.  So you wind up with n * m open sockets and
                almost all of them idle. This client effectively has a pool for each
                server, so the number of backend connections is hopefully greatly
                reduced.</para>
    <para>python-memcache uses pickle to store things, and there was already a
                huge stink about Swift using pickles in memcache
                (<link xlink:href="http://osvdb.org/show/osvdb/86581"/>).  That seemed sort of unfair,
                since nova and keystone and everyone else use pickles for memcache
                too, but it’s hidden behind a “standard” library. But changing would
                be a security regression at this point.</para>
    <para>Also, pylibmc wouldn’t work for us because it needs to use python
                sockets in order to play nice with eventlet.</para>
    <para>Lucid comes with memcached: v1.4.2.  Protocol documentation for that
                version is at:</para>
    <para>
      <link xlink:href="http://github.com/memcached/memcached/blob/1.4.2/doc/protocol.txt"/>
    </para>
    <variablelist>
      <varlistentry xml:id="swift.common.memcached.MemcacheConnPool">
        <term>
          <literal>swift.common.memcached.MemcacheConnPool</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.pools.Pool</literal></para>
          <para>Connection pool for Memcache Connections</para>
          <para>The <emphasis>server</emphasis> parameter can be a hostname, an IPv4 address, or an IPv6
                        address with an optional port. See
                        <xref linkend="swift.common.utils.parse_socket_string"/> for details.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.memcached.MemcacheConnPool.create">
              <term>
                <property>swift.common.memcached.MemcacheConnPool.create</property>
              </term>
              <listitem>
                <para>Generate a new pool item.  In order for the pool to
                                function, either this method must be overriden in a subclass
                                or the pool must be constructed with the <literal>create</literal> argument.
                                It accepts no arguments and returns a single instance of
                                whatever thing the pool is supposed to contain.</para>
                <para>In general, <xref linkend="swift.common.memcached.MemcacheConnPool.create"/> is called whenever the pool exceeds its
                                previous high-water mark of concurrently-checked-out-items.  In other
                                words, in a new pool with <emphasis>min_size</emphasis> of 0, the very first call
                                to <xref linkend="swift.common.memcached.MemcacheConnPool.get"/> will result in a call to <xref linkend="swift.common.memcached.MemcacheConnPool.create"/>.  If the first
                                caller calls <literal>put()</literal> before some other caller calls <xref linkend="swift.common.memcached.MemcacheConnPool.get"/>,
                                then the first item will be returned, and <xref linkend="swift.common.memcached.MemcacheConnPool.create"/> will not be
                                called a second time.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.memcached.MemcacheConnPool.get">
              <term>
                <property>swift.common.memcached.MemcacheConnPool.get</property>
              </term>
              <listitem>
                <para>Return an item from the pool, when one is available.  This may
                                cause the calling greenthread to block.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.memcached.MemcacheConnectionError">
        <term>
          <literal>swift.common.memcached.MemcacheConnectionError</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.memcached.MemcachePoolTimeout">
        <term>
          <literal>swift.common.memcached.MemcachePoolTimeout</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.timeout.Timeout</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.memcached.MemcacheRing">
        <term>
          <literal>swift.common.memcached.MemcacheRing</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Simple, consistent-hashed memcache client.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.memcached.MemcacheRing.decr">
              <term>
                <property>swift.common.memcached.MemcacheRing.decr</property>
              </term>
              <listitem>
                <para>Decrements a key which has a numeric value by delta. Calls incr with
                                -delta.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.memcached.MemcacheRing.delete">
              <term>
                <property>swift.common.memcached.MemcacheRing.delete</property>
              </term>
              <listitem>
                <para>Deletes a key/value pair from memcache.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.memcached.MemcacheRing.get">
              <term>
                <property>swift.common.memcached.MemcacheRing.get</property>
              </term>
              <listitem>
                <para>Gets the object specified by key.  It will also unserialize the object
                                before returning if it is serialized in memcache with JSON, or if it
                                is pickled and unpickling is allowed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.memcached.MemcacheRing.get_multi">
              <term>
                <property>swift.common.memcached.MemcacheRing.get_multi</property>
              </term>
              <listitem>
                <para>Gets multiple values from memcache for the given keys.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.memcached.MemcacheRing.incr">
              <term>
                <property>swift.common.memcached.MemcacheRing.incr</property>
              </term>
              <listitem>
                <para>Increments a key which has a numeric value by delta.
                                If the key can’t be found, it’s added as delta or 0 if delta &lt; 0.
                                If passed a negative number, will use memcached’s decr. Returns
                                the int stored in memcached
                                Note: The data memcached stores as the result of incr/decr is
                                an unsigned int.  decr’s that result in a number below 0 are
                                stored as 0.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.memcached.MemcacheRing.set">
              <term>
                <property>swift.common.memcached.MemcacheRing.set</property>
              </term>
              <listitem>
                <para>Set a key/value pair in memcache</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.memcached.MemcacheRing.set_multi">
              <term>
                <property>swift.common.memcached.MemcacheRing.set_multi</property>
              </term>
              <listitem>
                <para>Sets multiple key/value pairs in memcache.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.memcached.sanitize_timeout">
        <term>
          <function>swift.common.memcached.sanitize_timeout</function>
        </term>
        <listitem>
          <para>Sanitize a timeout value to use an absolute expiration time if the delta
                        is greater than 30 days (in seconds). Note that the memcached server
                        translates negative values to mean a delta of 30 days in seconds (and 1
                        additional second), client beware.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Request Helpers</title>
    <para>Miscellaneous utility functions for use in generating responses.</para>
    <para>Why not swift.common.utils, you ask? Because this way we can import things
                from swob in here without creating circular imports.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.SegmentedIterable">
        <term>
          <literal>swift.common.request_helpers.SegmentedIterable</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Iterable that returns the object contents for a large object.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.request_helpers.SegmentedIterable.app_iter_range">
              <term>
                <property>swift.common.request_helpers.SegmentedIterable.app_iter_range</property>
              </term>
              <listitem>
                <para>swob.Response will only respond with a 206 status in certain cases; one
                                of those is if the body iterator responds to .app_iter_range().</para>
                <para>However, this object (or really, its listing iter) is smart enough to
                                handle the range stuff internally, so we just no-op this out for swob.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.request_helpers.SegmentedIterable.app_iter_ranges">
              <term>
                <property>swift.common.request_helpers.SegmentedIterable.app_iter_ranges</property>
              </term>
              <listitem>
                <para>This method assumes that iter(self) yields all the data bytes that
                                go into the response, but none of the MIME stuff. For example, if
                                the response will contain three MIME docs with data “abcd”, “efgh”,
                                and “ijkl”, then iter(self) will give out the bytes “abcdefghijkl”.</para>
                <para>This method inserts the MIME stuff around the data bytes.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.request_helpers.SegmentedIterable.close">
              <term>
                <property>swift.common.request_helpers.SegmentedIterable.close</property>
              </term>
              <listitem>
                <para>Called when the client disconnect. Ensure that the connection to the
                                backend server is closed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.request_helpers.SegmentedIterable.validate_first_segment">
              <term>
                <property>swift.common.request_helpers.SegmentedIterable.validate_first_segment</property>
              </term>
              <listitem>
                <para>Start fetching object data to ensure that the first segment (if any) is
                                valid. This is to catch cases like “first segment is missing” or
                                “first segment’s etag doesn’t match manifest”.</para>
                <para>Note: this does not validate that you have any segments. A
                                zero-segment large object is not erroneous; it is just empty.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.copy_header_subset">
        <term>
          <function>swift.common.request_helpers.copy_header_subset</function>
        </term>
        <listitem>
          <para>Will copy desired subset of headers from from_r to to_r.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.get_listing_content_type">
        <term>
          <function>swift.common.request_helpers.get_listing_content_type</function>
        </term>
        <listitem>
          <para>Determine the content type to use for an account or container listing
                        response.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.get_name_and_placement">
        <term>
          <function>swift.common.request_helpers.get_name_and_placement</function>
        </term>
        <listitem>
          <para>Utility function to split and validate the request path and storage
                        policy.  The storage policy index is extracted from the headers of
                        the request and converted to a StoragePolicy instance.  The
                        remaining args are passed through to
                        <xref linkend="swift.common.request_helpers.split_and_validate_path"/>.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.get_object_transient_sysmeta">
        <term>
          <function>swift.common.request_helpers.get_object_transient_sysmeta</function>
        </term>
        <listitem>
          <para>Returns the Object Transient System Metadata header for key.
                        The Object Transient System Metadata namespace will be persisted by
                        backend object servers. These headers are treated in the same way as
                        object user metadata i.e. all headers in this namespace will be
                        replaced on every POST request.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.get_param">
        <term>
          <function>swift.common.request_helpers.get_param</function>
        </term>
        <listitem>
          <para>Get parameters from an HTTP request ensuring proper handling UTF-8
                        encoding.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.get_sys_meta_prefix">
        <term>
          <function>swift.common.request_helpers.get_sys_meta_prefix</function>
        </term>
        <listitem>
          <para>Returns the prefix for system metadata headers for given server type.</para>
          <para>This prefix defines the namespace for headers that will be persisted
                        by backend servers.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.get_user_meta_prefix">
        <term>
          <function>swift.common.request_helpers.get_user_meta_prefix</function>
        </term>
        <listitem>
          <para>Returns the prefix for user metadata headers for given server type.</para>
          <para>This prefix defines the namespace for headers that will be persisted
                        by backend servers.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.http_response_to_document_iters">
        <term>
          <function>swift.common.request_helpers.http_response_to_document_iters</function>
        </term>
        <listitem>
          <para>Takes a successful object-GET HTTP response and turns it into an
                        iterator of (first-byte, last-byte, length, headers, body-file)
                        5-tuples.</para>
          <para>The response must either be a 200 or a 206; if you feed in a 204 or
                        something similar, this probably won’t work.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.is_object_transient_sysmeta">
        <term>
          <function>swift.common.request_helpers.is_object_transient_sysmeta</function>
        </term>
        <listitem>
          <para>Tests if a header key starts with and is longer than the prefix for object
                        transient system metadata.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.is_sys_meta">
        <term>
          <function>swift.common.request_helpers.is_sys_meta</function>
        </term>
        <listitem>
          <para>Tests if a header key starts with and is longer than the system
                        metadata prefix for given server type.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.is_sys_or_user_meta">
        <term>
          <function>swift.common.request_helpers.is_sys_or_user_meta</function>
        </term>
        <listitem>
          <para>Tests if a header key starts with and is longer than the user or system
                        metadata prefix for given server type.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.is_user_meta">
        <term>
          <function>swift.common.request_helpers.is_user_meta</function>
        </term>
        <listitem>
          <para>Tests if a header key starts with and is longer than the user
                        metadata prefix for given server type.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.remove_items">
        <term>
          <function>swift.common.request_helpers.remove_items</function>
        </term>
        <listitem>
          <para>Removes items from a dict whose keys satisfy
                        the given condition.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.resolve_etag_is_at_header">
        <term>
          <function>swift.common.request_helpers.resolve_etag_is_at_header</function>
        </term>
        <listitem>
          <para>Helper function to resolve an alternative etag value that may be stored in
                        metadata under an alternate name.</para>
          <para>The value of the request’s X-Backend-Etag-Is-At header (if it exists) is a
                        comma separated list of alternate names in the metadata at which an
                        alternate etag value may be found. This list is processed in order until an
                        alternate etag is found.</para>
          <para>The left most value in X-Backend-Etag-Is-At will have been set by the left
                        most middleware, or if no middleware, by ECObjectController, if an EC
                        policy is in use. The left most middleware is assumed to be the authority
                        on what the etag value of the object content is.</para>
          <para>The resolver will work from left to right in the list until it finds a
                        value that is a name in the given metadata. So the left most wins, IF it
                        exists in the metadata.</para>
          <para>By way of example, assume the encrypter middleware is installed. If an
                        object is <emphasis>not</emphasis> encrypted then the resolver will not find the encrypter
                        middleware’s alternate etag sysmeta (X-Object-Sysmeta-Crypto-Etag) but will
                        then find the EC alternate etag (if EC policy). But if the object <emphasis>is</emphasis>
                        encrypted then X-Object-Sysmeta-Crypto-Etag is found and used, which is
                        correct because it should be preferred over X-Object-Sysmeta-Crypto-Etag.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.split_and_validate_path">
        <term>
          <function>swift.common.request_helpers.split_and_validate_path</function>
        </term>
        <listitem>
          <para>Utility function to split and validate the request path.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.strip_object_transient_sysmeta_prefix">
        <term>
          <function>swift.common.request_helpers.strip_object_transient_sysmeta_prefix</function>
        </term>
        <listitem>
          <para>Removes the object transient system metadata prefix from the start of a
                        header key.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.strip_sys_meta_prefix">
        <term>
          <function>swift.common.request_helpers.strip_sys_meta_prefix</function>
        </term>
        <listitem>
          <para>Removes the system metadata prefix for a given server type from the start
                        of a header key.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.strip_user_meta_prefix">
        <term>
          <function>swift.common.request_helpers.strip_user_meta_prefix</function>
        </term>
        <listitem>
          <para>Removes the user metadata prefix for a given server type from the start
                        of a header key.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.request_helpers.update_etag_is_at_header">
        <term>
          <function>swift.common.request_helpers.update_etag_is_at_header</function>
        </term>
        <listitem>
          <para>Helper function to update an X-Backend-Etag-Is-At header whose value is a
                        list of alternative header names at which the actual object etag may be
                        found. This informs the object server where to look for the actual object
                        etag when processing conditional requests.</para>
          <para>Since the proxy server and/or middleware may set alternative etag header
                        names, the value of X-Backend-Etag-Is-At is a comma separated list which
                        the object server inspects in order until it finds an etag value.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Swob</title>
    <para>Implementation of WSGI Request and Response objects.</para>
    <para>This library has a very similar API to Webob.  It wraps WSGI request
                environments and response values into objects that are more friendly to
                interact with.</para>
    <para>Why Swob and not just use WebOb?
                By Michael Barton</para>
    <para>We used webob for years. The main problem was that the interface
                wasn’t stable. For a while, each of our several test suites required
                a slightly different version of webob to run, and none of them worked
                with the then-current version. It was a huge headache, so we just
                scrapped it.</para>
    <para>This is kind of a ton of code, but it’s also been a huge relief to
                not have to scramble to add a bunch of code branches all over the
                place to keep Swift working every time webob decides some interface
                needs to change.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.Accept">
        <term>
          <literal>swift.common.swob.Accept</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Wraps a Request’s Accept header as a friendly object.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Accept.best_match">
              <term>
                <property>swift.common.swob.Accept.best_match</property>
              </term>
              <listitem>
                <para>Returns the item from “options” that best matches the accept header.
                                Returns None if no available options are acceptable to the client.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.HTTPException">
        <term>
          <literal>swift.common.swob.HTTPException</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.swob.Response"/>, <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.HeaderEnvironProxy">
        <term>
          <literal>swift.common.swob.HeaderEnvironProxy</literal>
        </term>
        <listitem>
          <para>Bases: <literal>collections.abc.MutableMapping</literal></para>
          <para>A dict-like object that proxies requests to a wsgi environ,
                        rewriting header keys to environ keys.</para>
          <para>For example, headers[‘Content-Range’] sets and gets the value of
                        headers.environ[‘HTTP_CONTENT_RANGE’]</para>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.HeaderEnvironProxy.keys">
              <term>
                <property>swift.common.swob.HeaderEnvironProxy.keys</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.Match">
        <term>
          <literal>swift.common.swob.Match</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Wraps a Request’s If-[None-]Match header as a friendly object.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.Range">
        <term>
          <literal>swift.common.swob.Range</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Wraps a Request’s Range header as a friendly object.
                        After initialization, “range.ranges” is populated with a list
                        of (start, end) tuples denoting the requested ranges.</para>
          <para>If there were any syntactically-invalid byte-range-spec values, the
                        constructor will raise a ValueError, per the relevant RFC:</para>
          <para>“The recipient of a byte-range-set that includes one or more syntactically
                        invalid byte-range-spec values MUST ignore the header field that includes
                        that byte-range-set.”</para>
          <para>According to the RFC 2616 specification, the following cases will be all
                        considered as syntactically invalid, thus, a ValueError is thrown so that
                        the range header will be ignored. If the range value contains at least
                        one of the following cases, the entire range is considered invalid,
                        ValueError will be thrown so that the header will be ignored.</para>
          <procedure>
            <step>
              <para>value not starts with bytes=</para>
            </step>
            <step>
              <para>range value start is greater than the end, eg. bytes=5-3</para>
            </step>
            <step>
              <para>range does not have start or end, eg. bytes=-</para>
            </step>
            <step>
              <para>range does not have hyphen, eg. bytes=45</para>
            </step>
            <step>
              <para>range value is non numeric</para>
            </step>
            <step>
              <para>any combination of the above</para>
            </step>
          </procedure>
          <para>Every syntactically valid range will be added into the ranges list
                        even when some of the ranges may not be satisfied by underlying content.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Range.ranges_for_length">
              <term>
                <property>swift.common.swob.Range.ranges_for_length</property>
              </term>
              <listitem>
                <para>This method is used to return multiple ranges for a given length
                                which should represent the length of the underlying content.
                                The constructor method __init__ made sure that any range in ranges
                                list is syntactically valid. So if length is None or size of the
                                ranges is zero, then the Range header should be ignored which will
                                eventually make the response to be 200.</para>
                <para>If an empty list is returned by this method, it indicates that there
                                are unsatisfiable ranges found in the Range header, 416 will be
                                returned.</para>
                <para>if a returned list has at least one element, the list indicates that
                                there is at least one range valid and the server should serve the
                                request with a 206 status code.</para>
                <para>The start value of each range represents the starting position in
                                the content, the end value represents the ending position. This
                                method purposely adds 1 to the end number because the spec defines
                                the Range to be inclusive.</para>
                <para>The Range spec can be found at the following link:
                                <link xlink:href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.Request">
        <term>
          <literal>swift.common.swob.Request</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>WSGI Request object.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.accept">
              <term>
                <property>swift.common.swob.Request.accept</property>
              </term>
              <listitem>
                <para>Retrieve and set the accept property in the WSGI environ, as a Accept object</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.acl">
              <term>
                <property>swift.common.swob.Request.acl</property>
              </term>
              <listitem>
                <para>Get and set the swob.ACL property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.blank">
              <term>
                <property>swift.common.swob.Request.blank</property>
              </term>
              <listitem>
                <para>Create a new request object with the given parameters, and an
                                environment otherwise filled in with non-surprising default values.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.body">
              <term>
                <property>swift.common.swob.Request.body</property>
              </term>
              <listitem>
                <para>Get and set the request body str</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.body_file">
              <term>
                <property>swift.common.swob.Request.body_file</property>
              </term>
              <listitem>
                <para>Get and set the wsgi.input property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.call_application">
              <term>
                <property>swift.common.swob.Request.call_application</property>
              </term>
              <listitem>
                <para>Calls the application with this request’s environment.  Returns the
                                status, headers, and app_iter for the response as a tuple.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.content_length">
              <term>
                <property>swift.common.swob.Request.content_length</property>
              </term>
              <listitem>
                <para>Retrieve and set the content-length header as an int</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.copy_get">
              <term>
                <property>swift.common.swob.Request.copy_get</property>
              </term>
              <listitem>
                <para>Makes a copy of the request, converting it to a GET.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.get_response">
              <term>
                <property>swift.common.swob.Request.get_response</property>
              </term>
              <listitem>
                <para>Calls the application with this request’s environment.  Returns a
                                Response object that wraps up the application’s result.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.host">
              <term>
                <property>swift.common.swob.Request.host</property>
              </term>
              <listitem>
                <para>Get and set the HTTP_HOST property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.host_url">
              <term>
                <property>swift.common.swob.Request.host_url</property>
              </term>
              <listitem>
                <para>Get url for request/response up to path</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.if_match">
              <term>
                <property>swift.common.swob.Request.if_match</property>
              </term>
              <listitem>
                <para>Retrieve and set the if-match property in the WSGI environ, as a Match object</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.if_modified_since">
              <term>
                <property>swift.common.swob.Request.if_modified_since</property>
              </term>
              <listitem>
                <para>Retrieve and set the if-modified-since header as a datetime, set it with a datetime, int, or str</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.if_none_match">
              <term>
                <property>swift.common.swob.Request.if_none_match</property>
              </term>
              <listitem>
                <para>Retrieve and set the if-none-match property in the WSGI environ, as a Match object</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.if_unmodified_since">
              <term>
                <property>swift.common.swob.Request.if_unmodified_since</property>
              </term>
              <listitem>
                <para>Retrieve and set the if-unmodified-since header as a datetime, set it with a datetime, int, or str</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.message_length">
              <term>
                <property>swift.common.swob.Request.message_length</property>
              </term>
              <listitem>
                <para>Properly determine the message length for this request. It will return
                                an integer if the headers explicitly contain the message length, or
                                None if the headers don’t contain a length. The ValueError exception
                                will be raised if the headers are invalid.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.method">
              <term>
                <property>swift.common.swob.Request.method</property>
              </term>
              <listitem>
                <para>Get and set the REQUEST_METHOD property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.params">
              <term>
                <property>swift.common.swob.Request.params</property>
              </term>
              <listitem>
                <para>Provides QUERY_STRING parameters as a dictionary</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.path">
              <term>
                <property>swift.common.swob.Request.path</property>
              </term>
              <listitem>
                <para>Provides the full path of the request, excluding the QUERY_STRING</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.path_info">
              <term>
                <property>swift.common.swob.Request.path_info</property>
              </term>
              <listitem>
                <para>Get and set the PATH_INFO property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.path_info_pop">
              <term>
                <property>swift.common.swob.Request.path_info_pop</property>
              </term>
              <listitem>
                <para>Takes one path portion (delineated by slashes) from the
                                path_info, and appends it to the script_name.  Returns
                                the path segment.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.path_qs">
              <term>
                <property>swift.common.swob.Request.path_qs</property>
              </term>
              <listitem>
                <para>The path of the request, without host but with query string.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.query_string">
              <term>
                <property>swift.common.swob.Request.query_string</property>
              </term>
              <listitem>
                <para>Get and set the QUERY_STRING property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.range">
              <term>
                <property>swift.common.swob.Request.range</property>
              </term>
              <listitem>
                <para>Retrieve and set the range property in the WSGI environ, as a Range object</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.referer">
              <term>
                <property>swift.common.swob.Request.referer</property>
              </term>
              <listitem>
                <para>Get and set the HTTP_REFERER property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.referrer">
              <term>
                <property>swift.common.swob.Request.referrer</property>
              </term>
              <listitem>
                <para>Get and set the HTTP_REFERER property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.remote_addr">
              <term>
                <property>swift.common.swob.Request.remote_addr</property>
              </term>
              <listitem>
                <para>Get and set the REMOTE_ADDR property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.remote_user">
              <term>
                <property>swift.common.swob.Request.remote_user</property>
              </term>
              <listitem>
                <para>Get and set the REMOTE_USER property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.script_name">
              <term>
                <property>swift.common.swob.Request.script_name</property>
              </term>
              <listitem>
                <para>Get and set the SCRIPT_NAME property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.split_path">
              <term>
                <property>swift.common.swob.Request.split_path</property>
              </term>
              <listitem>
                <para>Validate and split the Request’s path.</para>
                <para><emphasis role="bold">Examples</emphasis>:</para>
                <screen>['a'] = split_path('/a')
['a', None] = split_path('/a', 1, 2)
['a', 'c'] = split_path('/a/c', 1, 2)
['a', 'c', 'o/r'] = split_path('/a/c/o/r', 1, 3, True)</screen>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.str_params">
              <term>
                <property>swift.common.swob.Request.str_params</property>
              </term>
              <listitem>
                <para>Provides QUERY_STRING parameters as a dictionary</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.swift_entity_path">
              <term>
                <property>swift.common.swob.Request.swift_entity_path</property>
              </term>
              <listitem>
                <para>Provides the account/container/object path, sans API version.</para>
                <para>This can be useful when constructing a path to send to a backend
                                server, as that path will need everything after the “/v1”.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.timestamp">
              <term>
                <property>swift.common.swob.Request.timestamp</property>
              </term>
              <listitem>
                <para>Provides HTTP_X_TIMESTAMP as a <xref linkend="swift.common.utils.Timestamp"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.url">
              <term>
                <property>swift.common.swob.Request.url</property>
              </term>
              <listitem>
                <para>Provides the full url of the request</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Request.user_agent">
              <term>
                <property>swift.common.swob.Request.user_agent</property>
              </term>
              <listitem>
                <para>Get and set the HTTP_USER_AGENT property in the WSGI environment</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.Response">
        <term>
          <literal>swift.common.swob.Response</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>WSGI Response object.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.__call__">
              <term>
                <property>swift.common.swob.Response.__call__</property>
              </term>
              <listitem>
                <para>Respond to the WSGI request.</para>
                <warning>
                  <para>This will translate any relative Location header value to an
                                    absolute URL using the WSGI environment’s HOST_URL as a
                                    prefix, as RFC 2616 specifies.</para>
                  <para>However, it is quite common to use relative redirects,
                                    especially when it is difficult to know the exact HOST_URL
                                    the browser would have used when behind several CNAMEs, CDN
                                    services, etc. All modern browsers support relative
                                    redirects.</para>
                  <para>To skip over RFC enforcement of the Location header value,
                                    you may set <literal>env['swift.leave_relative_location'] = True</literal>
                                    in the WSGI environment.</para>
                </warning>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.absolute_location">
              <term>
                <property>swift.common.swob.Response.absolute_location</property>
              </term>
              <listitem>
                <para>Attempt to construct an absolute location.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.accept_ranges">
              <term>
                <property>swift.common.swob.Response.accept_ranges</property>
              </term>
              <listitem>
                <para>Retrieve and set the accept-ranges header</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.app_iter">
              <term>
                <property>swift.common.swob.Response.app_iter</property>
              </term>
              <listitem>
                <para>Retrieve and set the response app_iter</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.body">
              <term>
                <property>swift.common.swob.Response.body</property>
              </term>
              <listitem>
                <para>Retrieve and set the Response body str</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.charset">
              <term>
                <property>swift.common.swob.Response.charset</property>
              </term>
              <listitem>
                <para>Retrieve and set the response charset</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.conditional_etag">
              <term>
                <property>swift.common.swob.Response.conditional_etag</property>
              </term>
              <listitem>
                <para>The conditional_etag keyword argument for Response will allow the
                                conditional match value of a If-Match request to be compared to a
                                non-standard value.</para>
                <para>This is available for Storage Policies that do not store the client
                                object data verbatim on the storage nodes, but still need support
                                conditional requests.</para>
                <para>It’s most effectively used with X-Backend-Etag-Is-At which would
                                define the additional Metadata key(s) where the original ETag of the
                                clear-form client request data may be found.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.content_length">
              <term>
                <property>swift.common.swob.Response.content_length</property>
              </term>
              <listitem>
                <para>Retrieve and set the content-length header as an int</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.content_range">
              <term>
                <property>swift.common.swob.Response.content_range</property>
              </term>
              <listitem>
                <para>Retrieve and set the content-range header</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.content_type">
              <term>
                <property>swift.common.swob.Response.content_type</property>
              </term>
              <listitem>
                <para>Retrieve and set the response Content-Type header</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.etag">
              <term>
                <property>swift.common.swob.Response.etag</property>
              </term>
              <listitem>
                <para>Retrieve and set the response Etag header</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.fix_conditional_response">
              <term>
                <property>swift.common.swob.Response.fix_conditional_response</property>
              </term>
              <listitem>
                <para>You may call this once you have set the content_length to the whole
                                object length and body or app_iter to reset the content_length
                                properties on the request.</para>
                <para>It is ok to not call this method, the conditional response will be
                                maintained for you when you __call__ the response.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.host_url">
              <term>
                <property>swift.common.swob.Response.host_url</property>
              </term>
              <listitem>
                <para>Get url for request/response up to path</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.last_modified">
              <term>
                <property>swift.common.swob.Response.last_modified</property>
              </term>
              <listitem>
                <para>Retrieve and set the last-modified header as a datetime, set it with a datetime, int, or str</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.location">
              <term>
                <property>swift.common.swob.Response.location</property>
              </term>
              <listitem>
                <para>Retrieve and set the location header</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.status">
              <term>
                <property>swift.common.swob.Response.status</property>
              </term>
              <listitem>
                <para>Retrieve and set the Response status, e.g. ‘200 OK’</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.swob.Response.www_authenticate">
              <term>
                <property>swift.common.swob.Response.www_authenticate</property>
              </term>
              <listitem>
                <para>Construct a suitable value for WWW-Authenticate response header</para>
                <para>If we have a request and a valid-looking path, the realm
                                is the account; otherwise we set it to ‘unknown’.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.StatusMap">
        <term>
          <literal>swift.common.swob.StatusMap</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>A dict-like object that returns HTTPException subclasses/factory functions
                        where the given key is the status code.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.WsgiBytesIO">
        <term>
          <literal>swift.common.swob.WsgiBytesIO</literal>
        </term>
        <listitem>
          <para>Bases: <literal>_io.BytesIO</literal></para>
          <para>This class adds support for the additional wsgi.input methods defined on
                        eventlet.wsgi.Input to the BytesIO class which would otherwise be a fine
                        stand-in for the file-like object in the WSGI environment.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.swob.wsgify">
        <term>
          <function>swift.common.swob.wsgify</function>
        </term>
        <listitem>
          <para>A decorator for translating functions which take a swob Request object and
                        return a Response object into WSGI callables.  Also catches any raised
                        HTTPExceptions and treats them as a returned Response.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Utils</title>
    <para>Miscellaneous utility functions for use with Swift.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.ATTRIBUTES_RE">
        <term>
          <literal>swift.common.utils.ATTRIBUTES_RE</literal>
        </term>
        <listitem>
          <para>Regular expression to match form attributes.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.CloseableChain">
        <term>
          <literal>swift.common.utils.CloseableChain</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Like itertools.chain, but with a close method that will attempt to invoke
                        its sub-iterators’ close methods, if any.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.ContextPool">
        <term>
          <literal>swift.common.utils.ContextPool</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.greenpool.GreenPool</literal></para>
          <para>GreenPool subclassed to kill its coros when it gets gc’ed</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.GreenAsyncPile">
        <term>
          <literal>swift.common.utils.GreenAsyncPile</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Runs jobs in a pool of green threads, and the results can be retrieved by
                        using this object as an iterator.</para>
          <para>This is very similar in principle to eventlet.GreenPile, except it returns
                        results as they become available rather than in the order they were
                        launched.</para>
          <para>Correlating results with jobs (if necessary) is left to the caller.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.GreenAsyncPile.spawn">
              <term>
                <property>swift.common.utils.GreenAsyncPile.spawn</property>
              </term>
              <listitem>
                <para>Spawn a job in a green thread on the pile.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.GreenAsyncPile.waitall">
              <term>
                <property>swift.common.utils.GreenAsyncPile.waitall</property>
              </term>
              <listitem>
                <para>Wait timeout seconds for any results to come in.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.GreenAsyncPile.waitfirst">
              <term>
                <property>swift.common.utils.GreenAsyncPile.waitfirst</property>
              </term>
              <listitem>
                <para>Wait up to timeout seconds for first result to come in.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.GreenAsyncPileWaitallTimeout">
        <term>
          <literal>swift.common.utils.GreenAsyncPileWaitallTimeout</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.timeout.Timeout</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.GreenthreadSafeIterator">
        <term>
          <literal>swift.common.utils.GreenthreadSafeIterator</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Wrap an iterator to ensure that only one greenthread is inside its next()
                        method at a time.</para>
          <para>This is useful if an iterator’s next() method may perform network IO, as
                        that may trigger a greenthread context switch (aka trampoline), which can
                        give another greenthread a chance to call next(). At that point, you get
                        an error like “ValueError: generator already executing”. By wrapping calls
                        to next() with a mutex, we avoid that error.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.InputProxy">
        <term>
          <literal>swift.common.utils.InputProxy</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>File-like object that counts bytes read.
                        To be swapped in for wsgi.input for accounting purposes.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.InputProxy.read">
              <term>
                <property>swift.common.utils.InputProxy.read</property>
              </term>
              <listitem>
                <para>Pass read request to the underlying file-like object and
                                add bytes read to total.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.InputProxy.readline">
              <term>
                <property>swift.common.utils.InputProxy.readline</property>
              </term>
              <listitem>
                <para>Pass readline request to the underlying file-like object and
                                add bytes read to total.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.InvalidHashPathConfigError">
        <term>
          <literal>swift.common.utils.InvalidHashPathConfigError</literal>
        </term>
        <listitem>
          <para>Bases: <literal>ValueError</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.LRUCache">
        <term>
          <literal>swift.common.utils.LRUCache</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Decorator for size/time bound memoization that evicts the least
                        recently used members.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.LogAdapter">
        <term>
          <literal>swift.common.utils.LogAdapter</literal>
        </term>
        <listitem>
          <para>Bases: <literal>logging.LoggerAdapter</literal>, <literal>object</literal></para>
          <para>A Logger like object which performs some reformatting on calls to
                        <xref linkend="swift.common.utils.LogAdapter.exception"/>.  Can be used to store a threadlocal transaction id and
                        client ip.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.LogAdapter.exception">
              <term>
                <property>swift.common.utils.LogAdapter.exception</property>
              </term>
              <listitem>
                <para>Delegate an exception call to the underlying logger.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.LogAdapter.getEffectiveLevel">
              <term>
                <property>swift.common.utils.LogAdapter.getEffectiveLevel</property>
              </term>
              <listitem>
                <para>Get the effective level for the underlying logger.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.LogAdapter.notice">
              <term>
                <property>swift.common.utils.LogAdapter.notice</property>
              </term>
              <listitem>
                <para>Convenience function for syslog priority LOG_NOTICE. The python
                                logging lvl is set to 25, just above info.  SysLogHandler is
                                monkey patched to map this log lvl to the LOG_NOTICE syslog
                                priority.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.LogAdapter.process">
              <term>
                <property>swift.common.utils.LogAdapter.process</property>
              </term>
              <listitem>
                <para>Add extra info to message</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.LogAdapter.set_statsd_prefix">
              <term>
                <property>swift.common.utils.LogAdapter.set_statsd_prefix</property>
              </term>
              <listitem>
                <para>The StatsD client prefix defaults to the “name” of the logger.  This
                                method may override that default with a specific value.  Currently used
                                in the proxy-server to differentiate the Account, Container, and Object
                                controllers.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.LogAdapter.statsd_delegate">
              <term>
                <property>swift.common.utils.LogAdapter.statsd_delegate</property>
              </term>
              <listitem>
                <para>Factory to create methods which delegate to methods on
                                self.logger.statsd_client (an instance of StatsdClient).  The
                                created methods conditionally delegate to a method whose name is given
                                in ‘statsd_func_name’.  The created delegate methods are a no-op when
                                StatsD logging is not configured.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.ModifiedParseResult">
        <term>
          <literal>swift.common.utils.ModifiedParseResult</literal>
        </term>
        <listitem>
          <para>Bases: <literal>urllib.parse.ParseResult</literal></para>
          <para>Parse results class for urlparse.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.NR_ioprio_set">
        <term>
          <function>swift.common.utils.NR_ioprio_set</function>
        </term>
        <listitem>
          <para>Give __NR_ioprio_set value for your system.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.NullLogger">
        <term>
          <literal>swift.common.utils.NullLogger</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>A no-op logger for eventlet wsgi.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.PipeMutex">
        <term>
          <literal>swift.common.utils.PipeMutex</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Mutex using a pipe. Works across both greenlets and real threads, even
                        at the same time.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.PipeMutex.acquire">
              <term>
                <property>swift.common.utils.PipeMutex.acquire</property>
              </term>
              <listitem>
                <para>Acquire the mutex.</para>
                <para>If called with blocking=False, returns True if the mutex was
                                acquired and False if it wasn’t. Otherwise, blocks until the mutex
                                is acquired and returns True.</para>
                <para>This lock is recursive; the same greenthread may acquire it as many
                                times as it wants to, though it must then release it that many times
                                too.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.PipeMutex.close">
              <term>
                <property>swift.common.utils.PipeMutex.close</property>
              </term>
              <listitem>
                <para>Close the mutex. This releases its file descriptors.</para>
                <para>You can’t use a mutex after it’s been closed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.PipeMutex.release">
              <term>
                <property>swift.common.utils.PipeMutex.release</property>
              </term>
              <listitem>
                <para>Release the mutex.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.RateLimitedIterator">
        <term>
          <literal>swift.common.utils.RateLimitedIterator</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Wrap an iterator to only yield elements at a rate of N per second.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.Spliterator">
        <term>
          <literal>swift.common.utils.Spliterator</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Takes an iterator yielding sliceable things (e.g. strings or lists) and
                        yields subiterators, each yielding up to the requested number of items
                        from the source.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.StreamingPile">
        <term>
          <literal>swift.common.utils.StreamingPile</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.utils.GreenAsyncPile"/></para>
          <para>Runs jobs in a pool of green threads, spawning more jobs as results are
                        retrieved and worker threads become available.</para>
          <para>When used as a context manager, has the same worker-killing properties as
                        <xref linkend="swift.common.utils.ContextPool"/>.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.StreamingPile.asyncstarmap">
              <term>
                <property>swift.common.utils.StreamingPile.asyncstarmap</property>
              </term>
              <listitem>
                <para>This is the same as <literal>itertools.starmap()</literal>, except that <emphasis>func</emphasis> is
                                executed in a separate green thread for each item, and results won’t
                                necessarily have the same order as inputs.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.SwiftLogFormatter">
        <term>
          <literal>swift.common.utils.SwiftLogFormatter</literal>
        </term>
        <listitem>
          <para>Bases: <literal>logging.Formatter</literal></para>
          <para>Custom logging.Formatter will append txn_id to a log message if the
                        record has one and the message does not. Optionally it can shorten
                        overly long log lines.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.SwiftLogFormatter.format">
              <term>
                <property>swift.common.utils.SwiftLogFormatter.format</property>
              </term>
              <listitem>
                <para>Format the specified record as text.</para>
                <para>The record’s attribute dictionary is used as the operand to a
                                string formatting operation which yields the returned string.
                                Before formatting the dictionary, a couple of preparatory steps
                                are carried out. The message attribute of the record is computed
                                using LogRecord.getMessage(). If the formatting string uses the
                                time (as determined by a call to usesTime(), formatTime() is
                                called to format the event time. If there is exception information,
                                it is formatted using formatException() and appended to the message.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.ThreadSafeSysLogHandler">
        <term>
          <literal>swift.common.utils.ThreadSafeSysLogHandler</literal>
        </term>
        <listitem>
          <para>Bases: <literal>logging.handlers.SysLogHandler</literal></para>
          <variablelist>
            <varlistentry xml:id="swift.common.utils.ThreadSafeSysLogHandler.createLock">
              <term>
                <property>swift.common.utils.ThreadSafeSysLogHandler.createLock</property>
              </term>
              <listitem>
                <para>Acquire a thread lock for serializing access to the underlying I/O.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.Timestamp">
        <term>
          <literal>swift.common.utils.Timestamp</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Internal Representation of Swift Time.</para>
          <para>The normalized form of the X-Timestamp header looks like a float
                        with a fixed width to ensure stable string sorting - normalized
                        timestamps look like “1402464677.04188”</para>
          <para>To support overwrites of existing data without modifying the original
                        timestamp but still maintain consistency a second internal offset vector
                        is append to the normalized timestamp form which compares and sorts
                        greater than the fixed width float format but less than a newer timestamp.
                        The internalized format of timestamps looks like
                        “1402464677.04188_0000000000000000” - the portion after the underscore is
                        the offset and is a formatted hexadecimal integer.</para>
          <para>The internalized form is not exposed to clients in responses from
                        Swift.  Normal client operations will not create a timestamp with an
                        offset.</para>
          <para>The Timestamp class in common.utils supports internalized and
                        normalized formatting of timestamps and also comparison of timestamp
                        values.  When the offset value of a Timestamp is 0 - it’s considered
                        insignificant and need not be represented in the string format; to
                        support backwards compatibility during a Swift upgrade the
                        internalized and normalized form of a Timestamp with an
                        insignificant offset are identical.  When a timestamp includes an
                        offset it will always be represented in the internalized form, but
                        is still excluded from the normalized form.  Timestamps with an
                        equivalent timestamp portion (the float part) will compare and order
                        by their offset.  Timestamps with a greater timestamp portion will
                        always compare and order greater than a Timestamp with a lesser
                        timestamp regardless of it’s offset.  String comparison and ordering
                        is guaranteed for the internalized string format, and is backwards
                        compatible for normalized timestamps which do not include an offset.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.affinity_key_function">
        <term>
          <function>swift.common.utils.affinity_key_function</function>
        </term>
        <listitem>
          <para>Turns an affinity config value into a function suitable for passing to
                        sort(). After doing so, the array will be sorted with respect to the given
                        ordering.</para>
          <para>For example, if affinity_str is “r1=1, r2z7=2, r2z8=2”, then the array
                        will be sorted with all nodes from region 1 (r1=1) first, then all the
                        nodes from region 2 zones 7 and 8 (r2z7=2 and r2z8=2), then everything
                        else.</para>
          <para>Note that the order of the pieces of affinity_str is irrelevant; the
                        priority values are what comes after the equals sign.</para>
          <para>If affinity_str is empty or all whitespace, then the resulting function
                        will not alter the ordering of the nodes.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.affinity_locality_predicate">
        <term>
          <function>swift.common.utils.affinity_locality_predicate</function>
        </term>
        <listitem>
          <para>Turns a write-affinity config value into a predicate function for nodes.
                        The returned value will be a 1-arg function that takes a node dictionary
                        and returns a true value if it is “local” and a false value otherwise. The
                        definition of “local” comes from the affinity_str argument passed in here.</para>
          <para>For example, if affinity_str is “r1, r2z2”, then only nodes where region=1
                        or where (region=2 and zone=2) are considered local.</para>
          <para>If affinity_str is empty or all whitespace, then the resulting function
                        will consider everything local</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.audit_location_generator">
        <term>
          <function>swift.common.utils.audit_location_generator</function>
        </term>
        <listitem>
          <para>Given a devices path and a data directory, yield (path, device,
                        partition) for all files in that directory</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.backward">
        <term>
          <function>swift.common.utils.backward</function>
        </term>
        <listitem>
          <para>A generator returning lines from a file starting with the last line,
                        then the second last line, etc. i.e., it reads lines backwards.
                        Stops when the first line (if any) is read.
                        This is useful when searching for recent activity in very
                        large files.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.cache_from_env">
        <term>
          <function>swift.common.utils.cache_from_env</function>
        </term>
        <listitem>
          <para>Get memcache connection pool from the environment (which had been
                        previously set by the memcache middleware</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.capture_stdio">
        <term>
          <function>swift.common.utils.capture_stdio</function>
        </term>
        <listitem>
          <para>Log unhandled exceptions, close stdio, capture stdout and stderr.</para>
          <para>param logger: Logger object to use</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.closing_if_possible">
        <term>
          <function>swift.common.utils.closing_if_possible</function>
        </term>
        <listitem>
          <para>Like contextlib.closing(), but doesn’t crash if the object lacks a close()
                        method.</para>
          <para>PEP 333 (WSGI) says: “If the iterable returned by the application has a
                        close() method, the server or gateway must call that method upon
                        completion of the current request[.]” This function makes that easier.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.compute_eta">
        <term>
          <function>swift.common.utils.compute_eta</function>
        </term>
        <listitem>
          <para>Compute an ETA.  Now only if we could also have a progress bar…</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.config_auto_int_value">
        <term>
          <function>swift.common.utils.config_auto_int_value</function>
        </term>
        <listitem>
          <para>Returns default if value is None or ‘auto’.
                        Returns value as an int or raises ValueError otherwise.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.config_fallocate_value">
        <term>
          <function>swift.common.utils.config_fallocate_value</function>
        </term>
        <listitem>
          <para>Returns fallocate reserve_value as an int or float.
                        Returns is_percent as a boolean.
                        Returns a ValueError on invalid fallocate value.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.config_positive_int_value">
        <term>
          <function>swift.common.utils.config_positive_int_value</function>
        </term>
        <listitem>
          <para>Returns positive int value if it can be cast by int() and it’s an
                        integer &gt; 0. (not including zero) Raises ValueError otherwise.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.config_read_prefixed_options">
        <term>
          <function>swift.common.utils.config_read_prefixed_options</function>
        </term>
        <listitem>
          <para>Read prefixed options from configuration</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.config_read_reseller_options">
        <term>
          <function>swift.common.utils.config_read_reseller_options</function>
        </term>
        <listitem>
          <para>Read reseller_prefix option and associated options from configuration</para>
          <para>Reads the reseller_prefix option, then reads options that may be
                        associated with a specific reseller prefix. Reads options such that an
                        option without a prefix applies to all reseller prefixes unless an option
                        has an explicit prefix.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.config_true_value">
        <term>
          <function>swift.common.utils.config_true_value</function>
        </term>
        <listitem>
          <para>Returns True if the value is either True or a string in TRUE_VALUES.
                        Returns False otherwise.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.csv_append">
        <term>
          <function>swift.common.utils.csv_append</function>
        </term>
        <listitem>
          <para>Appends an item to a comma-separated string.</para>
          <para>If the comma-separated string is empty/None, just returns item.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.decode_timestamps">
        <term>
          <function>swift.common.utils.decode_timestamps</function>
        </term>
        <listitem>
          <para>Parses a string of the form generated by encode_timestamps and returns
                        a tuple of the three component timestamps. If explicit is False, component
                        timestamps that are not explicitly encoded will be assumed to have zero
                        delta from the previous component and therefore take the value of the
                        previous component. If explicit is True, component timestamps that are
                        not explicitly encoded will be returned with value None.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.document_iters_to_http_response_body">
        <term>
          <function>swift.common.utils.document_iters_to_http_response_body</function>
        </term>
        <listitem>
          <para>Takes an iterator of range iters and turns it into an appropriate
                        HTTP response body, whether that’s multipart/byteranges or not.</para>
          <para>This is almost, but not quite, the inverse of
                        request_helpers.http_response_to_document_iters(). This function only
                        yields chunks of the body, not any headers.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.document_iters_to_multipart_byteranges">
        <term>
          <function>swift.common.utils.document_iters_to_multipart_byteranges</function>
        </term>
        <listitem>
          <para>Takes an iterator of range iters and yields a multipart/byteranges MIME
                        document suitable for sending as the body of a multi-range 206 response.</para>
          <para>See document_iters_to_http_response_body for parameter descriptions.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.drop_buffer_cache">
        <term>
          <function>swift.common.utils.drop_buffer_cache</function>
        </term>
        <listitem>
          <para>Drop ‘buffer’ cache for the given range of the given file.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.drop_privileges">
        <term>
          <function>swift.common.utils.drop_privileges</function>
        </term>
        <listitem>
          <para>Sets the userid/groupid of the current process, get session leader, etc.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.dump_recon_cache">
        <term>
          <function>swift.common.utils.dump_recon_cache</function>
        </term>
        <listitem>
          <para>Update recon cache values</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.encode_timestamps">
        <term>
          <function>swift.common.utils.encode_timestamps</function>
        </term>
        <listitem>
          <para>Encode up to three timestamps into a string. Unlike a Timestamp object, the
                        encoded string does NOT used fixed width fields and consequently no
                        relative chronology of the timestamps can be inferred from lexicographic
                        sorting of encoded timestamp strings.</para>
          <variablelist>
            <varlistentry>
              <term>The format of the encoded string is:</term>
              <listitem>
                <para>&lt;t1&gt;[&lt;+/-&gt;&lt;t2 - t1&gt;[&lt;+/-&gt;&lt;t3 - t2&gt;]]</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>i.e. if t1 = t2 = t3 then just the string representation of t1 is returned,
                        otherwise the time offsets for t2 and t3 are appended. If explicit is True
                        then the offsets for t2 and t3 are always appended even if zero.</para>
          <para>Note: any offset value in t1 will be preserved, but offsets on t2 and t3
                        are not preserved. In the anticipated use cases for this method (and the
                        inverse decode_timestamps method) the timestamps passed as t2 and t3 are
                        not expected to have offsets as they will be timestamps associated with a
                        POST request. In the case where the encoding is used in a container objects
                        table row, t1 could be the PUT or DELETE time but t2 and t3 represent the
                        content type and metadata times (if different from the data file) i.e.
                        correspond to POST timestamps. In the case where the encoded form is used
                        in a .meta file name, t1 and t2 both correspond to POST timestamps.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.expand_ipv6">
        <term>
          <function>swift.common.utils.expand_ipv6</function>
        </term>
        <listitem>
          <para>Expand ipv6 address.
                        :param address: a string indicating valid ipv6 address
                        :returns: a string indicating fully expanded ipv6 address</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.extract_swift_bytes">
        <term>
          <function>swift.common.utils.extract_swift_bytes</function>
        </term>
        <listitem>
          <variablelist>
            <varlistentry>
              <term>Parse a content-type and return a tuple containing:</term>
              <listitem>
                <itemizedlist>
                  <listitem>
                    <para>the content_type string minus any swift_bytes param,</para>
                  </listitem>
                  <listitem>
                    <para>the swift_bytes value or None if the param was not found</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.fallocate">
        <term>
          <function>swift.common.utils.fallocate</function>
        </term>
        <listitem>
          <para>Pre-allocate disk space for a file.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.fdatasync">
        <term>
          <function>swift.common.utils.fdatasync</function>
        </term>
        <listitem>
          <para>Sync modified file data to disk.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.fsync">
        <term>
          <function>swift.common.utils.fsync</function>
        </term>
        <listitem>
          <para>Sync modified file data and metadata to disk.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.fsync_dir">
        <term>
          <function>swift.common.utils.fsync_dir</function>
        </term>
        <listitem>
          <para>Sync directory entries to disk.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_expirer_container">
        <term>
          <function>swift.common.utils.get_expirer_container</function>
        </term>
        <listitem>
          <para>Returns a expiring object container name for given X-Delete-At and
                        a/c/o.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_hmac">
        <term>
          <function>swift.common.utils.get_hmac</function>
        </term>
        <listitem>
          <para>Returns the hexdigest string of the HMAC-SHA1 (RFC 2104) for
                        the request.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_hub">
        <term>
          <function>swift.common.utils.get_hub</function>
        </term>
        <listitem>
          <para>Checks whether poll is available and falls back
                        on select if it isn’t.</para>
          <para>Note about epoll:</para>
          <para>Review: <link xlink:href="https://review.openstack.org/#/c/18806/"/></para>
          <para>There was a problem where once out of every 30 quadrillion
                        connections, a coroutine wouldn’t wake up when the client
                        closed its end. Epoll was not reporting the event or it was
                        getting swallowed somewhere. Then when that file descriptor
                        was re-used, eventlet would freak right out because it still
                        thought it was waiting for activity from it in some other coro.</para>
          <para>Another note about epoll: it’s hard to use when forking. epoll works
                        like so:</para>
          <itemizedlist>
            <listitem>
              <para>create an epoll instance: efd = epoll_create(…)</para>
            </listitem>
            <listitem>
              <variablelist>
                <varlistentry>
                  <term>register file descriptors of interest with epoll_ctl(efd,</term>
                  <listitem>
                    <para>EPOLL_CTL_ADD, fd, …)</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
            <listitem>
              <para>wait for events with epoll_wait(efd, …)</para>
            </listitem>
          </itemizedlist>
          <para>If you fork, you and all your child processes end up using the same
                        epoll instance, and everyone becomes confused. It is possible to use
                        epoll and fork and still have a correct program as long as you do the
                        right things, but eventlet doesn’t do those things. Really, it can’t
                        even try to do those things since it doesn’t get notified of forks.</para>
          <para>In contrast, both poll() and select() specify the set of interesting
                        file descriptors with each call, so there’s no problem with forking.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_log_line">
        <term>
          <function>swift.common.utils.get_log_line</function>
        </term>
        <listitem>
          <para>Make a line for logging that matches the documented log line format
                        for backend servers.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_logger">
        <term>
          <function>swift.common.utils.get_logger</function>
        </term>
        <listitem>
          <para>Get the current system logger using config settings.</para>
          <para><emphasis role="bold">Log config and defaults</emphasis>:</para>
          <screen>log_facility = LOG_LOCAL0
log_level = INFO
log_name = swift
log_max_line_length = 0
log_udp_host = (disabled)
log_udp_port = logging.handlers.SYSLOG_UDP_PORT
log_address = /dev/log
log_statsd_host = (disabled)
log_statsd_port = 8125
log_statsd_default_sample_rate = 1.0
log_statsd_sample_rate_factor = 1.0
log_statsd_metric_prefix = (empty-string)</screen>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_md5_socket">
        <term>
          <function>swift.common.utils.get_md5_socket</function>
        </term>
        <listitem>
          <para>Get an MD5 socket file descriptor. One can MD5 data with it by writing it
                        to the socket with os.write, then os.read the 16 bytes of the checksum out
                        later.</para>
          <para>NOTE: It is the caller’s responsibility to ensure that os.close() is
                        called on the returned file descriptor. This is a bare file descriptor,
                        not a Python object. It doesn’t close itself.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_policy_index">
        <term>
          <function>swift.common.utils.get_policy_index</function>
        </term>
        <listitem>
          <para>Returns the appropriate index of the storage policy for the request from
                        a proxy server</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_swift_info">
        <term>
          <function>swift.common.utils.get_swift_info</function>
        </term>
        <listitem>
          <para>Returns information about the swift cluster that has been previously
                        registered with the register_swift_info call.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_time_units">
        <term>
          <function>swift.common.utils.get_time_units</function>
        </term>
        <listitem>
          <para>Get a nomralized length of time in the largest unit of time (hours,
                        minutes, or seconds.)</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.get_valid_utf8_str">
        <term>
          <function>swift.common.utils.get_valid_utf8_str</function>
        </term>
        <listitem>
          <para>Get valid parts of utf-8 str from str, unicode and even invalid utf-8 str</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.hash_path">
        <term>
          <function>swift.common.utils.hash_path</function>
        </term>
        <listitem>
          <para>Get the canonical hash for an account/container/object</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.human_readable">
        <term>
          <function>swift.common.utils.human_readable</function>
        </term>
        <listitem>
          <para>Returns the number in a human readable format; for example 1048576 = “1Mi”.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.is_valid_ip">
        <term>
          <function>swift.common.utils.is_valid_ip</function>
        </term>
        <listitem>
          <para>Return True if the provided ip is a valid IP-address</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.is_valid_ipv4">
        <term>
          <function>swift.common.utils.is_valid_ipv4</function>
        </term>
        <listitem>
          <para>Return True if the provided ip is a valid IPv4-address</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.is_valid_ipv6">
        <term>
          <function>swift.common.utils.is_valid_ipv6</function>
        </term>
        <listitem>
          <para>Returns True if the provided ip is a valid IPv6-address</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.ismount">
        <term>
          <function>swift.common.utils.ismount</function>
        </term>
        <listitem>
          <para>Test whether a path is a mount point. This will catch any
                        exceptions and translate them into a False return value
                        Use ismount_raw to have the exceptions raised instead.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.ismount_raw">
        <term>
          <function>swift.common.utils.ismount_raw</function>
        </term>
        <listitem>
          <para>Test whether a path is a mount point. Whereas ismount will catch
                        any exceptions and just return False, this raw version will not
                        catch exceptions.</para>
          <para>This is code hijacked from C Python 2.6.8, adapted to remove the extra
                        lstat() system call.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.item_from_env">
        <term>
          <function>swift.common.utils.item_from_env</function>
        </term>
        <listitem>
          <para>Get a value from the wsgi environment</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.iter_multipart_mime_documents">
        <term>
          <function>swift.common.utils.iter_multipart_mime_documents</function>
        </term>
        <listitem>
          <para>Given a multi-part-mime-encoded input file object and boundary,
                        yield file-like objects for each part. Note that this does not
                        split each part into headers and body; the caller is responsible
                        for doing that if necessary.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.last_modified_date_to_timestamp">
        <term>
          <function>swift.common.utils.last_modified_date_to_timestamp</function>
        </term>
        <listitem>
          <para>Convert a last modified date (like you’d get from a container listing,
                        e.g. 2014-02-28T23:22:36.698390) to a float.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.link_fd_to_path">
        <term>
          <function>swift.common.utils.link_fd_to_path</function>
        </term>
        <listitem>
          <para>Creates a link to file descriptor at target_path specified. This method
                        does not close the fd for you. Unlike rename, as linkat() cannot
                        overwrite target_path if it exists, we unlink and try again.</para>
          <para>Attempts to fix / hide race conditions like empty object directories
                        being removed by backend processes during uploads, by retrying.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.list_from_csv">
        <term>
          <function>swift.common.utils.list_from_csv</function>
        </term>
        <listitem>
          <para>Splits the str given and returns a properly stripped list of the comma
                        separated values.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.load_libc_function">
        <term>
          <function>swift.common.utils.load_libc_function</function>
        </term>
        <listitem>
          <para>Attempt to find the function in libc, otherwise return a no-op func.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.lock_file">
        <term>
          <function>swift.common.utils.lock_file</function>
        </term>
        <listitem>
          <para>Context manager that acquires a lock on a file.  This will block until
                        the lock can be acquired, or the timeout time has expired (whichever occurs
                        first).</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.lock_parent_directory">
        <term>
          <function>swift.common.utils.lock_parent_directory</function>
        </term>
        <listitem>
          <para>Context manager that acquires a lock on the parent directory of the given
                        file path.  This will block until the lock can be acquired, or the timeout
                        time has expired (whichever occurs first).</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.lock_path">
        <term>
          <function>swift.common.utils.lock_path</function>
        </term>
        <listitem>
          <para>Context manager that acquires a lock on a directory.  This will block until
                        the lock can be acquired, or the timeout time has expired (whichever occurs
                        first).</para>
          <para>For locking exclusively, file or directory has to be opened in Write mode.
                        Python doesn’t allow directories to be opened in Write Mode. So we
                        workaround by locking a hidden file in the directory.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.makedirs_count">
        <term>
          <function>swift.common.utils.makedirs_count</function>
        </term>
        <listitem>
          <para>Same as os.makedirs() except that this method returns the number of
                        new directories that had to be created.</para>
          <para>Also, this does not raise an error if target directory already exists.
                        This behaviour is similar to Python 3.x’s os.makedirs() called with
                        exist_ok=True. Also similar to swift.common.utils.mkdirs()</para>
          <para>
            <link xlink:href="https://hg.python.org/cpython/file/v3.4.2/Lib/os.py#l212"/>
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.maybe_multipart_byteranges_to_document_iters">
        <term>
          <function>swift.common.utils.maybe_multipart_byteranges_to_document_iters</function>
        </term>
        <listitem>
          <para>Takes an iterator that may or may not contain a multipart MIME document
                        as well as content type and returns an iterator of body iterators.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.md5_hash_for_file">
        <term>
          <function>swift.common.utils.md5_hash_for_file</function>
        </term>
        <listitem>
          <para>Get the MD5 checksum of a file.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.mime_to_document_iters">
        <term>
          <function>swift.common.utils.mime_to_document_iters</function>
        </term>
        <listitem>
          <para>Takes a file-like object containing a multipart MIME document and
                        returns an iterator of (headers, body-file) tuples.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.mkdirs">
        <term>
          <function>swift.common.utils.mkdirs</function>
        </term>
        <listitem>
          <para>Ensures the path is a directory or makes it if not. Errors if the path
                        exists but is a file or on permissions failure.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.modify_priority">
        <term>
          <function>swift.common.utils.modify_priority</function>
        </term>
        <listitem>
          <para>Modify priority by nice and ionice.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.multipart_byteranges_to_document_iters">
        <term>
          <function>swift.common.utils.multipart_byteranges_to_document_iters</function>
        </term>
        <listitem>
          <para>Takes a file-like object containing a multipart/byteranges MIME document
                        (see RFC 7233, Appendix A) and returns an iterator of (first-byte,
                        last-byte, length, document-headers, body-file) 5-tuples.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.normalize_delete_at_timestamp">
        <term>
          <function>swift.common.utils.normalize_delete_at_timestamp</function>
        </term>
        <listitem>
          <para>Format a timestamp (string or numeric) into a standardized
                        xxxxxxxxxx (10) format.</para>
          <para>Note that timestamps less than 0000000000 are raised to
                        0000000000 and values greater than November 20th, 2286 at
                        17:46:39 UTC will be capped at that date and time, resulting in
                        no return value exceeding 9999999999.</para>
          <para>This cap is because the expirer is already working through a
                        sorted list of strings that were all a length of 10. Adding
                        another digit would mess up the sort and cause the expirer to
                        break from processing early. By 2286, this problem will need to
                        be fixed, probably by creating an additional .expiring_objects
                        account to work from with 11 (or more) digit container names.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.normalize_timestamp">
        <term>
          <function>swift.common.utils.normalize_timestamp</function>
        </term>
        <listitem>
          <para>Format a timestamp (string or numeric) into a standardized
                        xxxxxxxxxx.xxxxx (10.5) format.</para>
          <para>Note that timestamps using values greater than or equal to November 20th,
                        2286 at 17:46 UTC will use 11 digits to represent the number of
                        seconds.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.o_tmpfile_supported">
        <term>
          <function>swift.common.utils.o_tmpfile_supported</function>
        </term>
        <listitem>
          <para>Returns True if O_TMPFILE flag is supported.</para>
          <para>O_TMPFILE was introduced in Linux 3.11 but it also requires support from
                        underlying filesystem being used. Some common filesystems and linux
                        versions in which those filesystems added support for O_TMPFILE:
                        xfs (3.15)
                        ext4 (3.11)
                        btrfs (3.16)</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.override_bytes_from_content_type">
        <term>
          <function>swift.common.utils.override_bytes_from_content_type</function>
        </term>
        <listitem>
          <para>Takes a dict from a container listing and overrides the content_type,
                        bytes fields if swift_bytes is set.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.pairs">
        <term>
          <function>swift.common.utils.pairs</function>
        </term>
        <listitem>
          <para>Returns an iterator of all pairs of elements from item_list.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.parse_content_disposition">
        <term>
          <function>swift.common.utils.parse_content_disposition</function>
        </term>
        <listitem>
          <para>Given the value of a header like:
                        Content-Disposition: form-data; name=”somefile”; filename=”test.html”</para>
          <para>Return data like
                        (“form-data”, {“name”: “somefile”, “filename”: “test.html”})</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.parse_content_range">
        <term>
          <function>swift.common.utils.parse_content_range</function>
        </term>
        <listitem>
          <para>Parse a content-range header into (first_byte, last_byte, total_size).</para>
          <para>See RFC 7233 section 4.2 for details on the header format, but it’s
                        basically “Content-Range: bytes ${start}-${end}/${total}”.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.parse_content_type">
        <term>
          <function>swift.common.utils.parse_content_type</function>
        </term>
        <listitem>
          <para>Parse a content-type and its parameters into values.
                        RFC 2616 sec 14.17 and 3.7 are pertinent.</para>
          <para><emphasis role="bold">Examples</emphasis>:</para>
          <screen>'text/plain; charset=UTF-8' -&gt; ('text/plain', [('charset, 'UTF-8')])
'text/plain; charset=UTF-8; level=1' -&gt;
    ('text/plain', [('charset, 'UTF-8'), ('level', '1')])</screen>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.parse_mime_headers">
        <term>
          <function>swift.common.utils.parse_mime_headers</function>
        </term>
        <listitem>
          <para>Takes a file-like object containing a MIME document and returns a
                        HeaderKeyDict containing the headers. The body of the message is not
                        consumed: the position in doc_file is left at the beginning of the body.</para>
          <para>This function was inspired by the Python standard library’s
                        http.client.parse_headers.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.parse_options">
        <term>
          <function>swift.common.utils.parse_options</function>
        </term>
        <listitem>
          <para>Parse standard swift server/daemon options with optparse.OptionParser.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.parse_socket_string">
        <term>
          <function>swift.common.utils.parse_socket_string</function>
        </term>
        <listitem>
          <para>Given a string representing a socket, returns a tuple of (host, port).
                        Valid strings are DNS names, IPv4 addresses, or IPv6 addresses, with an
                        optional port. If an IPv6 address is specified it <emphasis role="bold">must</emphasis> be enclosed in
                        [], like <emphasis>[::1]</emphasis> or <emphasis>[::1]:11211</emphasis>. This follows the accepted prescription
                        for <link xlink:href="https://tools.ietf.org/html/rfc3986#section-3.2.2">IPv6 host literals</link>.</para>
          <para>Examples:</para>
          <screen>server.org
server.org:1337
127.0.0.1:1337
[::1]:1337
[::1]</screen>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.public">
        <term>
          <function>swift.common.utils.public</function>
        </term>
        <listitem>
          <para>Decorator to declare which methods are publicly accessible as HTTP
                        requests</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.put_recon_cache_entry">
        <term>
          <function>swift.common.utils.put_recon_cache_entry</function>
        </term>
        <listitem>
          <para>Update a recon cache entry item.</para>
          <para>If <literal>item</literal> is an empty dict then any existing <literal>key</literal> in <literal>cache_entry</literal>
                        will be deleted. Similarly if <literal>item</literal> is a dict and any of its values are
                        empty dicts then the corrsponsing key will be deleted from the nested dict
                        in <literal>cache_entry</literal>.</para>
          <para>We use nested recon cache entries when the object auditor
                        runs in parallel or else in ‘once’ mode with a specified subset of devices.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.quorum_size">
        <term>
          <function>swift.common.utils.quorum_size</function>
        </term>
        <listitem>
          <para>quorum size as it applies to services that use ‘replication’ for data
                        integrity  (Account/Container services).  Object quorum_size is defined
                        on a storage policy basis.</para>
          <para>Number of successful backend requests needed for the proxy to consider
                        the client request successful.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.quote">
        <term>
          <function>swift.common.utils.quote</function>
        </term>
        <listitem>
          <para>Patched version of urllib.quote that encodes utf-8 strings before quoting</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.random">
        <term>
          <function>swift.common.utils.random</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.ratelimit_sleep">
        <term>
          <function>swift.common.utils.ratelimit_sleep</function>
        </term>
        <listitem>
          <para>Will eventlet.sleep() for the appropriate time so that the max_rate
                        is never exceeded.  If max_rate is 0, will not ratelimit.  The
                        maximum recommended rate should not exceed (1000 * incr_by) a second
                        as eventlet.sleep() does involve some overhead.  Returns running_time
                        that should be used for subsequent calls.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.readconf">
        <term>
          <function>swift.common.utils.readconf</function>
        </term>
        <listitem>
          <para>Read config file(s) and return config items as a dict</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.register_swift_info">
        <term>
          <function>swift.common.utils.register_swift_info</function>
        </term>
        <listitem>
          <para>Registers information about the swift cluster to be retrieved with calls
                        to get_swift_info.</para>
          <variablelist>
            <varlistentry>
              <term>NOTE: Do not use “.” in the param: name or any keys in kwargs. “.” is used</term>
              <listitem>
                <para>in the disallowed_sections to remove unwanted keys from /info.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.reiterate">
        <term>
          <function>swift.common.utils.reiterate</function>
        </term>
        <listitem>
          <para>Consume the first item from an iterator, then re-chain it to the rest of
                        the iterator.  This is useful when you want to make sure the prologue to
                        downstream generators have been executed before continuing.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.remove_file">
        <term>
          <function>swift.common.utils.remove_file</function>
        </term>
        <listitem>
          <para>Quiet wrapper for os.unlink, OSErrors are suppressed</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.renamer">
        <term>
          <function>swift.common.utils.renamer</function>
        </term>
        <listitem>
          <para>Attempt to fix / hide race conditions like empty object directories
                        being removed by backend processes during uploads, by retrying.</para>
          <para>The containing directory of ‘new’ and of all newly created directories are
                        fsync’d by default. This _will_ come at a performance penalty. In cases
                        where these additional fsyncs are not necessary, it is expected that the
                        caller of renamer() turn it off explicitly.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.replace_partition_in_path">
        <term>
          <function>swift.common.utils.replace_partition_in_path</function>
        </term>
        <listitem>
          <para>Takes a full path to a file and a partition power and returns
                        the same path, but with the correct partition number. Most useful when
                        increasing the partition power.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.replication">
        <term>
          <function>swift.common.utils.replication</function>
        </term>
        <listitem>
          <para>Decorator to declare which methods are accessible for different
                        type of servers:</para>
          <itemizedlist>
            <listitem>
              <para>If option replication_server is None then this decorator
                                doesn’t matter.</para>
            </listitem>
            <listitem>
              <para>If option replication_server is True then ONLY decorated with
                                this decorator methods will be started.</para>
            </listitem>
            <listitem>
              <para>If option replication_server is False then decorated with this
                                decorator methods will NOT be started.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.rsync_ip">
        <term>
          <function>swift.common.utils.rsync_ip</function>
        </term>
        <listitem>
          <para>Transform ip string to an rsync-compatible form</para>
          <para>Will return ipv4 addresses unchanged, but will nest ipv6 addresses
                        inside square brackets.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.rsync_module_interpolation">
        <term>
          <function>swift.common.utils.rsync_module_interpolation</function>
        </term>
        <listitem>
          <para>Interpolate devices variables inside a rsync module template</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.search_tree">
        <term>
          <function>swift.common.utils.search_tree</function>
        </term>
        <listitem>
          <para>Look in root, for any files/dirs matching glob, recursively traversing
                        any found directories looking for files ending with ext</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.server_handled_successfully">
        <term>
          <function>swift.common.utils.server_handled_successfully</function>
        </term>
        <listitem>
          <para>True for successful responses <emphasis>or</emphasis> error codes that are not Swift’s fault,
                        False otherwise. For example, 500 is definitely the server’s fault, but
                        412 is an error code (4xx are all errors) that is due to a header the
                        client sent.</para>
          <para>If one is tracking error rates to monitor server health, one would be
                        advised to use a function like this one, lest a client cause a flurry of
                        404s or 416s and make a spurious spike in your errors graph.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.set_swift_dir">
        <term>
          <function>swift.common.utils.set_swift_dir</function>
        </term>
        <listitem>
          <para>Sets the directory from which swift config files will be read. If the given
                        directory differs from that already set then the swift.conf file in the new
                        directory will be validated and storage policies will be reloaded from the
                        new swift.conf file.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.sockaddr_alg">
        <term>
          <literal>swift.common.utils.sockaddr_alg</literal>
        </term>
        <listitem>
          <para>Bases: <literal>_ctypes.Structure</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.split_path">
        <term>
          <function>swift.common.utils.split_path</function>
        </term>
        <listitem>
          <para>Validate and split the given HTTP request path.</para>
          <para><emphasis role="bold">Examples</emphasis>:</para>
          <screen>['a'] = split_path('/a')
['a', None] = split_path('/a', 1, 2)
['a', 'c'] = split_path('/a/c', 1, 2)
['a', 'c', 'o/r'] = split_path('/a/c/o/r', 1, 3, True)</screen>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.storage_directory">
        <term>
          <function>swift.common.utils.storage_directory</function>
        </term>
        <listitem>
          <para>Get the storage directory</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.streq_const_time">
        <term>
          <function>swift.common.utils.streq_const_time</function>
        </term>
        <listitem>
          <para>Constant-time string comparison.</para>
          <para>This function takes two strings and compares them.  It is intended to be
                        used when doing a comparison for authentication purposes to help guard
                        against timing attacks.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.timing_stats">
        <term>
          <function>swift.common.utils.timing_stats</function>
        </term>
        <listitem>
          <para>Returns a decorator that logs timing events or errors for public methods in
                        swift’s wsgi server controllers, based on response code.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.tpool_reraise">
        <term>
          <function>swift.common.utils.tpool_reraise</function>
        </term>
        <listitem>
          <para>Hack to work around Eventlet’s tpool not catching and reraising Timeouts.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.unlink_older_than">
        <term>
          <function>swift.common.utils.unlink_older_than</function>
        </term>
        <listitem>
          <para>Remove any file in a given path that was last modified before mtime.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.unlink_paths_older_than">
        <term>
          <function>swift.common.utils.unlink_paths_older_than</function>
        </term>
        <listitem>
          <para>Remove any files from the given list that were
                        last modified before mtime.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.urlparse">
        <term>
          <function>swift.common.utils.urlparse</function>
        </term>
        <listitem>
          <para>urlparse augmentation.
                        This is necessary because urlparse can’t handle RFC 2732 URLs.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.validate_device_partition">
        <term>
          <function>swift.common.utils.validate_device_partition</function>
        </term>
        <listitem>
          <para>Validate that a device and a partition are valid and won’t lead to
                        directory traversal when used.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.validate_sync_to">
        <term>
          <function>swift.common.utils.validate_sync_to</function>
        </term>
        <listitem>
          <para>Validates an X-Container-Sync-To header value, returning the
                        validated endpoint, realm, and realm_key, or an error string.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.whataremyips">
        <term>
          <function>swift.common.utils.whataremyips</function>
        </term>
        <listitem>
          <para>Get “our” IP addresses (“us” being the set of services configured by
                        one <literal>*.conf</literal> file). If our REST listens on a specific address, return it.
                        Otherwise, if listen on ‘0.0.0.0’ or ‘::’ return all addresses, including
                        the loopback.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.write_file">
        <term>
          <function>swift.common.utils.write_file</function>
        </term>
        <listitem>
          <para>Write contents to file at path</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.utils.write_pickle">
        <term>
          <function>swift.common.utils.write_pickle</function>
        </term>
        <listitem>
          <para>Ensure that a pickle file gets written to disk.  The file
                        is first written to a tmp location, ensure it is synced to disk, then
                        perform a move to its final location</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>WSGI</title>
    <para>WSGI tools for use with swift.</para>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.ConfigDirLoader">
        <term>
          <literal>swift.common.wsgi.ConfigDirLoader</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.wsgi.NamedConfigLoader"/></para>
          <para>Read configuration from multiple files under the given path.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.ConfigFileError">
        <term>
          <literal>swift.common.wsgi.ConfigFileError</literal>
        </term>
        <listitem>
          <para>Bases: <literal>Exception</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.ConfigFilePortError">
        <term>
          <literal>swift.common.wsgi.ConfigFilePortError</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.wsgi.ConfigFileError"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.ConfigString">
        <term>
          <literal>swift.common.wsgi.ConfigString</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.wsgi.NamedConfigLoader"/></para>
          <para>Wrap a raw config string up for paste.deploy.</para>
          <para>If you give one of these to our loadcontext (e.g. give it to our
                        appconfig) we’ll intercept it and get it routed to the right loader.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.NamedConfigLoader">
        <term>
          <literal>swift.common.wsgi.NamedConfigLoader</literal>
        </term>
        <listitem>
          <para>Bases: <literal>paste.deploy.loadwsgi.ConfigLoader</literal></para>
          <para>Patch paste.deploy’s ConfigLoader so each context object will know what
                        config section it came from.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.PipelineWrapper">
        <term>
          <literal>swift.common.wsgi.PipelineWrapper</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>This class provides a number of utility methods for
                        modifying the composition of a wsgi pipeline.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PipelineWrapper.create_filter">
              <term>
                <property>swift.common.wsgi.PipelineWrapper.create_filter</property>
              </term>
              <listitem>
                <para>Creates a context for a filter that can subsequently be added
                                to a pipeline context.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PipelineWrapper.index">
              <term>
                <property>swift.common.wsgi.PipelineWrapper.index</property>
              </term>
              <listitem>
                <para>Returns the first index of the given entry point name in the pipeline.</para>
                <para>Raises ValueError if the given module is not in the pipeline.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PipelineWrapper.insert_filter">
              <term>
                <property>swift.common.wsgi.PipelineWrapper.insert_filter</property>
              </term>
              <listitem>
                <para>Inserts a filter module into the pipeline context.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PipelineWrapper.startswith">
              <term>
                <property>swift.common.wsgi.PipelineWrapper.startswith</property>
              </term>
              <listitem>
                <para>Tests if the pipeline starts with the given entry point name.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.PortPidState">
        <term>
          <literal>swift.common.wsgi.PortPidState</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>A helper class for <xref linkend="swift.common.wsgi.ServersPerPortStrategy"/> to track listen
                        sockets and PIDs for each port.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PortPidState.all_socks">
              <term>
                <property>swift.common.wsgi.PortPidState.all_socks</property>
              </term>
              <listitem>
                <para>Yield all current listen sockets.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PortPidState.forget_pid">
              <term>
                <property>swift.common.wsgi.PortPidState.forget_pid</property>
              </term>
              <listitem>
                <para>Idempotently forget a PID.  It’s okay if the PID is no longer in our
                                data structure (it could have been removed by the “orphan port” removal
                                in <literal>new_worker_socks()</literal>).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PortPidState.forget_port">
              <term>
                <property>swift.common.wsgi.PortPidState.forget_port</property>
              </term>
              <listitem>
                <para>Idempotently forget a port, closing the listen socket at most once.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PortPidState.not_tracking">
              <term>
                <property>swift.common.wsgi.PortPidState.not_tracking</property>
              </term>
              <listitem>
                <para>Return True if the specified port is not being tracked.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PortPidState.port_for_sock">
              <term>
                <property>swift.common.wsgi.PortPidState.port_for_sock</property>
              </term>
              <listitem/>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PortPidState.port_index_pairs">
              <term>
                <property>swift.common.wsgi.PortPidState.port_index_pairs</property>
              </term>
              <listitem>
                <para>Returns current (port, server index) pairs.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PortPidState.sock_for_port">
              <term>
                <property>swift.common.wsgi.PortPidState.sock_for_port</property>
              </term>
              <listitem/>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.PortPidState.track_port">
              <term>
                <property>swift.common.wsgi.PortPidState.track_port</property>
              </term>
              <listitem>
                <para>Start tracking servers for the given port and listen socket.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.RestrictedGreenPool">
        <term>
          <literal>swift.common.wsgi.RestrictedGreenPool</literal>
        </term>
        <listitem>
          <para>Bases: <literal>eventlet.greenpool.GreenPool</literal></para>
          <para>Works the same as GreenPool, but if the size is specified as one, then the
                        spawn_n() method will invoke waitall() before returning to prevent the
                        caller from doing any other work (like calling accept()).</para>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.RestrictedGreenPool.spawn_n">
              <term>
                <property>swift.common.wsgi.RestrictedGreenPool.spawn_n</property>
              </term>
              <listitem>
                <para>Create a greenthread to run the <emphasis>function</emphasis>, the same as
                                <literal>spawn()</literal>.  The difference is that <xref linkend="swift.common.wsgi.RestrictedGreenPool.spawn_n"/> returns
                                None; the results of <emphasis>function</emphasis> are not retrievable.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy">
        <term>
          <literal>swift.common.wsgi.ServersPerPortStrategy</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>WSGI server management strategy object for an object-server with one listen
                        port per unique local port in the storage policy rings.  The
                        <literal>servers_per_port</literal> integer config setting determines how many workers are
                        run per port.</para>
          <para>Used in <xref linkend="swift.common.wsgi.run_wsgi"/>.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy.do_bind_ports">
              <term>
                <property>swift.common.wsgi.ServersPerPortStrategy.do_bind_ports</property>
              </term>
              <listitem>
                <para>Bind one listen socket per unique local storage policy ring port.  Then
                                do all the work of drop_privileges except the actual dropping of
                                privileges (each forked-off worker will do that post-fork in
                                <xref linkend="swift.common.wsgi.ServersPerPortStrategy.post_fork_hook"/>).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy.log_sock_exit">
              <term>
                <property>swift.common.wsgi.ServersPerPortStrategy.log_sock_exit</property>
              </term>
              <listitem>
                <para>Log a server’s exit.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy.loop_timeout">
              <term>
                <property>swift.common.wsgi.ServersPerPortStrategy.loop_timeout</property>
              </term>
              <listitem>
                <para>Return timeout before checking for reloaded rings.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy.new_worker_socks">
              <term>
                <property>swift.common.wsgi.ServersPerPortStrategy.new_worker_socks</property>
              </term>
              <listitem>
                <para>Yield a sequence of (socket, server_idx) tuples for each server which
                                should be forked-off and started.</para>
                <para>Any sockets for “orphaned” ports no longer in any ring will be closed
                                (causing their associated workers to gracefully exit) after all new
                                sockets have been yielded.</para>
                <para>The server_idx item for each socket will passed into the
                                <xref linkend="swift.common.wsgi.ServersPerPortStrategy.log_sock_exit"/> and <xref linkend="swift.common.wsgi.ServersPerPortStrategy.register_worker_start"/> methods.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy.no_fork_sock">
              <term>
                <property>swift.common.wsgi.ServersPerPortStrategy.no_fork_sock</property>
              </term>
              <listitem>
                <para>This strategy does not support running in the foreground.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy.post_fork_hook">
              <term>
                <property>swift.common.wsgi.ServersPerPortStrategy.post_fork_hook</property>
              </term>
              <listitem>
                <para>Called in each child process, prior to starting the actual wsgi server,
                                to drop privileges.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy.register_worker_exit">
              <term>
                <property>swift.common.wsgi.ServersPerPortStrategy.register_worker_exit</property>
              </term>
              <listitem>
                <para>Called when a worker has exited.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy.register_worker_start">
              <term>
                <property>swift.common.wsgi.ServersPerPortStrategy.register_worker_start</property>
              </term>
              <listitem>
                <para>Called when a new worker is started.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.ServersPerPortStrategy.shutdown_sockets">
              <term>
                <property>swift.common.wsgi.ServersPerPortStrategy.shutdown_sockets</property>
              </term>
              <listitem>
                <para>Shutdown any listen sockets.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.WSGIContext">
        <term>
          <literal>swift.common.wsgi.WSGIContext</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>This class provides a means to provide context (scope) for a middleware
                        filter to have access to the wsgi start_response results like the request
                        status and headers.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.WorkersStrategy">
        <term>
          <literal>swift.common.wsgi.WorkersStrategy</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>WSGI server management strategy object for a single bind port and listen
                        socket shared by a configured number of forked-off workers.</para>
          <para>Used in <xref linkend="swift.common.wsgi.run_wsgi"/>.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.WorkersStrategy.do_bind_ports">
              <term>
                <property>swift.common.wsgi.WorkersStrategy.do_bind_ports</property>
              </term>
              <listitem>
                <para>Bind the one listen socket for this strategy and drop privileges
                                (since the parent process will never need to bind again).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.WorkersStrategy.log_sock_exit">
              <term>
                <property>swift.common.wsgi.WorkersStrategy.log_sock_exit</property>
              </term>
              <listitem>
                <para>Log a server’s exit.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.WorkersStrategy.loop_timeout">
              <term>
                <property>swift.common.wsgi.WorkersStrategy.loop_timeout</property>
              </term>
              <listitem>
                <para>We want to keep from busy-waiting, but we also need a non-None value so
                                the main loop gets a chance to tell whether it should keep running or
                                not (e.g. SIGHUP received).</para>
                <para>So we return 0.5.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.WorkersStrategy.new_worker_socks">
              <term>
                <property>swift.common.wsgi.WorkersStrategy.new_worker_socks</property>
              </term>
              <listitem>
                <para>Yield a sequence of (socket, opqaue_data) tuples for each server which
                                should be forked-off and started.</para>
                <para>The opaque_data item for each socket will passed into the
                                <xref linkend="swift.common.wsgi.WorkersStrategy.log_sock_exit"/> and <xref linkend="swift.common.wsgi.WorkersStrategy.register_worker_start"/> methods
                                where it will be ignored.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.WorkersStrategy.no_fork_sock">
              <term>
                <property>swift.common.wsgi.WorkersStrategy.no_fork_sock</property>
              </term>
              <listitem>
                <para>Return a server listen socket if the server should run in the
                                foreground (no fork).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.WorkersStrategy.post_fork_hook">
              <term>
                <property>swift.common.wsgi.WorkersStrategy.post_fork_hook</property>
              </term>
              <listitem>
                <para>Perform any initialization in a forked-off child process prior to
                                starting the wsgi server.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.WorkersStrategy.register_worker_exit">
              <term>
                <property>swift.common.wsgi.WorkersStrategy.register_worker_exit</property>
              </term>
              <listitem>
                <para>Called when a worker has exited.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.WorkersStrategy.register_worker_start">
              <term>
                <property>swift.common.wsgi.WorkersStrategy.register_worker_start</property>
              </term>
              <listitem>
                <para>Called when a new worker is started.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.wsgi.WorkersStrategy.shutdown_sockets">
              <term>
                <property>swift.common.wsgi.WorkersStrategy.shutdown_sockets</property>
              </term>
              <listitem>
                <para>Shutdown any listen sockets.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.get_socket">
        <term>
          <function>swift.common.wsgi.get_socket</function>
        </term>
        <listitem>
          <para>Bind socket to bind ip:port in conf</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.init_request_processor">
        <term>
          <function>swift.common.wsgi.init_request_processor</function>
        </term>
        <listitem>
          <para>Loads common settings from conf
                        Sets the logger
                        Loads the request processor</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.loadapp">
        <term>
          <function>swift.common.wsgi.loadapp</function>
        </term>
        <listitem>
          <para>Loads a context from a config file, and if the context is a pipeline
                        then presents the app with the opportunity to modify the pipeline.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.make_env">
        <term>
          <function>swift.common.wsgi.make_env</function>
        </term>
        <listitem>
          <para>Returns a new fresh WSGI environment.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.make_pre_authed_env">
        <term>
          <function>swift.common.wsgi.make_pre_authed_env</function>
        </term>
        <listitem>
          <para>Same as <xref linkend="swift.common.wsgi.make_env"/> but with preauthorization.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.make_pre_authed_request">
        <term>
          <function>swift.common.wsgi.make_pre_authed_request</function>
        </term>
        <listitem>
          <para>Same as <xref linkend="swift.common.wsgi.make_subrequest"/> but with preauthorization.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.make_subrequest">
        <term>
          <function>swift.common.wsgi.make_subrequest</function>
        </term>
        <listitem>
          <para>Makes a new swob.Request based on the current env but with the
                        parameters specified.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.monkey_patch_mimetools">
        <term>
          <function>swift.common.wsgi.monkey_patch_mimetools</function>
        </term>
        <listitem>
          <para>mimetools.Message defaults content-type to “text/plain”
                        This changes it to default to None, so we can detect missing headers.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.pipeline_property">
        <term>
          <function>swift.common.wsgi.pipeline_property</function>
        </term>
        <listitem>
          <para>Create a property accessor for the given name.  The property will
                        dig through the bound instance on which it was accessed for an
                        attribute “app” and check that object for an attribute of the given
                        name.  If the “app” object does not have such an attribute, it will
                        look for an attribute “app” on THAT object and continue it’s search
                        from there.  If the named attribute cannot be found accessing the
                        property will raise AttributeError.</para>
          <para>If a default kwarg is provided you get that instead of the
                        AttributeError.  When found the attribute will be cached on instance
                        with the property accessor using the same name as the attribute
                        prefixed with a leading underscore.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.run_wsgi">
        <term>
          <function>swift.common.wsgi.run_wsgi</function>
        </term>
        <listitem>
          <para>Runs the server according to some strategy.  The default strategy runs a
                        specified number of workers in pre-fork model.  The object-server (only)
                        may use a servers-per-port strategy if its config has a servers_per_port
                        setting with a value greater than zero.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.wsgi.wrap_conf_type">
        <term>
          <function>swift.common.wsgi.wrap_conf_type</function>
        </term>
        <listitem>
          <para>Wrap a function whos first argument is a paste.deploy style config uri,
                        such that you can pass it an un-adorned raw filesystem path (or config
                        string) and the config directive (either config:, config_dir:, or
                        config_str:) will be added automatically based on the type of entity
                        (either a file or directory, or if no such entity on the file system -
                        just a string) before passing it through to the paste.deploy function.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="storage-policy">
    <title>Storage Policy</title>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.BaseStoragePolicy">
        <term>
          <literal>swift.common.storage_policy.BaseStoragePolicy</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Represents a storage policy.  Not meant to be instantiated directly;
                        implement a derived subclasses (e.g. StoragePolicy, ECStoragePolicy, etc)
                        or use <xref linkend="swift.common.storage_policy.reload_storage_policies"/> to
                        load POLICIES from <literal>swift.conf</literal>.</para>
          <para>The object_ring property is lazy loaded once the service’s <literal>swift_dir</literal>
                        is known via <xref linkend="swift.common.storage_policy.StoragePolicyCollection.get_object_ring"/>, but it may
                        be over-ridden via object_ring kwarg at create time for testing or
                        actively loaded with <literal>load_ring()</literal>.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.BaseStoragePolicy.add_name">
              <term>
                <property>swift.common.storage_policy.BaseStoragePolicy.add_name</property>
              </term>
              <listitem>
                <para>Adds an alias name to the storage policy. Shouldn’t be called
                                directly from the storage policy but instead through the
                                storage policy collection class, so lookups by name resolve
                                correctly.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.BaseStoragePolicy.change_primary_name">
              <term>
                <property>swift.common.storage_policy.BaseStoragePolicy.change_primary_name</property>
              </term>
              <listitem>
                <para>Changes the primary/default name of the policy to a specified name.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.BaseStoragePolicy.get_info">
              <term>
                <property>swift.common.storage_policy.BaseStoragePolicy.get_info</property>
              </term>
              <listitem>
                <para>Return the info dict and conf file options for this policy.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.BaseStoragePolicy.load_ring">
              <term>
                <property>swift.common.storage_policy.BaseStoragePolicy.load_ring</property>
              </term>
              <listitem>
                <para>Load the ring for this policy immediately.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.BaseStoragePolicy.quorum">
              <term>
                <property>swift.common.storage_policy.BaseStoragePolicy.quorum</property>
              </term>
              <listitem>
                <para>Number of successful backend requests needed for the proxy to
                                consider the client request successful.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.BaseStoragePolicy.register">
              <term>
                <property>swift.common.storage_policy.BaseStoragePolicy.register</property>
              </term>
              <listitem>
                <para>Decorator for Storage Policy implementations to register
                                their StoragePolicy class.  This will also set the policy_type
                                attribute on the registered implementation.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.BaseStoragePolicy.remove_name">
              <term>
                <property>swift.common.storage_policy.BaseStoragePolicy.remove_name</property>
              </term>
              <listitem>
                <para>Removes an alias name from the storage policy. Shouldn’t be called
                                directly from the storage policy but instead through the storage
                                policy collection class, so lookups by name resolve correctly. If
                                the name removed is the primary name then the next available alias
                                will be adopted as the new primary name.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.ECStoragePolicy">
        <term>
          <literal>swift.common.storage_policy.ECStoragePolicy</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.storage_policy.BaseStoragePolicy"/></para>
          <para>Represents a storage policy of type ‘erasure_coding’.</para>
          <para>Not meant to be instantiated directly; use
                        <xref linkend="swift.common.storage_policy.reload_storage_policies"/> to load
                        POLICIES from <literal>swift.conf</literal>.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.ECStoragePolicy.ec_scheme_description">
              <term>
                <property>swift.common.storage_policy.ECStoragePolicy.ec_scheme_description</property>
              </term>
              <listitem>
                <para>This short hand form of the important parts of the ec schema is stored
                                in Object System Metadata on the EC Fragment Archives for debugging.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.ECStoragePolicy.fragment_size">
              <term>
                <property>swift.common.storage_policy.ECStoragePolicy.fragment_size</property>
              </term>
              <listitem>
                <para>Maximum length of a fragment, including header.</para>
                <para>NB: a fragment archive is a sequence of 0 or more max-length
                                fragments followed by one possibly-shorter fragment.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.ECStoragePolicy.get_backend_index">
              <term>
                <property>swift.common.storage_policy.ECStoragePolicy.get_backend_index</property>
              </term>
              <listitem>
                <para>Backend index for PyECLib</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.ECStoragePolicy.get_info">
              <term>
                <property>swift.common.storage_policy.ECStoragePolicy.get_info</property>
              </term>
              <listitem>
                <para>Return the info dict and conf file options for this policy.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.ECStoragePolicy.load_ring">
              <term>
                <property>swift.common.storage_policy.ECStoragePolicy.load_ring</property>
              </term>
              <listitem>
                <para>Load the ring for this policy immediately.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.ECStoragePolicy.quorum">
              <term>
                <property>swift.common.storage_policy.ECStoragePolicy.quorum</property>
              </term>
              <listitem>
                <para>Number of successful backend requests needed for the proxy to consider
                                the client PUT request successful.</para>
                <para>The quorum size for EC policies defines the minimum number
                                of data + parity elements required to be able to guarantee
                                the desired fault tolerance, which is the number of data
                                elements supplemented by the minimum number of parity
                                elements required by the chosen erasure coding scheme.</para>
                <para>For example, for Reed-Solomon, the minimum number parity
                                elements required is 1, and thus the quorum_size requirement
                                is ec_ndata + 1.</para>
                <para>Given the number of parity elements required is not the same
                                for every erasure coding scheme, consult PyECLib for
                                min_parity_fragments_needed()</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.PolicyError">
        <term>
          <literal>swift.common.storage_policy.PolicyError</literal>
        </term>
        <listitem>
          <para>Bases: <literal>ValueError</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.StoragePolicy">
        <term>
          <literal>swift.common.storage_policy.StoragePolicy</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.common.storage_policy.BaseStoragePolicy"/></para>
          <para>Represents a storage policy of type ‘replication’.  Default storage policy
                        class unless otherwise overridden from swift.conf.</para>
          <para>Not meant to be instantiated directly; use
                        <xref linkend="swift.common.storage_policy.reload_storage_policies"/> to load
                        POLICIES from <literal>swift.conf</literal>.</para>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.StoragePolicy.quorum">
              <term>
                <property>swift.common.storage_policy.StoragePolicy.quorum</property>
              </term>
              <listitem>
                <variablelist>
                  <varlistentry>
                    <term>Quorum concept in the replication case:</term>
                    <listitem>
                      <para>floor(number of replica / 2) + 1</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.StoragePolicyCollection">
        <term>
          <literal>swift.common.storage_policy.StoragePolicyCollection</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>This class represents the collection of valid storage policies for the
                        cluster and is instantiated as <xref linkend="swift.common.storage_policy.StoragePolicy"/> objects are added to
                        the collection when <literal>swift.conf</literal> is parsed by
                        <xref linkend="swift.common.storage_policy.parse_storage_policies"/>.</para>
          <para>When a StoragePolicyCollection is created, the following validation
                        is enforced:</para>
          <itemizedlist>
            <listitem>
              <para>If a policy with index 0 is not declared and no other policies defined,
                                Swift will create one</para>
            </listitem>
            <listitem>
              <para>The policy index must be a non-negative integer</para>
            </listitem>
            <listitem>
              <para>If no policy is declared as the default and no other policies are
                                defined, the policy with index 0 is set as the default</para>
            </listitem>
            <listitem>
              <para>Policy indexes must be unique</para>
            </listitem>
            <listitem>
              <para>Policy names are required</para>
            </listitem>
            <listitem>
              <para>Policy names are case insensitive</para>
            </listitem>
            <listitem>
              <para>Policy names must contain only letters, digits or a dash</para>
            </listitem>
            <listitem>
              <para>Policy names must be unique</para>
            </listitem>
            <listitem>
              <para>The policy name ‘Policy-0’ can only be used for the policy with index 0</para>
            </listitem>
            <listitem>
              <para>If any policies are defined, exactly one policy must be declared default</para>
            </listitem>
            <listitem>
              <para>Deprecated policies can not be declared the default</para>
            </listitem>
          </itemizedlist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.StoragePolicyCollection.add_policy_alias">
              <term>
                <property>swift.common.storage_policy.StoragePolicyCollection.add_policy_alias</property>
              </term>
              <listitem>
                <para>Adds a new name or names to a policy</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.StoragePolicyCollection.change_policy_primary_name">
              <term>
                <property>swift.common.storage_policy.StoragePolicyCollection.change_policy_primary_name</property>
              </term>
              <listitem>
                <para>Changes the primary or default name of a policy. The new primary
                                name can be an alias that already belongs to the policy or a
                                completely new name.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.StoragePolicyCollection.get_by_index">
              <term>
                <property>swift.common.storage_policy.StoragePolicyCollection.get_by_index</property>
              </term>
              <listitem>
                <para>Find a storage policy by its index.</para>
                <para>An index of None will be treated as 0.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.StoragePolicyCollection.get_by_name">
              <term>
                <property>swift.common.storage_policy.StoragePolicyCollection.get_by_name</property>
              </term>
              <listitem>
                <para>Find a storage policy by its name.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.StoragePolicyCollection.get_object_ring">
              <term>
                <property>swift.common.storage_policy.StoragePolicyCollection.get_object_ring</property>
              </term>
              <listitem>
                <para>Get the ring object to use to handle a request based on its policy.</para>
                <para>An index of None will be treated as 0.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.StoragePolicyCollection.get_policy_info">
              <term>
                <property>swift.common.storage_policy.StoragePolicyCollection.get_policy_info</property>
              </term>
              <listitem>
                <para>Build info about policies for the /info endpoint</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.common.storage_policy.StoragePolicyCollection.remove_policy_alias">
              <term>
                <property>swift.common.storage_policy.StoragePolicyCollection.remove_policy_alias</property>
              </term>
              <listitem>
                <para>Removes a name or names from a policy. If the name removed is the
                                primary name then the next available alias will be adopted
                                as the new primary name.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.StoragePolicySingleton">
        <term>
          <literal>swift.common.storage_policy.StoragePolicySingleton</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>An instance of this class is the primary interface to storage policies
                        exposed as a module level global named <literal>POLICIES</literal>.  This global
                        reference wraps <literal>_POLICIES</literal> which is normally instantiated by parsing
                        <literal>swift.conf</literal> and will result in an instance of
                        <xref linkend="swift.common.storage_policy.StoragePolicyCollection"/>.</para>
          <para>You should never patch this instance directly, instead patch the module
                        level <literal>_POLICIES</literal> instance so that swift code which imported
                        <literal>POLICIES</literal> directly will reference the patched
                        <xref linkend="swift.common.storage_policy.StoragePolicyCollection"/>.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.get_policy_string">
        <term>
          <function>swift.common.storage_policy.get_policy_string</function>
        </term>
        <listitem>
          <para>Helper function to construct a string from a base and the policy.
                        Used to encode the policy index into either a file name or a
                        directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.parse_storage_policies">
        <term>
          <function>swift.common.storage_policy.parse_storage_policies</function>
        </term>
        <listitem>
          <para>Parse storage policies in <literal>swift.conf</literal> - note that validation
                        is done when the <xref linkend="swift.common.storage_policy.StoragePolicyCollection"/> is instantiated.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.reload_storage_policies">
        <term>
          <function>swift.common.storage_policy.reload_storage_policies</function>
        </term>
        <listitem>
          <para>Reload POLICIES from <literal>swift.conf</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.common.storage_policy.split_policy_string">
        <term>
          <function>swift.common.storage_policy.split_policy_string</function>
        </term>
        <listitem>
          <para>Helper function to convert a string representing a base and a
                        policy.  Used to decode the policy from either a file name or
                        a directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
</section>
