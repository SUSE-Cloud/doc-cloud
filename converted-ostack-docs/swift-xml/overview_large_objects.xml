<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:id="large-objects">
  <title>Large Object Support</title>
  <section>
    <title>Overview</title>
    <para>Swift has a limit on the size of a single uploaded object; by default this is
                5GB. However, the download size of a single object is virtually unlimited with
                the concept of segmentation. Segments of the larger object are uploaded and a
                special manifest file is created that, when downloaded, sends all the segments
                concatenated as a single object. This also offers much greater upload speed
                with the possibility of parallel uploads of the segments.</para>
  </section>
  <section xml:id="dlo-doc">
    <title>Dynamic Large Objects</title>
    <para>Middleware that will provide Dynamic Large Object (DLO) support.</para>
    <section>
      <title>Using <literal>swift</literal></title>
      <para>The quickest way to try out this feature is use the <literal>swift</literal> Swift Tool
                    included with the <link xlink:href="http://github.com/openstack/python-swiftclient">python-swiftclient</link> library.  You can use the <literal>-S</literal>
                    option to specify the segment size to use when splitting a large file. For
                    example:</para>
      <screen>swift upload test_container -S 1073741824 large_file</screen>
      <para>This would split the large_file into 1G segments and begin uploading those
                    segments in parallel. Once all the segments have been uploaded, <literal>swift</literal> will
                    then create the manifest file so the segments can be downloaded as one.</para>
      <para>So now, the following <literal>swift</literal> command would download the entire large
                    object:</para>
      <screen>swift download test_container large_file</screen>
      <para><literal>swift</literal> command uses a strict convention for its segmented object
                    support. In the above example it will upload all the segments into a
                    second container named test_container_segments. These segments will
                    have names like large_file/1290206778.25/21474836480/00000000,
                    large_file/1290206778.25/21474836480/00000001, etc.</para>
      <para>The main benefit for using a separate container is that the main container
                    listings will not be polluted with all the segment names. The reason for using
                    the segment name format of &lt;name&gt;/&lt;timestamp&gt;/&lt;size&gt;/&lt;segment&gt; is so that an
                    upload of a new file with the same name won’t overwrite the contents of the
                    first until the last moment when the manifest file is updated.</para>
      <para><literal>swift</literal> will manage these segment files for you, deleting old segments on
                    deletes and overwrites, etc. You can override this behavior with the
                    <literal>--leave-segments</literal> option if desired; this is useful if you want to have
                    multiple versions of the same large object available.</para>
    </section>
    <section>
      <title>Direct API</title>
      <para>You can also work with the segments and manifests directly with HTTP
                    requests instead of having <literal>swift</literal> do that for you. You can just
                    upload the segments like you would any other object and the manifest
                    is just a zero-byte (not enforced) file with an extra
                    <literal>X-Object-Manifest</literal> header.</para>
      <para>All the object segments need to be in the same container, have a common object
                    name prefix, and sort in the order in which they should be concatenated.
                    Object names are sorted lexicographically as UTF-8 byte strings.
                    They don’t have to be in the same container as the manifest file will be, which
                    is useful to keep container listings clean as explained above with <literal>swift</literal>.</para>
      <para>The manifest file is simply a zero-byte (not enforced) file with the extra
                    <literal>X-Object-Manifest: &lt;container&gt;/&lt;prefix&gt;</literal> header, where <literal>&lt;container&gt;</literal> is
                    the container the object segments are in and <literal>&lt;prefix&gt;</literal> is the common prefix
                    for all the segments.</para>
      <para>It is best to upload all the segments first and then create or update the
                    manifest. In this way, the full object won’t be available for downloading
                    until the upload is complete. Also, you can upload a new set of segments to
                    a second location and then update the manifest to point to this new location.
                    During the upload of the new segments, the original manifest will still be
                    available to download the first set of segments.</para>
      <note>
        <para>When updating a manifest object using a POST request, a
                        <literal>X-Object-Manifest</literal> header must be included for the object to
                        continue to behave as a manifest object.</para>
        <para>The manifest file should have no content. However, this is not enforced.
                        If the manifest path itself conforms to container/prefix specified in
                        <literal>X-Object-Manifest</literal>, and if manifest has some content/data in it, it
                        would also be considered as segment and manifest’s content will be part of
                        the concatenated GET response. The order of concatenation follows the usual
                        DLO logic which is - the order of concatenation adheres to order returned
                        when segment names are sorted.</para>
      </note>
      <para>Here’s an example using <literal>curl</literal> with tiny 1-byte segments:</para>
      <screen><?dbsuse-fo font-size="8pt"?># First, upload the segments
curl -X PUT -H 'X-Auth-Token: &lt;token&gt;'         http://&lt;storage_url&gt;/container/myobject/00000001 --data-binary '1'
curl -X PUT -H 'X-Auth-Token: &lt;token&gt;'         http://&lt;storage_url&gt;/container/myobject/00000002 --data-binary '2'
curl -X PUT -H 'X-Auth-Token: &lt;token&gt;'         http://&lt;storage_url&gt;/container/myobject/00000003 --data-binary '3'

# Next, create the manifest file
curl -X PUT -H 'X-Auth-Token: &lt;token&gt;'         -H 'X-Object-Manifest: container/myobject/'         http://&lt;storage_url&gt;/container/myobject --data-binary ''

# And now we can download the segments as a single object
curl -H 'X-Auth-Token: &lt;token&gt;'         http://&lt;storage_url&gt;/container/myobject</screen>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.dlo.GetContext">
          <term>
            <literal>swift.common.middleware.dlo.GetContext</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.common.wsgi.WSGIContext"/></para>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.dlo.GetContext.handle_request">
                <term>
                  <property>swift.common.middleware.dlo.GetContext.handle_request</property>
                </term>
                <listitem>
                  <para>Take a GET or HEAD request, and if it is for a dynamic large object
                                    manifest, return an appropriate response.</para>
                  <para>Otherwise, simply pass it through.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section xml:id="slo-doc">
    <title>Static Large Objects</title>
    <para>Middleware that will provide Static Large Object (SLO) support.</para>
    <para>This feature is very similar to Dynamic Large Object (DLO) support in that
                it allows the user to upload many objects concurrently and afterwards
                download them as a single object. It is different in that it does not rely
                on eventually consistent container listings to do so. Instead, a user
                defined manifest of the object segments is used.</para>
    <section>
      <title>Uploading the Manifest</title>
      <para>After the user has uploaded the objects to be concatenated, a manifest is
                    uploaded. The request must be a PUT with the query parameter:</para>
      <screen>?multipart-manifest=put</screen>
      <para>The body of this request will be an ordered list of segment descriptions in
                    JSON format. The data to be supplied for each segment is:</para>
      <informaltable>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="16.4*"/>
          <colspec colname="c2" colwidth="83.6*"/>
          <thead>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>path</para>
              </entry>
              <entry>
                <para>the path to the segment object (not including account)
                                        /container/object_name</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>etag</para>
              </entry>
              <entry>
                <para>(optional) the ETag given back when the segment object
                                        was PUT</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>size_bytes</para>
              </entry>
              <entry>
                <para>(optional) the size of the complete segment object in
                                        bytes</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>range</para>
              </entry>
              <entry>
                <para>(optional) the (inclusive) range within the object to
                                        use as a segment. If omitted, the entire object is used.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>The format of the list will be:</para>
      <screen>[{"path": "/cont/object",
  "etag": "etagoftheobjectsegment",
  "size_bytes": 10485760,
  "range": "1048576-2097151"}, ...]</screen>
      <para>The number of object segments is limited to a configurable amount, default
                    1000. Each segment must be at least 1 byte. On upload, the middleware will
                    head every segment passed in to verify:</para>
      <procedure>
        <step>
          <para>the segment exists (i.e. the HEAD was successful);</para>
        </step>
        <step>
          <para>the segment meets minimum size requirements;</para>
        </step>
        <step>
          <para>if the user provided a non-null etag, the etag matches;</para>
        </step>
        <step>
          <para>if the user provided a non-null size_bytes, the size_bytes matches; and</para>
        </step>
        <step>
          <para>if the user provided a range, it is a singular, syntactically correct range
                                that is satisfiable given the size of the object.</para>
        </step>
      </procedure>
      <para>Note that the etag and size_bytes keys are optional; if omitted, the
                    verification is not performed. If any of the objects fail to verify (not
                    found, size/etag mismatch, below minimum size, invalid range) then the user
                    will receive a 4xx error response. If everything does match, the user will
                    receive a 2xx response and the SLO object is ready for downloading.</para>
      <para>Behind the scenes, on success, a json manifest generated from the user input is
                    sent to object servers with an extra “X-Static-Large-Object: True” header
                    and a modified Content-Type. The items in this manifest will include the etag
                    and size_bytes for each segment, regardless of whether the client specified
                    them for verification. The parameter: swift_bytes=$total_size will be
                    appended to the existing Content-Type, where total_size is the sum of all
                    the included segments’ size_bytes. This extra parameter will be hidden from
                    the user.</para>
      <para>Manifest files can reference objects in separate containers, which will improve
                    concurrent upload speed. Objects can be referenced by multiple manifests. The
                    segments of a SLO manifest can even be other SLO manifests. Treat them as any
                    other object i.e., use the Etag and Content-Length given on the PUT of the
                    sub-SLO in the manifest to the parent SLO.</para>
      <para>While uploading a manifest, a user can send Etag for verification. It needs to
                    be md5 of the segments’ etags, if there is no range specified. For example, if
                    the manifest to be uploaded looks like this:</para>
      <screen>[{"path": "/cont/object1",
  "etag": "etagoftheobjectsegment1",
  "size_bytes": 10485760},
 {"path": "/cont/object2",
  "etag": "etagoftheobjectsegment2",
  "size_bytes": 10485760}]</screen>
      <para>The Etag of the above manifest would be md5 of etagoftheobjectsegment1 and
                    etagoftheobjectsegment2. This could be computed in the following way:</para>
      <screen>echo -n 'etagoftheobjectsegment1etagoftheobjectsegment2' | md5sum</screen>
      <para>If a manifest to be uploaded with a segment range looks like this:</para>
      <screen>[{"path": "/cont/object1",
  "etag": "etagoftheobjectsegmentone",
  "size_bytes": 10485760,
  "range": "1-2"},
 {"path": "/cont/object2",
  "etag": "etagoftheobjectsegmenttwo",
  "size_bytes": 10485760,
  "range": "3-4"}]</screen>
      <para>While computing the Etag of the above manifest, internally each segment’s etag
                    will be taken in the form of ‘etagvalue:rangevalue;’. Hence the Etag of the
                    above manifest would be:</para>
      <screen>echo -n 'etagoftheobjectsegmentone:1-2;etagoftheobjectsegmenttwo:3-4;'     | md5sum</screen>
    </section>
    <section>
      <title>Range Specification</title>
      <para>Users now have the ability to specify ranges for SLO segments.
                    Users can now include an optional ‘range’ field in segment descriptions
                    to specify which bytes from the underlying object should be used for the
                    segment data. Only one range may be specified per segment.</para>
      <note>
        <para>The ‘etag’ and ‘size_bytes’ fields still describe the backing object as a
                            whole.</para>
      </note>
      <para>If a user uploads this manifest:</para>
      <screen>[{"path": "/con/obj_seg_1", "size_bytes": 2097152, "range": "0-1048576"},
 {"path": "/con/obj_seg_2", "size_bytes": 2097152,
  "range": "512-1550000"},
 {"path": "/con/obj_seg_1", "size_bytes": 2097152, "range": "-2048"}]</screen>
      <para>The segment will consist of the first 1048576 bytes of /con/obj_seg_1,
                    followed by bytes 513 through 1550000 (inclusive) of /con/obj_seg_2, and
                    finally bytes 2095104 through 2097152 (i.e., the last 2048 bytes) of
                    /con/obj_seg_1.</para>
      <note>
        <para>The minimum sized range is 1 byte. This is the same as the minimum
                            segment size.</para>
      </note>
    </section>
    <section>
      <title>Retrieving a Large Object</title>
      <para>A GET request to the manifest object will return the concatenation of the
                    objects from the manifest much like DLO. If any of the segments from the
                    manifest are not found or their Etag/Content Length have changed since upload,
                    the connection will drop. In this case a 409 Conflict will be logged in the
                    proxy logs and the user will receive incomplete results. Note that this will be
                    enforced regardless of whether the user performed per-segment validation during
                    upload.</para>
      <para>The headers from this GET or HEAD request will return the metadata attached
                    to the manifest object itself with some exceptions:</para>
      <screen>Content-Length: the total size of the SLO (the sum of the sizes of
                the segments in the manifest)
X-Static-Large-Object: True
Etag: the etag of the SLO (generated the same way as DLO)</screen>
      <para>A GET request with the query parameter:</para>
      <screen>?multipart-manifest=get</screen>
      <para>will return a transformed version of the original manifest, containing
                    additional fields and different key names. For example, the first manifest in
                    the example above would look like this:</para>
      <screen>[{"name": "/cont/object",
  "hash": "etagoftheobjectsegment",
  "bytes": 10485760,
  "range": "1048576-2097151"}, ...]</screen>
      <para>As you can see, some of the fields are renamed compared to the put request:
                    <emphasis>path</emphasis> is <emphasis>name</emphasis>, <emphasis>etag</emphasis> is <emphasis>hash</emphasis>, <emphasis>size_bytes</emphasis> is <emphasis>bytes</emphasis>.  The <emphasis>range</emphasis> field
                    remains the same (if present).</para>
      <para>A GET request with the query parameters:</para>
      <screen>?multipart-manifest=get&amp;format=raw</screen>
      <para>will return the contents of the original manifest as it was sent by the client.
                    The main purpose for both calls is solely debugging.</para>
      <para>When the manifest object is uploaded you are more or less guaranteed that
                    every segment in the manifest exists and matched the specifications.
                    However, there is nothing that prevents the user from breaking the
                    SLO download by deleting/replacing a segment referenced in the manifest. It is
                    left to the user to use caution in handling the segments.</para>
    </section>
    <section>
      <title>Deleting a Large Object</title>
      <para>A DELETE request will just delete the manifest object itself.</para>
      <para>A DELETE with a query parameter:</para>
      <screen>?multipart-manifest=delete</screen>
      <para>will delete all the segments referenced in the manifest and then the manifest
                    itself. The failure response will be similar to the bulk delete middleware.</para>
    </section>
    <section>
      <title>Modifying a Large Object</title>
      <para>PUTs / POSTs will work as expected, PUTs will just overwrite the manifest
                    object for example.</para>
    </section>
    <section>
      <title>Container Listings</title>
      <para>In a container listing the size listed for SLO manifest objects will be the
                    total_size of the concatenated segments in the manifest. The overall
                    X-Container-Bytes-Used for the container (and subsequently for the account)
                    will not reflect total_size of the manifest but the actual size of the json
                    data stored. The reason for this somewhat confusing discrepancy is we want the
                    container listing to reflect the size of the manifest object when it is
                    downloaded. We do not, however, want to count the bytes-used twice (for both
                    the manifest and the segments it’s referring to) in the container and account
                    metadata which can be used for stats purposes.</para>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.slo.SloGetContext">
          <term>
            <literal>swift.common.middleware.slo.SloGetContext</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.common.wsgi.WSGIContext"/></para>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.slo.SloGetContext.convert_segment_listing">
                <term>
                  <property>swift.common.middleware.slo.SloGetContext.convert_segment_listing</property>
                </term>
                <listitem>
                  <para>Converts the manifest data to match with the format
                                    that was put in through ?multipart-manifest=put</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.slo.SloGetContext.handle_slo_get_or_head">
                <term>
                  <property>swift.common.middleware.slo.SloGetContext.handle_slo_get_or_head</property>
                </term>
                <listitem>
                  <para>Takes a request and a start_response callable and does the normal WSGI
                                    thing with them. Returns an iterator suitable for sending up the WSGI
                                    chain.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.slo.StaticLargeObject">
          <term>
            <literal>swift.common.middleware.slo.StaticLargeObject</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <para>StaticLargeObject Middleware</para>
            <para>See above for a full description.</para>
            <para>The proxy logs created for any subrequests made will have swift.source set
                            to “SLO”.</para>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.slo.StaticLargeObject.get_segments_to_delete_iter">
                <term>
                  <property>swift.common.middleware.slo.StaticLargeObject.get_segments_to_delete_iter</property>
                </term>
                <listitem>
                  <para>A generator function to be used to delete all the segments and
                                    sub-segments referenced in a manifest.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.slo.StaticLargeObject.get_slo_segments">
                <term>
                  <property>swift.common.middleware.slo.StaticLargeObject.get_slo_segments</property>
                </term>
                <listitem>
                  <para>Performs a swob.Request and returns the SLO manifest’s segments.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.slo.StaticLargeObject.handle_multipart_delete">
                <term>
                  <property>swift.common.middleware.slo.StaticLargeObject.handle_multipart_delete</property>
                </term>
                <listitem>
                  <para>Will delete all the segments in the SLO manifest and then, if
                                    successful, will delete the manifest file.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.slo.StaticLargeObject.handle_multipart_get_or_head">
                <term>
                  <property>swift.common.middleware.slo.StaticLargeObject.handle_multipart_get_or_head</property>
                </term>
                <listitem>
                  <para>Handles the GET or HEAD of a SLO manifest.</para>
                  <para>The response body (only on GET, of course) will consist of the
                                    concatenation of the segments.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.common.middleware.slo.StaticLargeObject.handle_multipart_put">
                <term>
                  <property>swift.common.middleware.slo.StaticLargeObject.handle_multipart_put</property>
                </term>
                <listitem>
                  <para>Will handle the PUT of a SLO manifest.
                                    Heads every object in manifest to check if is valid and if so will
                                    save a manifest generated from the user input. Uses WSGIContext to
                                    call self and start_response and returns a WSGI iterator.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.common.middleware.slo.parse_and_validate_input">
          <term>
            <function>swift.common.middleware.slo.parse_and_validate_input</function>
          </term>
          <listitem>
            <para>Given a request body, parses it and returns a list of dictionaries.</para>
            <para>The output structure is nearly the same as the input structure, but it
                            is not an exact copy. Given a valid input dictionary <literal>d_in</literal>, its
                            corresponding output dictionary <literal>d_out</literal> will be as follows:</para>
            <itemizedlist>
              <listitem>
                <para>d_out[‘etag’] == d_in[‘etag’]</para>
              </listitem>
              <listitem>
                <para>d_out[‘path’] == d_in[‘path’]</para>
              </listitem>
              <listitem>
                <para>d_in[‘size_bytes’] can be a string (“12”) or an integer (12), but
                                        d_out[‘size_bytes’] is an integer.</para>
              </listitem>
              <listitem>
                <para>(optional) d_in[‘range’] is a string of the form “M-N”, “M-“, or
                                        “-N”, where M and N are non-negative integers. d_out[‘range’] is the
                                        corresponding swob.Range object. If d_in does not have a key
                                        ‘range’, neither will d_out.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section>
    <title>Direct API</title>
    <para>SLO support centers around the user generated manifest file. After the user
                has uploaded the segments into their account a manifest file needs to be
                built and uploaded. All object segments, must be at least 1 byte
                in size. Please see the SLO docs for <xref linkend="slo-doc"/> further
                details.</para>
  </section>
  <section>
    <title>Additional Notes</title>
    <itemizedlist>
      <listitem>
        <para>With a <literal>GET</literal> or <literal>HEAD</literal> of a manifest file, the <literal>X-Object-Manifest:
&lt;container&gt;/&lt;prefix&gt;</literal> header will be returned with the concatenated object
                        so you can tell where it’s getting its segments from.</para>
      </listitem>
      <listitem>
        <para>When updating a manifest object using a POST request, a
                        <literal>X-Object-Manifest</literal> header must be included for the object to
                        continue to behave as a manifest object.</para>
      </listitem>
      <listitem>
        <para>The response’s <literal>Content-Length</literal> for a <literal>GET</literal> or <literal>HEAD</literal> on the manifest
                        file will be the sum of all the segments in the <literal>&lt;container&gt;/&lt;prefix&gt;</literal>
                        listing, dynamically. So, uploading additional segments after the manifest is
                        created will cause the concatenated object to be that much larger; there’s no
                        need to recreate the manifest file.</para>
      </listitem>
      <listitem>
        <para>The response’s <literal>Content-Type</literal> for a <literal>GET</literal> or <literal>HEAD</literal> on the manifest
                        will be the same as the <literal>Content-Type</literal> set during the <literal>PUT</literal> request that
                        created the manifest. You can easily change the <literal>Content-Type</literal> by reissuing
                        the <literal>PUT</literal>.</para>
      </listitem>
      <listitem>
        <para>The response’s <literal>ETag</literal> for a <literal>GET</literal> or <literal>HEAD</literal> on the manifest file will
                        be the MD5 sum of the concatenated string of ETags for each of the segments
                        in the manifest (for DLO, from the listing <literal>&lt;container&gt;/&lt;prefix&gt;</literal>).
                        Usually in Swift the ETag is the MD5 sum of the contents of the object, and
                        that holds true for each segment independently. But it’s not meaningful to
                        generate such an ETag for the manifest itself so this method was chosen to
                        at least offer change detection.</para>
      </listitem>
    </itemizedlist>
    <note>
      <para>If you are using the container sync feature you will need to ensure both
                    your manifest file and your segment files are synced if they happen to be
                    in different containers.</para>
    </note>
  </section>
  <section>
    <title>History</title>
    <para>Dynamic large object support has gone through various iterations before
                settling on this implementation.</para>
    <para>The primary factor driving the limitation of object size in Swift is
                maintaining balance among the partitions of the ring.  To maintain an even
                dispersion of disk usage throughout the cluster the obvious storage pattern
                was to simply split larger objects into smaller segments, which could then be
                glued together during a read.</para>
    <para>Before the introduction of large object support some applications were already
                splitting their uploads into segments and re-assembling them on the client
                side after retrieving the individual pieces.  This design allowed the client
                to support backup and archiving of large data sets, but was also frequently
                employed to improve performance or reduce errors due to network interruption.
                The major disadvantage of this method is that knowledge of the original
                partitioning scheme is required to properly reassemble the object, which is
                not practical for some use cases, such as CDN origination.</para>
    <para>In order to eliminate any barrier to entry for clients wanting to store
                objects larger than 5GB, initially we also prototyped fully transparent
                support for large object uploads.  A fully transparent implementation would
                support a larger max size by automatically splitting objects into segments
                during upload within the proxy without any changes to the client API.  All
                segments were completely hidden from the client API.</para>
    <para>This solution introduced a number of challenging failure conditions into the
                cluster, wouldn’t provide the client with any option to do parallel uploads,
                and had no basis for a resume feature.  The transparent implementation was
                deemed just too complex for the benefit.</para>
    <para>The current “user manifest” design was chosen in order to provide a
                transparent download of large objects to the client and still provide the
                uploading client a clean API to support segmented uploads.</para>
    <para>To meet an many use cases as possible Swift supports two types of large
                object manifests. Dynamic and static large object manifests both support
                the same idea of allowing the user to upload many segments to be later
                downloaded as a single file.</para>
    <para>Dynamic large objects rely on a container listing to provide the manifest.
                This has the advantage of allowing the user to add/removes segments from the
                manifest at any time. It has the disadvantage of relying on eventually
                consistent container listings. All three copies of the container dbs must
                be updated for a complete list to be guaranteed. Also, all segments must
                be in a single container, which can limit concurrent upload speed.</para>
    <para>Static large objects rely on a user provided manifest file. A user can
                upload objects into multiple containers and then reference those objects
                (segments) in a self generated manifest file. Future GETs to that file will
                download the concatenation of the specified segments. This has the advantage of
                being able to immediately download the complete object once the manifest has
                been successfully PUT. Being able to upload segments into separate containers
                also improves concurrent upload speed. It has the disadvantage that the
                manifest is finalized once PUT. Any changes to it means it has to be replaced.</para>
    <para>Between these two methods the user has great flexibility in how (s)he chooses
                to upload and retrieve large objects to Swift. Swift does not, however, stop
                the user from harming themselves. In both cases the segments are deletable by
                the user at any time. If a segment was deleted by mistake, a dynamic large
                object, having no way of knowing it was ever there, would happily ignore the
                deleted file and the user will get an incomplete file. A static large object
                would, when failing to retrieve the object specified in the manifest, drop the
                connection and the user would receive partial results.</para>
  </section>
</section>
