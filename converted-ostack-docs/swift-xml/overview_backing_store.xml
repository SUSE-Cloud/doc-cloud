<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Using Swift as Backing Store for Service Data</title>
  <section>
    <title>Background</title>
    <para>This section provides guidance to OpenStack Service developers for how to
                store your users’ data in Swift. An example of this is that a user requests
                that Nova save a snapshot of a VM. Nova passes the request to Glance,
                Glance writes the image to a Swift container as a set of objects.</para>
    <para>Throughout this section, the following terminology and concepts are used:</para>
    <itemizedlist>
      <listitem>
        <para>User or end-user. This is a person making a request that will result in
                        an OpenStack Service making a request to Swift.</para>
      </listitem>
      <listitem>
        <para>Project (also known as Tenant). This is the unit of resource ownership.
                        While data such as snapshot images or block volume backups may be
                        stored as a result of an end-user’s request, the reality is that these
                        are project data.</para>
      </listitem>
      <listitem>
        <para>Service. This is a program or system used by end-users. Specifically, it
                        is any program or system that is capable of receiving end-user’s tokens and
                        validating the token with the Keystone Service and has a need to store
                        data in Swift. Glance and Cinder are examples of such Services.</para>
      </listitem>
      <listitem>
        <para>Service User. This is a Keystone user that has been assigned to a Service.
                        This allows the Service to generate and use its own tokens so that it
                        can interact with other Services as itself.</para>
      </listitem>
      <listitem>
        <para>Service Project. This is a project (tenant) that is associated with a
                        Service. There may be a single project shared by many Services or there
                        may be a project dedicated to each Service. In this document, the
                        main purpose of the Service Project is to allow the system operator
                        to configure specific roles for each Service User.</para>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Alternate Backing Store Schemes</title>
    <para>There are three schemes described here:</para>
    <itemizedlist>
      <listitem>
        <para>Dedicated Service Account (Single Tenant)</para>
        <para>Your Service has a dedicated Service Project (hence a single dedicated
                        Swift account). Data for all users and projects are stored in this
                        account. Your Service must have a user assigned to it (the Service User).
                        When you have data to store on behalf of one of your users, you use the
                        Service User credentials to get a token for the Service Project and
                        request Swift to store the data in the Service Project.</para>
        <para>With this scheme, data for all users is stored in a single account. This
                        is transparent to your users and since the credentials for the Service User
                        are typically not shared with anyone, your users’ cannot access their
                        data by making a request directly to Swift. However, since data belonging
                        to all users is stored in one account, it presents a single point of
                        vulnerably to accidental deletion or a leak of the service-user
                        credentials.</para>
      </listitem>
      <listitem>
        <para>Multi Project (Multi Tenant)</para>
        <para>Data belonging to a project is stored in the Swift account
                        associated with the project. Users make requests to your Service using
                        a token scoped to a project in the normal way. You can then use this
                        same token to store the user data in the project’s Swift account.</para>
        <para>The effect is that data is stored in multiple projects (aka tenants).
                        Hence this scheme has been known as the “multi tenant” scheme.</para>
        <para>With this scheme, access is controlled by Keystone. The users must
                        have a role that allows them to perform the request to your Service. In
                        addition, they must have a role that also allows them to store data in
                        the Swift account. By default, the admin or swiftoperator roles are
                        used for this purpose (specific systems may use other role names). If the
                        user does not have the appropriate roles, when your Service attempts
                        to access Swift, the operation will fail.</para>
        <para>Since you are using the user’s token to access the data, it follows that
                        the user can use the same token to access Swift directly – bypassing your
                        Service. When end-users are browsing containers, they will also see
                        your Service’s containers and objects – and may potentially delete
                        the data. Conversely, there is no single account where all data so leakage
                        of credentials will only affect a single project/tenant.</para>
      </listitem>
      <listitem>
        <para>Service Prefix Account</para>
        <para>Data belonging to a project is stored in a Swift account associated
                        with the project. This is similar to the Multi Project scheme described
                        above. However, the Swift account is different than the account that
                        users access. Specifically, it has a different account prefix. For example,
                        for the project 1234, the user account is named AUTH_1234. Your Service uses
                        a different account, for example, SERVICE_1234.</para>
        <para>To access the SERVICE_1234 account, you must present two tokens: the user’s
                        token is put in the X-Auth-Token header. You present your Service’s token
                        in the X-Service-Token header. Swift is configured such that only when both
                        tokens are presented will it allow access. Specifically, the user cannot
                        bypass your Service because they only have their own token. Conversely, your
                        Service can only access the data while it has a copy of the user’s token –
                        the Service’s token by itself will not grant access.</para>
        <para>The data stored in the Service Prefix Account cannot be seen by end-users.
                        So they cannot delete this data – they can only access the data if they
                        make a request through your Service. The data is also more secure. To make
                        an unauthorized access, someone would need to compromise both an end-user’s
                        and your Service User credentials. Even then, this would only expose one
                        project – not other projects.</para>
      </listitem>
    </itemizedlist>
    <para>The Service Prefix Account scheme combines features of the Dedicated Service
                Account and Multi Project schemes. It has the private, dedicated,
                characteristics of the Dedicated Service Account scheme but does not present
                a single point of attack. Using the Service Prefix Account scheme is a little
                more involved than the other schemes, so the rest of this document describes
                it more detail.</para>
  </section>
  <section>
    <title>Service Prefix Account Overview</title>
    <para>The following diagram shows the flow through the system from the end-user,
                to your Service and then onto Swift:</para>
    <screen>client
   \
    \   &lt;request&gt;: &lt;path-specific-to-the-service&gt;
     \  x-auth-token: &lt;user-token&gt;
      \
    SERVICE
       \
        \    PUT: /v1/SERVICE_1234/&lt;container&gt;/&lt;object&gt;
         \   x-auth-token: &lt;user-token&gt;
          \  x-service-token: &lt;service-token&gt;
           \
          Swift</screen>
    <para>The sequence of events and actions are as follows:</para>
    <itemizedlist>
      <listitem>
        <para>Request arrives at your Service</para>
      </listitem>
      <listitem>
        <para>The &lt;user-token&gt; is validated by the keystonemiddleware.auth_token
                        middleware. The user’s role(s) are used to determine if the user
                        can perform the request. See  for technical
                        information on the authentication system.</para>
      </listitem>
      <listitem>
        <para>As part of this request, your Service needs to access Swift (either to
                        write or read a container or object). In this example, you want to perform
                        a PUT on &lt;container&gt;/&lt;object&gt;.</para>
      </listitem>
      <listitem>
        <para>In the wsgi environment, the auth_token module will have populated the
                        HTTP_X_SERVICE_CATALOG item. This lists the Swift endpoint and account.
                        This is something such as <link xlink:href="https:/"/>/&lt;netloc&gt;/v1/AUTH_1234 where <literal>AUTH_</literal>
                        is a prefix and <literal>1234</literal> is the project id.</para>
      </listitem>
      <listitem>
        <para>The <literal>AUTH_</literal> prefix is the default value. However, your system may use a
                        different prefix. To determine the actual prefix, search for the first
                        underscore (‘_’) character in the account name. If there is no underscore
                        character in the account name, this means there is no prefix.</para>
      </listitem>
      <listitem>
        <para>Your Service should have a configuration parameter that provides the
                        appropriate prefix to use for storing data in Swift. There is more
                        discussion of this below, but for now assume the prefix is <literal>SERVICE_</literal>.</para>
      </listitem>
      <listitem>
        <para>Replace the prefix (<literal>AUTH_</literal> in above examples) in the path with
                        <literal>SERVICE_</literal>, so the full URL to access the object becomes
                        <link xlink:href="https:/"/>/&lt;netloc&gt;/v1/SERVICE_1234/&lt;container&gt;/&lt;object&gt;.</para>
      </listitem>
      <listitem>
        <para>Make the request to Swift, using this URL. In the X-Auth-Token header place
                        a copy of the &lt;user-token&gt;. In the X-Service-Token header, place your
                        Service’s token. If you use python-swiftclient you can achieve this
                        by:</para>
        <itemizedlist>
          <listitem>
            <para>Putting the URL in the <literal>preauthurl</literal> parameter</para>
          </listitem>
          <listitem>
            <para>Putting the &lt;user-token&gt; in <literal>preauthtoken</literal> parameter</para>
          </listitem>
          <listitem>
            <para>Adding the X-Service-Token to the <literal>headers</literal> parameter</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
    <section>
      <title>Using the HTTP_X_SERVICE_CATALOG to get Swift Account Name</title>
      <para>The auth_token middleware populates the wsgi environment with information when
                    it validates the user’s token. The HTTP_X_SERVICE_CATALOG item is a JSON
                    string containing  details of the OpenStack endpoints. For Swift, this also
                    contains the project’s Swift account name. Here is an example of a catalog
                    entry for Swift:</para>
      <screen>"serviceCatalog": [
    ...
    {
        ....
        "type": "object-store",
        "endpoints": [
           ...
           {
               ...
               "publicURL": "https://&lt;netloc&gt;/v1/AUTH_1234",
               "region": "&lt;region-name&gt;"
               ...
           }
           ...
     ...
     }
}</screen>
      <para>To get the End-user’s account:</para>
      <itemizedlist>
        <listitem>
          <para>Look for an entry with <literal>type</literal> of <literal>object-store</literal></para>
        </listitem>
        <listitem>
          <para>If there are several regions, there will be several endpoints. Use the
                            appropriate region name and select the <literal>publicURL</literal> item.</para>
        </listitem>
        <listitem>
          <para>The Swift account name is the final item in the path (“AUTH_1234” in this
                            example).</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Getting a Service Token</title>
      <para>A Service Token is no different than any other token and is requested
                    from Keystone using user credentials and project in the usual way. The core
                    requirement is that your Service User has the appropriate role. In practice:</para>
      <itemizedlist>
        <listitem>
          <para>Your Service must have a user assigned to it (the Service User).</para>
        </listitem>
        <listitem>
          <para>Your Service has a project assigned to it (the Service Project).</para>
        </listitem>
        <listitem>
          <para>The Service User must have a role on the Service Project. This role is
                            distinct from any of the normal end-user roles.</para>
        </listitem>
        <listitem>
          <para>The role used must the role configured in the /etc/swift/proxy-server.conf.
                            This is the <literal>&lt;prefix&gt;_service_roles</literal> option. In this example, the role
                            is the <literal>service</literal> role:</para>
          <screen>[keystoneauth]
reseller_prefix = AUTH_, SERVICE_
SERVICE_service_role = service</screen>
        </listitem>
      </itemizedlist>
      <para>The <literal>service</literal> role should only be granted to OpenStack Services. It should
                    not be granted to users.</para>
    </section>
    <section>
      <title>Single or multiple Service Prefixes?</title>
      <para>Most of the examples used in this document used a single prefix. The
                    prefix, <literal>SERVICE</literal> was used. By using a single prefix, an operator is
                    allowing all OpenStack Services to share the same account for data
                    associated with a given project. For test systems or deployments well protected
                    on private firewalled networks, this is appropriate.</para>
      <para>However, if one Service is compromised, that Service can access
                    data created by another Service. To prevent this, multiple Service Prefixes may
                    be used. This also requires that the operator configure multiple service
                    roles. For example, in a system that has Glance and Cinder, the following
                    Swift configuration could be used:</para>
      <screen>[keystoneauth]
reseller_prefix = AUTH_, IMAGE_, BLOCK_
IMAGE_service_roles = image_service
BLOCK_service_roles = block_service</screen>
      <para>The Service User for Glance would be granted the <literal>image_service</literal> role on its
                    Service Project and the Cinder Service user is granted the <literal>block_service</literal>
                    role on its project. In this scheme, if the Cinder Service was compromised,
                    it would not be able to access any Glance data.</para>
    </section>
    <section>
      <title>Container Naming</title>
      <para>Since a single Service Prefix is possible, container names should be prefixed
                    with a unique string to prevent name clashes. We suggest you use the service
                    type field (as used in the service catalog). For example, The Glance Service
                    would use “image” as a prefix.</para>
    </section>
  </section>
</section>
