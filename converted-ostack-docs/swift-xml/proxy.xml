<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Proxy</title>
  <section>
    <title>Proxy Controllers</title>
    <section>
      <title>Base</title>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.Controller">
          <term>
            <literal>swift.proxy.controllers.base.Controller</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <para>Base WSGI controller class for the proxy</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.GET">
                <term>
                  <property>swift.proxy.controllers.base.Controller.GET</property>
                </term>
                <listitem>
                  <para>Handler for HTTP GET requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.GETorHEAD_base">
                <term>
                  <property>swift.proxy.controllers.base.Controller.GETorHEAD_base</property>
                </term>
                <listitem>
                  <para>Base handler for HTTP GET or HEAD requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.HEAD">
                <term>
                  <property>swift.proxy.controllers.base.Controller.HEAD</property>
                </term>
                <listitem>
                  <para>Handler for HTTP HEAD requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.OPTIONS">
                <term>
                  <property>swift.proxy.controllers.base.Controller.OPTIONS</property>
                </term>
                <listitem>
                  <para>Base handler for OPTIONS requests</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.account_info">
                <term>
                  <property>swift.proxy.controllers.base.Controller.account_info</property>
                </term>
                <listitem>
                  <para>Get account information, and also verify that the account exists.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.allowed_methods">
                <term>
                  <property>swift.proxy.controllers.base.Controller.allowed_methods</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.autocreate_account">
                <term>
                  <property>swift.proxy.controllers.base.Controller.autocreate_account</property>
                </term>
                <listitem>
                  <para>Autocreate an account</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.best_response">
                <term>
                  <property>swift.proxy.controllers.base.Controller.best_response</property>
                </term>
                <listitem>
                  <para>Given a list of responses from several servers, choose the best to
                                    return to the API.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.container_info">
                <term>
                  <property>swift.proxy.controllers.base.Controller.container_info</property>
                </term>
                <listitem>
                  <para>Get container information and thusly verify container existence.
                                    This will also verify account existence.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.generate_request_headers">
                <term>
                  <property>swift.proxy.controllers.base.Controller.generate_request_headers</property>
                </term>
                <listitem>
                  <para>Create a list of headers to be used in backend requests</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.have_quorum">
                <term>
                  <property>swift.proxy.controllers.base.Controller.have_quorum</property>
                </term>
                <listitem>
                  <para>Given a list of statuses from several requests, determine if
                                    a quorum response can already be decided.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.is_origin_allowed">
                <term>
                  <property>swift.proxy.controllers.base.Controller.is_origin_allowed</property>
                </term>
                <listitem>
                  <para>Is the given Origin allowed to make requests to this resource</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.make_requests">
                <term>
                  <property>swift.proxy.controllers.base.Controller.make_requests</property>
                </term>
                <listitem>
                  <para>Sends an HTTP request to multiple nodes and aggregates the results.
                                    It attempts the primary nodes concurrently, then iterates over the
                                    handoff nodes as needed.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.pass_through_headers">
                <term>
                  <property>swift.proxy.controllers.base.Controller.pass_through_headers</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.server_type">
                <term>
                  <property>swift.proxy.controllers.base.Controller.server_type</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.Controller.transfer_headers">
                <term>
                  <property>swift.proxy.controllers.base.Controller.transfer_headers</property>
                </term>
                <listitem>
                  <para>Transfer legal headers from an original client request to dictionary
                                    that will be used as headers by the backend request</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.GetOrHeadHandler">
          <term>
            <literal>swift.proxy.controllers.base.GetOrHeadHandler</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.proxy.controllers.base.ResumingGetter"/></para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.GetOrHeadHandler.get_working_response">
                <term>
                  <property>swift.proxy.controllers.base.GetOrHeadHandler.get_working_response</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.NodeIter">
          <term>
            <literal>swift.proxy.controllers.base.NodeIter</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <para>Yields nodes for a ring partition, skipping over error
                            limited nodes and stopping at the configurable number of nodes. If a
                            node yielded subsequently gets error limited, an extra node will be
                            yielded to take its place.</para>
            <para>Note that if you’re going to iterate over this concurrently from
                            multiple greenthreads, you’ll want to use a
                            swift.common.utils.GreenthreadSafeIterator to serialize access.
                            Otherwise, you may get ValueErrors from concurrent access. (You also
                            may not, depending on how logging is configured, the vagaries of
                            socket IO and eventlet, and the phase of the moon.)</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.NodeIter.log_handoffs">
                <term>
                  <property>swift.proxy.controllers.base.NodeIter.log_handoffs</property>
                </term>
                <listitem>
                  <para>Log handoff requests if handoff logging is enabled and the
                                    handoff was not expected.</para>
                  <para>We only log handoffs when we’ve pushed the handoff count further
                                    than we would normally have expected under normal circumstances,
                                    that is (request_node_count - num_primaries), when handoffs goes
                                    higher than that it means one of the primaries must have been
                                    skipped because of error limiting before we consumed all of our
                                    nodes_left.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.NodeIter.next">
                <term>
                  <property>swift.proxy.controllers.base.NodeIter.next</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.NodeIter.set_node_provider">
                <term>
                  <property>swift.proxy.controllers.base.NodeIter.set_node_provider</property>
                </term>
                <listitem>
                  <para>Install a callback function that will be used during a call to next()
                                    to get an alternate node instead of returning the next node from the
                                    iterator.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.ResumingGetter">
          <term>
            <literal>swift.proxy.controllers.base.ResumingGetter</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.ResumingGetter.fast_forward">
                <term>
                  <property>swift.proxy.controllers.base.ResumingGetter.fast_forward</property>
                </term>
                <listitem>
                  <para>Will skip num_bytes into the current ranges.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.ResumingGetter.is_good_source">
                <term>
                  <property>swift.proxy.controllers.base.ResumingGetter.is_good_source</property>
                </term>
                <listitem>
                  <para>Indicates whether or not the request made to the backend found
                                    what it was looking for.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.ResumingGetter.last_headers">
                <term>
                  <property>swift.proxy.controllers.base.ResumingGetter.last_headers</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.ResumingGetter.last_status">
                <term>
                  <property>swift.proxy.controllers.base.ResumingGetter.last_status</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.ResumingGetter.learn_size_from_content_range">
                <term>
                  <property>swift.proxy.controllers.base.ResumingGetter.learn_size_from_content_range</property>
                </term>
                <listitem>
                  <para>If client_chunk_size is set, makes sure we yield things starting on
                                    chunk boundaries based on the Content-Range header in the response.</para>
                  <para>Sets our Range header’s first byterange to the value learned from
                                    the Content-Range header in the response; if we were given a
                                    fully-specified range (e.g. “bytes=123-456”), this is a no-op.</para>
                  <para>If we were given a half-specified range (e.g. “bytes=123-” or
                                    “bytes=-456”), then this changes the Range header to a
                                    semantically-equivalent one <emphasis>and</emphasis> it lets us resume on a proper
                                    boundary instead of just in the middle of a piece somewhere.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.ResumingGetter.pop_range">
                <term>
                  <property>swift.proxy.controllers.base.ResumingGetter.pop_range</property>
                </term>
                <listitem>
                  <para>Remove the first byterange from our Range header.</para>
                  <para>This is used after a byterange has been completely sent to the
                                    client; this way, should we need to resume the download from another
                                    object server, we do not re-fetch byteranges that the client already
                                    has.</para>
                  <para>If we have no Range header, this is a no-op.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.base.ResumingGetter.response_parts_iter">
                <term>
                  <property>swift.proxy.controllers.base.ResumingGetter.response_parts_iter</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.bytes_to_skip">
          <term>
            <function>swift.proxy.controllers.base.bytes_to_skip</function>
          </term>
          <listitem>
            <para>Assume an object is composed of N records, where the first N-1 are all
                            the same size and the last is at most that large, but may be smaller.</para>
            <para>When a range request is made, it might start with a partial record. This
                            must be discarded, lest the consumer get bad data. This is particularly
                            true of suffix-byte-range requests, e.g. “Range: bytes=-12345” where the
                            size of the object is unknown at the time the request is made.</para>
            <para>This function computes the number of bytes that must be discarded to
                            ensure only whole records are yielded. Erasure-code decoding needs this.</para>
            <para>This function could have been inlined, but it took enough tries to get
                            right that some targeted unit tests were desirable, hence its extraction.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.clear_info_cache">
          <term>
            <function>swift.proxy.controllers.base.clear_info_cache</function>
          </term>
          <listitem>
            <para>Clear the cached info in both memcache and env</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.close_swift_conn">
          <term>
            <function>swift.proxy.controllers.base.close_swift_conn</function>
          </term>
          <listitem>
            <para>Force close the http connection to the backend.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.cors_validation">
          <term>
            <function>swift.proxy.controllers.base.cors_validation</function>
          </term>
          <listitem>
            <para>Decorator to check if the request is a CORS request and if so, if it’s
                            valid.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.delay_denial">
          <term>
            <function>swift.proxy.controllers.base.delay_denial</function>
          </term>
          <listitem>
            <para>Decorator to declare which methods should have any swift.authorize call
                            delayed. This is so the method can load the Request object up with
                            additional information that may be needed by the authorization system.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.get_account_info">
          <term>
            <function>swift.proxy.controllers.base.get_account_info</function>
          </term>
          <listitem>
            <para>Get the info structure for an account, based on env and app.
                            This is useful to middlewares.</para>
            <note>
              <para>This call bypasses auth. Success does not imply that the request has
                                authorization to the account.</para>
            </note>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.get_cache_key">
          <term>
            <function>swift.proxy.controllers.base.get_cache_key</function>
          </term>
          <listitem>
            <para>Get the keys for both memcache and env[‘swift.infocache’] (cache_key)
                            where info about accounts, containers, and objects is cached</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.get_container_info">
          <term>
            <function>swift.proxy.controllers.base.get_container_info</function>
          </term>
          <listitem>
            <para>Get the info structure for a container, based on env and app.
                            This is useful to middlewares.</para>
            <note>
              <para>This call bypasses auth. Success does not imply that the request has
                                authorization to the container.</para>
            </note>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.get_info">
          <term>
            <function>swift.proxy.controllers.base.get_info</function>
          </term>
          <listitem>
            <para>Get info about accounts or containers</para>
            <variablelist>
              <varlistentry>
                <term>Note: This call bypasses auth. Success does not imply that the</term>
                <listitem>
                  <para>request has authorization to the info.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.get_object_info">
          <term>
            <function>swift.proxy.controllers.base.get_object_info</function>
          </term>
          <listitem>
            <para>Get the info structure for an object, based on env and app.
                            This is useful to middlewares.</para>
            <note>
              <para>This call bypasses auth. Success does not imply that the request has
                                authorization to the object.</para>
            </note>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.headers_to_account_info">
          <term>
            <function>swift.proxy.controllers.base.headers_to_account_info</function>
          </term>
          <listitem>
            <para>Construct a cacheable dict of account info based on response headers.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.headers_to_container_info">
          <term>
            <function>swift.proxy.controllers.base.headers_to_container_info</function>
          </term>
          <listitem>
            <para>Construct a cacheable dict of container info based on response headers.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.headers_to_object_info">
          <term>
            <function>swift.proxy.controllers.base.headers_to_object_info</function>
          </term>
          <listitem>
            <para>Construct a cacheable dict of object info based on response headers.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.set_info_cache">
          <term>
            <function>swift.proxy.controllers.base.set_info_cache</function>
          </term>
          <listitem>
            <para>Cache info in both memcache and env.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.set_object_info_cache">
          <term>
            <function>swift.proxy.controllers.base.set_object_info_cache</function>
          </term>
          <listitem>
            <para>Cache object info in the WSGI environment, but not in memcache. Caching
                            in memcache would lead to cache pressure and mass evictions due to the
                            large number of objects in a typical Swift cluster. This is a
                            per-request cache only.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.source_key">
          <term>
            <function>swift.proxy.controllers.base.source_key</function>
          </term>
          <listitem>
            <para>Provide the timestamp of the swift http response as a floating
                            point value.  Used as a sort key.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.base.update_headers">
          <term>
            <function>swift.proxy.controllers.base.update_headers</function>
          </term>
          <listitem>
            <para>Helper function to update headers in the response.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section>
      <title>Account</title>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.account.AccountController">
          <term>
            <literal>swift.proxy.controllers.account.AccountController</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.proxy.controllers.base.Controller"/></para>
            <para>WSGI controller for account requests</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.account.AccountController.DELETE">
                <term>
                  <property>swift.proxy.controllers.account.AccountController.DELETE</property>
                </term>
                <listitem>
                  <para>HTTP DELETE request handler.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.account.AccountController.GETorHEAD">
                <term>
                  <property>swift.proxy.controllers.account.AccountController.GETorHEAD</property>
                </term>
                <listitem>
                  <para>Handler for HTTP GET/HEAD requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.account.AccountController.POST">
                <term>
                  <property>swift.proxy.controllers.account.AccountController.POST</property>
                </term>
                <listitem>
                  <para>HTTP POST request handler.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.account.AccountController.PUT">
                <term>
                  <property>swift.proxy.controllers.account.AccountController.PUT</property>
                </term>
                <listitem>
                  <para>HTTP PUT request handler.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.account.AccountController.add_acls_from_sys_metadata">
                <term>
                  <property>swift.proxy.controllers.account.AccountController.add_acls_from_sys_metadata</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.account.AccountController.server_type">
                <term>
                  <property>swift.proxy.controllers.account.AccountController.server_type</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section>
      <title>Container</title>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.container.ContainerController">
          <term>
            <literal>swift.proxy.controllers.container.ContainerController</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.proxy.controllers.base.Controller"/></para>
            <para>WSGI controller for container requests</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.container.ContainerController.DELETE">
                <term>
                  <property>swift.proxy.controllers.container.ContainerController.DELETE</property>
                </term>
                <listitem>
                  <para>HTTP DELETE request handler.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.container.ContainerController.GET">
                <term>
                  <property>swift.proxy.controllers.container.ContainerController.GET</property>
                </term>
                <listitem>
                  <para>Handler for HTTP GET requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.container.ContainerController.GETorHEAD">
                <term>
                  <property>swift.proxy.controllers.container.ContainerController.GETorHEAD</property>
                </term>
                <listitem>
                  <para>Handler for HTTP GET/HEAD requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.container.ContainerController.HEAD">
                <term>
                  <property>swift.proxy.controllers.container.ContainerController.HEAD</property>
                </term>
                <listitem>
                  <para>Handler for HTTP HEAD requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.container.ContainerController.POST">
                <term>
                  <property>swift.proxy.controllers.container.ContainerController.POST</property>
                </term>
                <listitem>
                  <para>HTTP POST request handler.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.container.ContainerController.PUT">
                <term>
                  <property>swift.proxy.controllers.container.ContainerController.PUT</property>
                </term>
                <listitem>
                  <para>HTTP PUT request handler.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.container.ContainerController.clean_acls">
                <term>
                  <property>swift.proxy.controllers.container.ContainerController.clean_acls</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.container.ContainerController.pass_through_headers">
                <term>
                  <property>swift.proxy.controllers.container.ContainerController.pass_through_headers</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.container.ContainerController.server_type">
                <term>
                  <property>swift.proxy.controllers.container.ContainerController.server_type</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section>
      <title>Object</title>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.BaseObjectController">
          <term>
            <literal>swift.proxy.controllers.obj.BaseObjectController</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.proxy.controllers.base.Controller"/></para>
            <para>Base WSGI controller for object requests.</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.BaseObjectController.DELETE">
                <term>
                  <property>swift.proxy.controllers.obj.BaseObjectController.DELETE</property>
                </term>
                <listitem>
                  <para>HTTP DELETE request handler.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.BaseObjectController.GET">
                <term>
                  <property>swift.proxy.controllers.obj.BaseObjectController.GET</property>
                </term>
                <listitem>
                  <para>Handler for HTTP GET requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.BaseObjectController.GETorHEAD">
                <term>
                  <property>swift.proxy.controllers.obj.BaseObjectController.GETorHEAD</property>
                </term>
                <listitem>
                  <para>Handle HTTP GET or HEAD requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.BaseObjectController.HEAD">
                <term>
                  <property>swift.proxy.controllers.obj.BaseObjectController.HEAD</property>
                </term>
                <listitem>
                  <para>Handler for HTTP HEAD requests.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.BaseObjectController.POST">
                <term>
                  <property>swift.proxy.controllers.obj.BaseObjectController.POST</property>
                </term>
                <listitem>
                  <para>HTTP POST request handler.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.BaseObjectController.PUT">
                <term>
                  <property>swift.proxy.controllers.obj.BaseObjectController.PUT</property>
                </term>
                <listitem>
                  <para>HTTP PUT request handler.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.BaseObjectController.iter_nodes_local_first">
                <term>
                  <property>swift.proxy.controllers.obj.BaseObjectController.iter_nodes_local_first</property>
                </term>
                <listitem>
                  <para>Yields nodes for a ring partition.</para>
                  <para>If the ‘write_affinity’ setting is non-empty, then this will yield N
                                    local nodes (as defined by the write_affinity setting) first, then the
                                    rest of the nodes as normal. It is a re-ordering of the nodes such
                                    that the local ones come first; no node is omitted. The effect is
                                    that the request will be serviced by local object servers first, but
                                    nonlocal ones will be employed if not enough local ones are available.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.BaseObjectController.server_type">
                <term>
                  <property>swift.proxy.controllers.obj.BaseObjectController.server_type</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.ECAppIter">
          <term>
            <literal>swift.proxy.controllers.obj.ECAppIter</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <para>WSGI iterable that decodes EC fragment archives (or portions thereof)
                            into the original object (or portions thereof).</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECAppIter.app_iter_range">
                <term>
                  <property>swift.proxy.controllers.obj.ECAppIter.app_iter_range</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECAppIter.app_iter_ranges">
                <term>
                  <property>swift.proxy.controllers.obj.ECAppIter.app_iter_ranges</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECAppIter.close">
                <term>
                  <property>swift.proxy.controllers.obj.ECAppIter.close</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECAppIter.kickoff">
                <term>
                  <property>swift.proxy.controllers.obj.ECAppIter.kickoff</property>
                </term>
                <listitem>
                  <para>Start pulling data from the backends so that we can learn things like
                                    the real Content-Type that might only be in the multipart/byteranges
                                    response body. Update our response accordingly.</para>
                  <para>Also, this is the first point at which we can learn the MIME
                                    boundary that our response has in the headers. We grab that so we
                                    can also use it in the body.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseBucket">
          <term>
            <literal>swift.proxy.controllers.obj.ECGetResponseBucket</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <para>A helper class to encapsulate the properties of buckets in which fragment
                            getters and alternate nodes are collected.</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseBucket.add_alternate_nodes">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseBucket.add_alternate_nodes</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseBucket.add_response">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseBucket.add_response</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseBucket.get_responses">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseBucket.get_responses</property>
                </term>
                <listitem>
                  <para>Return a list of all useful sources. Where there are multiple sources
                                    associated with the same frag_index then only one is included.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseBucket.set_durable">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseBucket.set_durable</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseBucket.shortfall">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseBucket.shortfall</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseBucket.shortfall_with_alts">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseBucket.shortfall_with_alts</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseCollection">
          <term>
            <literal>swift.proxy.controllers.obj.ECGetResponseCollection</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <para>Manages all successful EC GET responses gathered by ResumingGetters.</para>
            <para>A response comprises a tuple of (&lt;getter instance&gt;, &lt;parts iterator&gt;). All
                            responses having the same data timestamp are placed in an
                            ECGetResponseBucket for that timestamp. The buckets are stored in the
                            ‘buckets’ dict which maps timestamp-&gt; bucket.</para>
            <para>This class encapsulates logic for selecting the best bucket from the
                            collection, and for choosing alternate nodes.</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseCollection.add_response">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseCollection.add_response</property>
                </term>
                <listitem>
                  <para>Add a response to the collection.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseCollection.best_bucket">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseCollection.best_bucket</property>
                </term>
                <listitem>
                  <para>Return the best bucket in the collection.</para>
                  <para>The “best” bucket is the newest timestamp with sufficient getters, or
                                    the closest to having sufficient getters, unless it is bettered by a
                                    bucket with potential alternate nodes.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseCollection.get_extra_headers">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseCollection.get_extra_headers</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseCollection.has_alternate_node">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseCollection.has_alternate_node</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECGetResponseCollection.provide_alternate_node">
                <term>
                  <property>swift.proxy.controllers.obj.ECGetResponseCollection.provide_alternate_node</property>
                </term>
                <listitem>
                  <para>Callback function that is installed in a NodeIter. Called on every call
                                    to NodeIter.next(), which means we can track the number of nodes to
                                    which GET requests have been made and selectively inject an alternate
                                    node, if we have one.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.ECObjectController">
          <term>
            <literal>swift.proxy.controllers.obj.ECObjectController</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.proxy.controllers.obj.BaseObjectController"/></para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ECObjectController.policy_type">
                <term>
                  <property>swift.proxy.controllers.obj.ECObjectController.policy_type</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.MIMEPutter">
          <term>
            <literal>swift.proxy.controllers.obj.MIMEPutter</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.proxy.controllers.obj.Putter"/></para>
            <para>Putter for backend PUT requests that use MIME.</para>
            <para>This is here mostly to wrap up the fact that all multipart PUTs are
                            chunked because of the mime boundary footer trick and the first
                            half of the two-phase PUT conversation handling.</para>
            <para>An HTTP PUT request that supports streaming.</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.MIMEPutter.connect">
                <term>
                  <property>swift.proxy.controllers.obj.MIMEPutter.connect</property>
                </term>
                <listitem>
                  <para>Connect to a backend node and send the headers.</para>
                  <para>Override superclass method to notify object of need for support for
                                    multipart body with footers and optionally multiphase commit, and
                                    verify object server’s capabilities.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.MIMEPutter.end_of_object_data">
                <term>
                  <property>swift.proxy.controllers.obj.MIMEPutter.end_of_object_data</property>
                </term>
                <listitem>
                  <para>Call when there is no more data to send.</para>
                  <para>Overrides superclass implementation to send any footer metadata
                                    after object data.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.MIMEPutter.send_commit_confirmation">
                <term>
                  <property>swift.proxy.controllers.obj.MIMEPutter.send_commit_confirmation</property>
                </term>
                <listitem>
                  <para>Call when there are &gt; quorum 2XX responses received.  Send commit
                                    confirmations to all object nodes to finalize the PUT.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.ObjectControllerRouter">
          <term>
            <literal>swift.proxy.controllers.obj.ObjectControllerRouter</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ObjectControllerRouter.policy_type_to_controller_map">
                <term>
                  <property>swift.proxy.controllers.obj.ObjectControllerRouter.policy_type_to_controller_map</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ObjectControllerRouter.register">
                <term>
                  <property>swift.proxy.controllers.obj.ObjectControllerRouter.register</property>
                </term>
                <listitem>
                  <para>Decorator for Storage Policy implementations to register
                                    their ObjectController implementations.</para>
                  <para>This also fills in a policy_type attribute on the class.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.Putter">
          <term>
            <literal>swift.proxy.controllers.obj.Putter</literal>
          </term>
          <listitem>
            <para>Bases: <literal>object</literal></para>
            <para>Putter for backend PUT requests.</para>
            <para>Encapsulates all the actions required to establish a connection with a
                            storage node and stream data to that node.</para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.Putter.await_response">
                <term>
                  <property>swift.proxy.controllers.obj.Putter.await_response</property>
                </term>
                <listitem>
                  <para>Get 100-continue response indicating the end of 1st phase of a 2-phase
                                    commit or the final response, i.e. the one with status &gt;= 200.</para>
                  <para>Might or might not actually wait for anything. If we said Expect:
                                    100-continue but got back a non-100 response, that’ll be the thing
                                    returned, and we won’t do any network IO to get it. OTOH, if we got
                                    a 100 Continue response and sent up the PUT request’s body, then
                                    we’ll actually read the 2xx-5xx response off the network here.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.Putter.close">
                <term>
                  <property>swift.proxy.controllers.obj.Putter.close</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.Putter.connect">
                <term>
                  <property>swift.proxy.controllers.obj.Putter.connect</property>
                </term>
                <listitem>
                  <para>Connect to a backend node and send the headers.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.Putter.end_of_object_data">
                <term>
                  <property>swift.proxy.controllers.obj.Putter.end_of_object_data</property>
                </term>
                <listitem>
                  <para>Call when there is no more data to send.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.Putter.send_chunk">
                <term>
                  <property>swift.proxy.controllers.obj.Putter.send_chunk</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.Putter.spawn_sender_greenthread">
                <term>
                  <property>swift.proxy.controllers.obj.Putter.spawn_sender_greenthread</property>
                </term>
                <listitem>
                  <para>Call before sending the first chunk of request body</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.Putter.wait">
                <term>
                  <property>swift.proxy.controllers.obj.Putter.wait</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.ReplicatedObjectController">
          <term>
            <literal>swift.proxy.controllers.obj.ReplicatedObjectController</literal>
          </term>
          <listitem>
            <para>Bases: <xref linkend="swift.proxy.controllers.obj.BaseObjectController"/></para>
            <variablelist>
              <varlistentry xml:id="swift.proxy.controllers.obj.ReplicatedObjectController.policy_type">
                <term>
                  <property>swift.proxy.controllers.obj.ReplicatedObjectController.policy_type</property>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.check_content_type">
          <term>
            <function>swift.proxy.controllers.obj.check_content_type</function>
          </term>
          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.chunk_transformer">
          <term>
            <function>swift.proxy.controllers.obj.chunk_transformer</function>
          </term>
          <listitem>
            <para>A generator to transform a source chunk to erasure coded chunks for each
                            <literal>send</literal> call. The number of erasure coded chunks is as
                            policy.ec_n_unique_fragments.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.client_range_to_segment_range">
          <term>
            <function>swift.proxy.controllers.obj.client_range_to_segment_range</function>
          </term>
          <listitem>
            <para>Takes a byterange from the client and converts it into a byterange
                            spanning the necessary segments.</para>
            <para>Handles prefix, suffix, and fully-specified byte ranges.</para>
            <variablelist>
              <varlistentry>
                <term>Examples:</term>
                <listitem>
                  <para>client_range_to_segment_range(100, 700, 512) = (0, 1023)
                                        client_range_to_segment_range(100, 700, 256) = (0, 767)
                                        client_range_to_segment_range(300, None, 256) = (256, None)</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.segment_range_to_fragment_range">
          <term>
            <function>swift.proxy.controllers.obj.segment_range_to_fragment_range</function>
          </term>
          <listitem>
            <para>Takes a byterange spanning some segments and converts that into a
                            byterange spanning the corresponding fragments within their fragment
                            archives.</para>
            <para>Handles prefix, suffix, and fully-specified byte ranges.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry xml:id="swift.proxy.controllers.obj.trailing_metadata">
          <term>
            <function>swift.proxy.controllers.obj.trailing_metadata</function>
          </term>
          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section xml:id="proxy-server">
    <title>Proxy Server</title>
    <variablelist>
      <varlistentry xml:id="swift.proxy.server.Application">
        <term>
          <literal>swift.proxy.server.Application</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>WSGI application for the proxy server.</para>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.check_config">
              <term>
                <property>swift.proxy.server.Application.check_config</property>
              </term>
              <listitem>
                <para>Check the configuration for possible errors</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.error_limit">
              <term>
                <property>swift.proxy.server.Application.error_limit</property>
              </term>
              <listitem>
                <para>Mark a node as error limited. This immediately pretends the
                                node received enough errors to trigger error suppression. Use
                                this for errors like Insufficient Storage. For other errors
                                use <xref linkend="swift.proxy.server.Application.error_occurred"/>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.error_limited">
              <term>
                <property>swift.proxy.server.Application.error_limited</property>
              </term>
              <listitem>
                <para>Check if the node is currently error limited.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.error_occurred">
              <term>
                <property>swift.proxy.server.Application.error_occurred</property>
              </term>
              <listitem>
                <para>Handle logging, and handling of errors.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.exception_occurred">
              <term>
                <property>swift.proxy.server.Application.exception_occurred</property>
              </term>
              <listitem>
                <para>Handle logging of generic exceptions.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.get_controller">
              <term>
                <property>swift.proxy.server.Application.get_controller</property>
              </term>
              <listitem>
                <para>Get the controller to handle a request.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.get_object_ring">
              <term>
                <property>swift.proxy.server.Application.get_object_ring</property>
              </term>
              <listitem>
                <para>Get the ring object to use to handle a request based on its policy.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.get_policy_options">
              <term>
                <property>swift.proxy.server.Application.get_policy_options</property>
              </term>
              <listitem>
                <para>Return policy specific options.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.handle_request">
              <term>
                <property>swift.proxy.server.Application.handle_request</property>
              </term>
              <listitem>
                <para>Entry point for proxy server.
                                Should return a WSGI-style callable (such as swob.Response).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.iter_nodes">
              <term>
                <property>swift.proxy.server.Application.iter_nodes</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.modify_wsgi_pipeline">
              <term>
                <property>swift.proxy.server.Application.modify_wsgi_pipeline</property>
              </term>
              <listitem>
                <para>Called during WSGI pipeline creation. Modifies the WSGI pipeline
                                context to ensure that mandatory middleware is present in the pipeline.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.set_node_timing">
              <term>
                <property>swift.proxy.server.Application.set_node_timing</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.sort_nodes">
              <term>
                <property>swift.proxy.server.Application.sort_nodes</property>
              </term>
              <listitem>
                <para>Sorts nodes in-place (and returns the sorted list) according to
                                the configured strategy. The default “sorting” is to randomly
                                shuffle the nodes. If the “timing” strategy is chosen, the nodes
                                are sorted according to the stored timing data.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.proxy.server.Application.update_request">
              <term>
                <property>swift.proxy.server.Application.update_request</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.proxy.server.ProxyOverrideOptions">
        <term>
          <literal>swift.proxy.server.ProxyOverrideOptions</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Encapsulates proxy server options that may be overridden e.g. for
                        policy specific configurations.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.proxy.server.app_factory">
        <term>
          <function>swift.proxy.server.app_factory</function>
        </term>
        <listitem>
          <para>paste.deploy app factory for creating WSGI proxy apps.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.proxy.server.parse_per_policy_config">
        <term>
          <function>swift.proxy.server.parse_per_policy_config</function>
        </term>
        <listitem>
          <para>Search the config file for any per-policy config sections and load those
                        sections to a dict mapping policy reference (name or index) to policy
                        options.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
</section>
