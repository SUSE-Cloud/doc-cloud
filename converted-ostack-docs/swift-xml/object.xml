<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Object</title>
  <section xml:id="object-auditor">
    <title>Object Auditor</title>
    <variablelist>
      <varlistentry xml:id="swift.obj.auditor.AuditorWorker">
        <term>
          <literal>swift.obj.auditor.AuditorWorker</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Walk through file system to audit objects</para>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.AuditorWorker.audit_all_objects">
              <term>
                <property>swift.obj.auditor.AuditorWorker.audit_all_objects</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.AuditorWorker.create_recon_nested_dict">
              <term>
                <property>swift.obj.auditor.AuditorWorker.create_recon_nested_dict</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.AuditorWorker.failsafe_object_audit">
              <term>
                <property>swift.obj.auditor.AuditorWorker.failsafe_object_audit</property>
              </term>
              <listitem>
                <para>Entrypoint to object_audit, with a failsafe generic exception handler.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.AuditorWorker.object_audit">
              <term>
                <property>swift.obj.auditor.AuditorWorker.object_audit</property>
              </term>
              <listitem>
                <para>Audits the given object location.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.AuditorWorker.record_stats">
              <term>
                <property>swift.obj.auditor.AuditorWorker.record_stats</property>
              </term>
              <listitem>
                <para>Based on config’s object_size_stats will keep track of how many objects
                                fall into the specified ranges. For example with the following:</para>
                <para>object_size_stats = 10, 100, 1024</para>
                <para>and your system has 3 objects of sizes: 5, 20, and 10000 bytes the log
                                will look like: {“10”: 1, “100”: 1, “1024”: 0, “OVER”: 1}</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.auditor.ObjectAuditor">
        <term>
          <literal>swift.obj.auditor.ObjectAuditor</literal>
        </term>
        <listitem>
          <para>Bases: <literal>swift.common.daemon.Daemon</literal></para>
          <para>Audit objects.</para>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.ObjectAuditor.audit_loop">
              <term>
                <property>swift.obj.auditor.ObjectAuditor.audit_loop</property>
              </term>
              <listitem>
                <para>Parallel audit loop</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.ObjectAuditor.clear_recon_cache">
              <term>
                <property>swift.obj.auditor.ObjectAuditor.clear_recon_cache</property>
              </term>
              <listitem>
                <para>Clear recon cache entries</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.ObjectAuditor.fork_child">
              <term>
                <property>swift.obj.auditor.ObjectAuditor.fork_child</property>
              </term>
              <listitem>
                <para>Child execution</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.ObjectAuditor.run_audit">
              <term>
                <property>swift.obj.auditor.ObjectAuditor.run_audit</property>
              </term>
              <listitem>
                <para>Run the object audit</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.ObjectAuditor.run_forever">
              <term>
                <property>swift.obj.auditor.ObjectAuditor.run_forever</property>
              </term>
              <listitem>
                <para>Run the object audit until stopped.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.auditor.ObjectAuditor.run_once">
              <term>
                <property>swift.obj.auditor.ObjectAuditor.run_once</property>
              </term>
              <listitem>
                <para>Run the object audit once</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Object Backend</title>
    <para>Disk File Interface for the Swift Object Server</para>
    <para>The <literal>DiskFile</literal>, <literal>DiskFileWriter</literal> and <literal>DiskFileReader</literal> classes combined define
                the on-disk abstraction layer for supporting the object server REST API
                interfaces (excluding <literal>REPLICATE</literal>). Other implementations wishing to provide
                an alternative backend for the object server must implement the three
                classes. An example alternative implementation can be found in the
                <literal>mem_server.py</literal> and <literal>mem_diskfile.py</literal> modules along size this one.</para>
    <para>The <literal>DiskFileManager</literal> is a reference implemenation specific class and is not
                part of the backend API.</para>
    <para>The remaining methods in this module are considered implementation specific and
                are also not considered part of the backend API.</para>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.AuditLocation">
        <term>
          <literal>swift.obj.diskfile.AuditLocation</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Represents an object location to be audited.</para>
          <para>Other than being a bucket of data, the only useful thing this does is
                        stringify to a filesystem path so the auditor’s logs look okay.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile">
        <term>
          <literal>swift.obj.diskfile.BaseDiskFile</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Manage object files.</para>
          <para>This specific implementation manages object files on a disk formatted with
                        a POSIX-compliant file system that supports extended attributes as
                        metadata on a file or directory.</para>
          <note>
            <para>The arguments to the constructor are considered implementation
                            specific. The API does not define the constructor arguments.</para>
            <para>The following path format is used for data file locations:
                            &lt;devices_path/&lt;device_dir&gt;/&lt;datadir&gt;/&lt;partdir&gt;/&lt;suffixdir&gt;/&lt;hashdir&gt;/
                            &lt;datafile&gt;.&lt;ext&gt;</para>
          </note>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.account">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.account</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.container">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.container</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.content_length">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.content_length</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.content_type">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.content_type</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.content_type_timestamp">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.content_type_timestamp</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.create">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.create</property>
              </term>
              <listitem>
                <para>Context manager to create a file. We create a temporary file first, and
                                then return a DiskFileWriter object to encapsulate the state.</para>
                <note>
                  <para>An implementation is not required to perform on-disk
                                    preallocations even if the parameter is specified. But if it does
                                    and it fails, it must raise a <literal>DiskFileNoSpace</literal> exception.</para>
                </note>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.data_timestamp">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.data_timestamp</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.delete">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.delete</property>
              </term>
              <listitem>
                <para>Delete the object.</para>
                <para>This implementation creates a tombstone file using the given
                                timestamp, and removes any older versions of the object file. Any
                                file that has an older timestamp than timestamp will be deleted.</para>
                <note>
                  <para>An implementation is free to use or ignore the timestamp
                                    parameter.</para>
                </note>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.durable_timestamp">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.durable_timestamp</property>
              </term>
              <listitem>
                <para>Provides the timestamp of the newest data file found in the object
                                directory.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.fragments">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.fragments</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.from_hash_dir">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.from_hash_dir</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.get_datafile_metadata">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.get_datafile_metadata</property>
              </term>
              <listitem>
                <para>Provide the datafile metadata for a previously opened object as a
                                dictionary. This is metadata that was included when the object was
                                first PUT, and does not include metadata set by any subsequent POST.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.get_metadata">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.get_metadata</property>
              </term>
              <listitem>
                <para>Provide the metadata for a previously opened object as a dictionary.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.get_metafile_metadata">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.get_metafile_metadata</property>
              </term>
              <listitem>
                <para>Provide the metafile metadata for a previously opened object as a
                                dictionary. This is metadata that was written by a POST and does not
                                include any persistent metadata that was set by the original PUT.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.manager">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.manager</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.obj">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.obj</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.open">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.open</property>
              </term>
              <listitem>
                <para>Open the object.</para>
                <para>This implementation opens the data file representing the object, reads
                                the associated metadata in the extended attributes, additionally
                                combining metadata from fast-POST <literal>.meta</literal> files.</para>
                <note>
                  <para>An implementation is allowed to raise any of the following
                                    exceptions, but is only required to raise <literal>DiskFileNotExist</literal> when
                                    the object representation does not exist.</para>
                </note>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.read_metadata">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.read_metadata</property>
              </term>
              <listitem>
                <para>Return the metadata for an object without requiring the caller to open
                                the object first.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.reader">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.reader</property>
              </term>
              <listitem>
                <para>Return a <xref linkend="swift.common.swob.Response"/> class compatible
                                “<literal>app_iter</literal>” object as defined by
                                <xref linkend="swift.obj.diskfile.DiskFileReader"/>.</para>
                <para>For this implementation, the responsibility of closing the open file
                                is passed to the <xref linkend="swift.obj.diskfile.DiskFileReader"/> object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.reader_cls">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.reader_cls</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.timestamp">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.timestamp</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.write_metadata">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.write_metadata</property>
              </term>
              <listitem>
                <para>Write a block of metadata to an object without requiring the caller to
                                create the object first. Supports fast-POST behavior semantics.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFile.writer_cls">
              <term>
                <property>swift.obj.diskfile.BaseDiskFile.writer_cls</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager">
        <term>
          <literal>swift.obj.diskfile.BaseDiskFileManager</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Management class for devices, providing common place for shared parameters
                        and methods not provided by the DiskFile class (which primarily services
                        the object server REST API layer).</para>
          <para>The <literal>get_diskfile()</literal> method is how this implementation creates a <literal>DiskFile</literal>
                        object.</para>
          <note>
            <para>This class is reference implementation specific and not part of the
                            pluggable on-disk backend API.</para>
          </note>
          <note>
            <para>TODO(portante): Not sure what the right name to recommend here, as
                            “manager” seemed generic enough, though suggestions are welcome.</para>
          </note>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.cleanup_ondisk_files">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.cleanup_ondisk_files</property>
              </term>
              <listitem>
                <para>Clean up on-disk files that are obsolete and gather the set of valid
                                on-disk files for an object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.consolidate_hashes">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.consolidate_hashes</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.construct_dev_path">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.construct_dev_path</property>
              </term>
              <listitem>
                <para>Construct the path to a device without checking if it is mounted.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.diskfile_cls">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.diskfile_cls</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.get_dev_path">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.get_dev_path</property>
              </term>
              <listitem>
                <para>Return the path to a device, first checking to see if either it
                                is a proper mount point, or at least a directory depending on
                                the mount_check configuration option.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.get_diskfile">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.get_diskfile</property>
              </term>
              <listitem>
                <para>Returns a BaseDiskFile instance for an object based on the object’s
                                partition, path parts and policy.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.get_diskfile_from_audit_location">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.get_diskfile_from_audit_location</property>
              </term>
              <listitem>
                <para>Returns a BaseDiskFile instance for an object at the given
                                AuditLocation.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.get_diskfile_from_hash">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.get_diskfile_from_hash</property>
              </term>
              <listitem>
                <para>Returns a DiskFile instance for an object at the given
                                object_hash. Just in case someone thinks of refactoring, be
                                sure DiskFileDeleted is <emphasis>not</emphasis> raised, but the DiskFile
                                instance representing the tombstoned object is returned
                                instead.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.get_hashes">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.get_hashes</property>
              </term>
              <listitem/>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.get_ondisk_files">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.get_ondisk_files</property>
              </term>
              <listitem>
                <para>Given a simple list of files names, determine the files that constitute
                                a valid fileset i.e. a set of files that defines the state of an
                                object, and determine the files that are obsolete and could be deleted.
                                Note that some files may fall into neither category.</para>
                <para>If a file is considered part of a valid fileset then its info dict will
                                be added to the results dict, keyed by &lt;extension&gt;_info. Any files that
                                are no longer required will have their info dicts added to a list
                                stored under the key ‘obsolete’.</para>
                <para>The results dict will always contain entries with keys ‘ts_file’,
                                ‘data_file’ and ‘meta_file’. Their values will be the fully qualified
                                path to a file of the corresponding type if there is such a file in the
                                valid fileset, or None.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.invalidate_hash">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.invalidate_hash</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.make_on_disk_filename">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.make_on_disk_filename</property>
              </term>
              <listitem>
                <para>Returns filename for given timestamp.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.object_audit_location_generator">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.object_audit_location_generator</property>
              </term>
              <listitem>
                <para>Yield an AuditLocation for all objects stored under device_dirs.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.parse_on_disk_filename">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.parse_on_disk_filename</property>
              </term>
              <listitem>
                <para>Parse an on disk file name.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.pickle_async_update">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.pickle_async_update</property>
              </term>
              <listitem>
                <para>Write data describing a container update notification to a pickle file
                                in the async_pending directory.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.quarantine_renamer">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.quarantine_renamer</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.replication_lock">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.replication_lock</property>
              </term>
              <listitem>
                <para>A context manager that will lock on the device given, if
                                configured to do so.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.yield_hashes">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.yield_hashes</property>
              </term>
              <listitem>
                <para>Yields tuples of (hash_only, timestamps) for object
                                information stored for the given device, partition, and
                                (optionally) suffixes. If suffixes is None, all stored
                                suffixes will be searched for object hashes. Note that if
                                suffixes is not None but empty, such as [], then nothing will
                                be yielded.</para>
                <para>timestamps is a dict which may contain items mapping:</para>
                <itemizedlist>
                  <listitem>
                    <para>ts_data -&gt; timestamp of data or tombstone file,</para>
                  </listitem>
                  <listitem>
                    <para>ts_meta -&gt; timestamp of meta file, if one exists</para>
                  </listitem>
                  <listitem>
                    <variablelist>
                      <varlistentry>
                        <term>ts_ctype -&gt; timestamp of meta file containing most recent</term>
                        <listitem>
                          <para>content-type value, if one exists</para>
                        </listitem>
                      </varlistentry>
                    </variablelist>
                  </listitem>
                </itemizedlist>
                <para>where timestamps are instances of
                                <xref linkend="swift.common.utils.Timestamp"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileManager.yield_suffixes">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileManager.yield_suffixes</property>
              </term>
              <listitem>
                <para>Yields tuples of (full_path, suffix_only) for suffixes stored
                                on the given device and partition.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileReader">
        <term>
          <literal>swift.obj.diskfile.BaseDiskFileReader</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Encapsulation of the WSGI read context for servicing GET REST API
                        requests. Serves as the context manager object for the
                        <xref linkend="swift.obj.diskfile.DiskFile"/> class’s
                        <literal>swift.obj.diskfile.DiskFile.reader()</literal> method.</para>
          <note>
            <para>The quarantining behavior of this method is considered implementation
                            specific, and is not required of the API.</para>
          </note>
          <note>
            <para>The arguments to the constructor are considered implementation
                            specific. The API does not define the constructor arguments.</para>
          </note>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileReader.app_iter_range">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileReader.app_iter_range</property>
              </term>
              <listitem>
                <para>Returns an iterator over the data file for range (start, stop)</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileReader.app_iter_ranges">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileReader.app_iter_ranges</property>
              </term>
              <listitem>
                <para>Returns an iterator over the data file for a set of ranges</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileReader.can_zero_copy_send">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileReader.can_zero_copy_send</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileReader.close">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileReader.close</property>
              </term>
              <listitem>
                <para>Close the open file handle if present.</para>
                <para>For this specific implementation, this method will handle quarantining
                                the file if necessary.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileReader.manager">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileReader.manager</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileReader.zero_copy_send">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileReader.zero_copy_send</property>
              </term>
              <listitem>
                <para>Does some magic with splice() and tee() to move stuff from disk to
                                network without ever touching userspace.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileWriter">
        <term>
          <literal>swift.obj.diskfile.BaseDiskFileWriter</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Encapsulation of the write context for servicing PUT REST API
                        requests. Serves as the context manager object for the
                        <xref linkend="swift.obj.diskfile.DiskFile"/> class’s
                        <literal>swift.obj.diskfile.DiskFile.create()</literal> method.</para>
          <note>
            <para>It is the responsibility of the
                            <literal>swift.obj.diskfile.DiskFile.create()</literal> method context manager to
                            close the open file descriptor.</para>
          </note>
          <note>
            <para>The arguments to the constructor are considered implementation
                            specific. The API does not define the constructor arguments.</para>
          </note>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileWriter.commit">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileWriter.commit</property>
              </term>
              <listitem>
                <para>Perform any operations necessary to mark the object as durable. For
                                replication policy type this is a no-op.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileWriter.manager">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileWriter.manager</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileWriter.put">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileWriter.put</property>
              </term>
              <listitem>
                <para>Finalize writing the file on disk.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileWriter.put_succeeded">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileWriter.put_succeeded</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.BaseDiskFileWriter.write">
              <term>
                <property>swift.obj.diskfile.BaseDiskFileWriter.write</property>
              </term>
              <listitem>
                <para>Write a chunk of data to disk. All invocations of this method must
                                come before invoking the :func:</para>
                <para>For this implementation, the data is written into a temporary file.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.DiskFile">
        <term>
          <literal>swift.obj.diskfile.DiskFile</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.obj.diskfile.BaseDiskFile"/></para>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.DiskFile.reader_cls">
              <term>
                <property>swift.obj.diskfile.DiskFile.reader_cls</property>
              </term>
              <listitem>
                <para>alias of <xref linkend="swift.obj.diskfile.DiskFileReader"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.DiskFile.writer_cls">
              <term>
                <property>swift.obj.diskfile.DiskFile.writer_cls</property>
              </term>
              <listitem>
                <para>alias of <xref linkend="swift.obj.diskfile.DiskFileWriter"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.DiskFileManager">
        <term>
          <literal>swift.obj.diskfile.DiskFileManager</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.obj.diskfile.BaseDiskFileManager"/></para>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.DiskFileManager.diskfile_cls">
              <term>
                <property>swift.obj.diskfile.DiskFileManager.diskfile_cls</property>
              </term>
              <listitem>
                <para>alias of <xref linkend="swift.obj.diskfile.DiskFile"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.DiskFileReader">
        <term>
          <literal>swift.obj.diskfile.DiskFileReader</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.obj.diskfile.BaseDiskFileReader"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.DiskFileRouter">
        <term>
          <literal>swift.obj.diskfile.DiskFileRouter</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.DiskFileRouter.policy_type_to_manager_cls">
              <term>
                <property>swift.obj.diskfile.DiskFileRouter.policy_type_to_manager_cls</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.DiskFileRouter.register">
              <term>
                <property>swift.obj.diskfile.DiskFileRouter.register</property>
              </term>
              <listitem>
                <para>Decorator for Storage Policy implementations to register
                                their DiskFile implementation.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.DiskFileWriter">
        <term>
          <literal>swift.obj.diskfile.DiskFileWriter</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.obj.diskfile.BaseDiskFileWriter"/></para>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.DiskFileWriter.put">
              <term>
                <property>swift.obj.diskfile.DiskFileWriter.put</property>
              </term>
              <listitem>
                <para>Finalize writing the file on disk.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.ECDiskFile">
        <term>
          <literal>swift.obj.diskfile.ECDiskFile</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.obj.diskfile.BaseDiskFile"/></para>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFile.durable_timestamp">
              <term>
                <property>swift.obj.diskfile.ECDiskFile.durable_timestamp</property>
              </term>
              <listitem>
                <para>Provides the timestamp of the newest durable file found in the object
                                directory.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFile.fragments">
              <term>
                <property>swift.obj.diskfile.ECDiskFile.fragments</property>
              </term>
              <listitem>
                <para>Provides information about all fragments that were found in the object
                                directory, including fragments without a matching durable file, and
                                including any fragment chosen to construct the opened diskfile.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFile.purge">
              <term>
                <property>swift.obj.diskfile.ECDiskFile.purge</property>
              </term>
              <listitem>
                <para>Remove a tombstone file matching the specified timestamp or
                                datafile matching the specified timestamp and fragment index
                                from the object directory.</para>
                <para>This provides the EC reconstructor/ssync process with a way to
                                remove a tombstone or fragment from a handoff node after
                                reverting it to its primary node.</para>
                <para>The hash will be invalidated, and if empty or invalid the
                                hsh_path will be removed on next cleanup_ondisk_files.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFile.reader_cls">
              <term>
                <property>swift.obj.diskfile.ECDiskFile.reader_cls</property>
              </term>
              <listitem>
                <para>alias of <xref linkend="swift.obj.diskfile.ECDiskFileReader"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFile.writer_cls">
              <term>
                <property>swift.obj.diskfile.ECDiskFile.writer_cls</property>
              </term>
              <listitem>
                <para>alias of <xref linkend="swift.obj.diskfile.ECDiskFileWriter"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.ECDiskFileManager">
        <term>
          <literal>swift.obj.diskfile.ECDiskFileManager</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.obj.diskfile.BaseDiskFileManager"/></para>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFileManager.diskfile_cls">
              <term>
                <property>swift.obj.diskfile.ECDiskFileManager.diskfile_cls</property>
              </term>
              <listitem>
                <para>alias of <xref linkend="swift.obj.diskfile.ECDiskFile"/></para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFileManager.make_on_disk_filename">
              <term>
                <property>swift.obj.diskfile.ECDiskFileManager.make_on_disk_filename</property>
              </term>
              <listitem>
                <para>Returns the EC specific filename for given timestamp.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFileManager.parse_on_disk_filename">
              <term>
                <property>swift.obj.diskfile.ECDiskFileManager.parse_on_disk_filename</property>
              </term>
              <listitem>
                <para>Returns timestamp(s) and other info extracted from a policy specific
                                file name. For EC policy the data file name includes a fragment index
                                and possibly a durable marker, both of which which must be stripped off
                                to retrieve the timestamp.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFileManager.validate_fragment_index">
              <term>
                <property>swift.obj.diskfile.ECDiskFileManager.validate_fragment_index</property>
              </term>
              <listitem>
                <para>Return int representation of frag_index, or raise a DiskFileError if
                                frag_index is not a whole number.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.ECDiskFileReader">
        <term>
          <literal>swift.obj.diskfile.ECDiskFileReader</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.obj.diskfile.BaseDiskFileReader"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.ECDiskFileWriter">
        <term>
          <literal>swift.obj.diskfile.ECDiskFileWriter</literal>
        </term>
        <listitem>
          <para>Bases: <xref linkend="swift.obj.diskfile.BaseDiskFileWriter"/></para>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFileWriter.commit">
              <term>
                <property>swift.obj.diskfile.ECDiskFileWriter.commit</property>
              </term>
              <listitem>
                <para>Finalize put by renaming the object data file to include a durable
                                marker. We do this for EC policy because it requires a 2-phase put
                                commit confirmation.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.diskfile.ECDiskFileWriter.put">
              <term>
                <property>swift.obj.diskfile.ECDiskFileWriter.put</property>
              </term>
              <listitem>
                <para>The only difference between this method and the replication policy
                                DiskFileWriter method is adding the frag index to the metadata.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.clear_auditor_status">
        <term>
          <function>swift.obj.diskfile.clear_auditor_status</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.consolidate_hashes">
        <term>
          <function>swift.obj.diskfile.consolidate_hashes</function>
        </term>
        <listitem>
          <para>Take what’s in hashes.pkl and hashes.invalid, combine them, write the
                        result back to hashes.pkl, and clear out hashes.invalid.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.extract_policy">
        <term>
          <function>swift.obj.diskfile.extract_policy</function>
        </term>
        <listitem>
          <para>Extracts the policy for an object (based on the name of the objects
                        directory) given the device-relative path to the object. Returns None in
                        the event that the path is malformed in some way.</para>
          <para>The device-relative path is everything after the mount point; for example:</para>
          <variablelist>
            <varlistentry>
              <term>/srv/node/d42/objects-5/30/179/</term>
              <listitem>
                <para>485dc017205a81df3af616d917c90179/1401811134.873649.data</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>would have device-relative path:</para>
          <para>objects-5/30/179/485dc017205a81df3af616d917c90179/1401811134.873649.data</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.get_async_dir">
        <term>
          <function>swift.obj.diskfile.get_async_dir</function>
        </term>
        <listitem>
          <para>Helper function to construct a string from a base and the policy.
                        Used to encode the policy index into either a file name or a
                        directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.get_auditor_status">
        <term>
          <function>swift.obj.diskfile.get_auditor_status</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.get_data_dir">
        <term>
          <function>swift.obj.diskfile.get_data_dir</function>
        </term>
        <listitem>
          <para>Helper function to construct a string from a base and the policy.
                        Used to encode the policy index into either a file name or a
                        directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.get_part_path">
        <term>
          <function>swift.obj.diskfile.get_part_path</function>
        </term>
        <listitem>
          <para>Given the device path, policy, and partition, returns the full
                        path to the partition</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.get_tmp_dir">
        <term>
          <function>swift.obj.diskfile.get_tmp_dir</function>
        </term>
        <listitem>
          <para>Helper function to construct a string from a base and the policy.
                        Used to encode the policy index into either a file name or a
                        directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.invalidate_hash">
        <term>
          <function>swift.obj.diskfile.invalidate_hash</function>
        </term>
        <listitem>
          <para>Invalidates the hash for a suffix_dir in the partition’s hashes file.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.object_audit_location_generator">
        <term>
          <function>swift.obj.diskfile.object_audit_location_generator</function>
        </term>
        <listitem>
          <para>Given a devices path (e.g. “/srv/node”), yield an AuditLocation for all
                        objects stored under that directory if device_dirs isn’t set.  If
                        device_dirs is set, only yield AuditLocation for the objects under the
                        entries in device_dirs. The AuditLocation only knows the path to the hash
                        directory, not to the .data file therein (if any). This is to avoid a
                        double listdir(hash_dir); the DiskFile object will always do one, so
                        we don’t.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.quarantine_renamer">
        <term>
          <function>swift.obj.diskfile.quarantine_renamer</function>
        </term>
        <listitem>
          <para>In the case that a file is corrupted, move it to a quarantined
                        area to allow replication to fix it.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.read_hashes">
        <term>
          <function>swift.obj.diskfile.read_hashes</function>
        </term>
        <listitem>
          <para>Read the existing hashes.pkl</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.read_metadata">
        <term>
          <function>swift.obj.diskfile.read_metadata</function>
        </term>
        <listitem>
          <para>Helper function to read the pickled metadata from an object file.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.relink_paths">
        <term>
          <function>swift.obj.diskfile.relink_paths</function>
        </term>
        <listitem>
          <para>Hard-links a file located in target_path using the second path
                        new_target_path. Creates intermediate directories if required.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.strip_self">
        <term>
          <function>swift.obj.diskfile.strip_self</function>
        </term>
        <listitem>
          <para>Wrapper to attach module level functions to base class.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.update_auditor_status">
        <term>
          <function>swift.obj.diskfile.update_auditor_status</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.write_hashes">
        <term>
          <function>swift.obj.diskfile.write_hashes</function>
        </term>
        <listitem>
          <para>Write hashes to hashes.pkl</para>
          <para>The updated key is added to hashes before it is written.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.diskfile.write_metadata">
        <term>
          <function>swift.obj.diskfile.write_metadata</function>
        </term>
        <listitem>
          <para>Helper function to write pickled metadata for an object file.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="object-replicator">
    <title>Object Replicator</title>
    <variablelist>
      <varlistentry xml:id="swift.obj.replicator.ObjectReplicator">
        <term>
          <literal>swift.obj.replicator.ObjectReplicator</literal>
        </term>
        <listitem>
          <para>Bases: <literal>swift.common.daemon.Daemon</literal></para>
          <para>Replicate objects.</para>
          <para>Encapsulates most logic and data needed by the object replication process.
                        Each call to .replicate() performs one replication pass.  It’s up to the
                        caller to do this in a loop.</para>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.build_replication_jobs">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.build_replication_jobs</property>
              </term>
              <listitem>
                <para>Helper function for collect_jobs to build jobs for replication
                                using replication style storage policy</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.check_ring">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.check_ring</property>
              </term>
              <listitem>
                <para>Check to see if the ring has been updated
                                :param object_ring: the ring to check</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.collect_jobs">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.collect_jobs</property>
              </term>
              <listitem>
                <para>Returns a sorted list of jobs (dictionaries) that specify the
                                partitions, nodes, etc to be rsynced.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.delete_handoff_objs">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.delete_handoff_objs</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.delete_partition">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.delete_partition</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.detect_lockups">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.detect_lockups</property>
              </term>
              <listitem>
                <para>In testing, the pool.waitall() call very occasionally failed to return.
                                This is an attempt to make sure the replicator finishes its replication
                                pass in some eventuality.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.heartbeat">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.heartbeat</property>
              </term>
              <listitem>
                <para>Loop that runs in the background during replication.  It periodically
                                logs progress.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.kill_coros">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.kill_coros</property>
              </term>
              <listitem>
                <para>Utility function that kills all coroutines currently running.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.load_object_ring">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.load_object_ring</property>
              </term>
              <listitem>
                <para>Make sure the policy’s rings are loaded.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.replicate">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.replicate</property>
              </term>
              <listitem>
                <para>Run a replication pass</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.rsync">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.rsync</property>
              </term>
              <listitem>
                <para>Uses rsync to implement the sync method. This was the first
                                sync method in Swift.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.run_forever">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.run_forever</property>
              </term>
              <listitem>
                <para>Override this to run forever</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.run_once">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.run_once</property>
              </term>
              <listitem>
                <para>Override this to run the script once</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.ssync">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.ssync</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.stats_line">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.stats_line</property>
              </term>
              <listitem>
                <para>Logs various stats for the currently running replication pass.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.sync">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.sync</property>
              </term>
              <listitem>
                <para>Synchronize local suffix directories from a partition with a remote
                                node.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.update">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.update</property>
              </term>
              <listitem>
                <para>High-level method that replicates a single partition.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.replicator.ObjectReplicator.update_deleted">
              <term>
                <property>swift.obj.replicator.ObjectReplicator.update_deleted</property>
              </term>
              <listitem>
                <para>High-level method that replicates a single partition that doesn’t
                                belong on this node.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.replicator.get_data_dir">
        <term>
          <function>swift.obj.replicator.get_data_dir</function>
        </term>
        <listitem>
          <para>Helper function to construct a string from a base and the policy.
                        Used to encode the policy index into either a file name or a
                        directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.replicator.get_tmp_dir">
        <term>
          <function>swift.obj.replicator.get_tmp_dir</function>
        </term>
        <listitem>
          <para>Helper function to construct a string from a base and the policy.
                        Used to encode the policy index into either a file name or a
                        directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.ssync_sender.Sender">
        <term>
          <literal>swift.obj.ssync_sender.Sender</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Sends SSYNC requests to the object server.</para>
          <para>These requests are eventually handled by
                        <xref linkend="module-swift.obj.ssync_receiver"/> and full documentation about the
                        process is there.</para>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_sender.Sender.connect">
              <term>
                <property>swift.obj.ssync_sender.Sender.connect</property>
              </term>
              <listitem>
                <para>Establishes a connection and starts an SSYNC request
                                with the object server.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_sender.Sender.disconnect">
              <term>
                <property>swift.obj.ssync_sender.Sender.disconnect</property>
              </term>
              <listitem>
                <para>Closes down the connection to the object server once done
                                with the SSYNC request.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_sender.Sender.missing_check">
              <term>
                <property>swift.obj.ssync_sender.Sender.missing_check</property>
              </term>
              <listitem>
                <para>Handles the sender-side of the MISSING_CHECK step of a
                                SSYNC request.</para>
                <para>Full documentation of this can be found at
                                <xref linkend="swift.obj.ssync_receiver.Receiver.missing_check"/>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_sender.Sender.readline">
              <term>
                <property>swift.obj.ssync_sender.Sender.readline</property>
              </term>
              <listitem>
                <para>Reads a line from the SSYNC response body.</para>
                <para>httplib has no readline and will block on read(x) until x is
                                read, so we have to do the work ourselves. A bit of this is
                                taken from Python’s httplib itself.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_sender.Sender.send_delete">
              <term>
                <property>swift.obj.ssync_sender.Sender.send_delete</property>
              </term>
              <listitem>
                <para>Sends a DELETE subrequest with the given information.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_sender.Sender.send_post">
              <term>
                <property>swift.obj.ssync_sender.Sender.send_post</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_sender.Sender.send_put">
              <term>
                <property>swift.obj.ssync_sender.Sender.send_put</property>
              </term>
              <listitem>
                <para>Sends a PUT subrequest for the url_path using the source df
                                (DiskFile) and content_length.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_sender.Sender.updates">
              <term>
                <property>swift.obj.ssync_sender.Sender.updates</property>
              </term>
              <listitem>
                <para>Handles the sender-side of the UPDATES step of an SSYNC
                                request.</para>
                <para>Full documentation of this can be found at
                                <xref linkend="swift.obj.ssync_receiver.Receiver.updates"/>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.ssync_sender.decode_wanted">
        <term>
          <function>swift.obj.ssync_sender.decode_wanted</function>
        </term>
        <listitem>
          <para>Parse missing_check line parts to determine which parts of local
                        diskfile were wanted by the receiver.</para>
          <para>The encoder for parts is
                        <xref linkend="swift.obj.ssync_receiver.encode_wanted"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.ssync_sender.encode_missing">
        <term>
          <function>swift.obj.ssync_sender.encode_missing</function>
        </term>
        <listitem>
          <para>Returns a string representing the object hash, its data file timestamp
                        and the delta forwards to its metafile and content-type timestamps, if
                        non-zero, in the form:
                        <literal>&lt;hash&gt; &lt;ts_data&gt; [m:&lt;hex delta to ts_meta&gt;[,t:&lt;hex delta to ts_ctype&gt;]]</literal></para>
          <para>The decoder for this line is
                        <xref linkend="swift.obj.ssync_receiver.decode_missing"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.ssync_receiver.Receiver">
        <term>
          <literal>swift.obj.ssync_receiver.Receiver</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Handles incoming SSYNC requests to the object server.</para>
          <para>These requests come from the object-replicator daemon that uses
                        <xref linkend="module-swift.obj.ssync_sender"/>.</para>
          <para>The number of concurrent SSYNC requests is restricted by
                        use of a replication_semaphore and can be configured with the
                        object-server.conf [object-server] replication_concurrency
                        setting.</para>
          <para>An SSYNC request is really just an HTTP conduit for
                        sender/receiver replication communication. The overall
                        SSYNC request should always succeed, but it will contain
                        multiple requests within its request and response bodies. This
                        “hack” is done so that replication concurrency can be managed.</para>
          <para>The general process inside an SSYNC request is:</para>
          <procedure>
            <step>
              <para>Initialize the request: Basic request validation, mount check,
                                    acquire semaphore lock, etc..</para>
            </step>
            <step>
              <para>Missing check: Sender sends the hashes and timestamps of
                                    the object information it can send, receiver sends back
                                    the hashes it wants (doesn’t have or has an older
                                    timestamp).</para>
            </step>
            <step>
              <para>Updates: Sender sends the object information requested.</para>
            </step>
            <step>
              <para>Close down: Release semaphore lock, etc.</para>
            </step>
          </procedure>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_receiver.Receiver.initialize_request">
              <term>
                <property>swift.obj.ssync_receiver.Receiver.initialize_request</property>
              </term>
              <listitem>
                <para>Basic validation of request and mount check.</para>
                <para>This function will be called before attempting to acquire a
                                replication semaphore lock, so contains only quick checks.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_receiver.Receiver.missing_check">
              <term>
                <property>swift.obj.ssync_receiver.Receiver.missing_check</property>
              </term>
              <listitem>
                <para>Handles the receiver-side of the MISSING_CHECK step of a
                                SSYNC request.</para>
                <para>Receives a list of hashes and timestamps of object
                                information the sender can provide and responds with a list
                                of hashes desired, either because they’re missing or have an
                                older timestamp locally.</para>
                <para>The process is generally:</para>
                <procedure>
                  <step>
                    <para>Sender sends <literal>:MISSING_CHECK: START</literal> and begins
                                            sending <literal>hash timestamp</literal> lines.</para>
                  </step>
                  <step>
                    <para>Receiver gets <literal>:MISSING_CHECK: START</literal> and begins
                                            reading the <literal>hash timestamp</literal> lines, collecting the
                                            hashes of those it desires.</para>
                  </step>
                  <step>
                    <para>Sender sends <literal>:MISSING_CHECK: END</literal>.</para>
                  </step>
                  <step>
                    <para>Receiver gets <literal>:MISSING_CHECK: END</literal>, responds with
                                            <literal>:MISSING_CHECK: START</literal>, followed by the list of
                                            &lt;wanted_hash&gt; specifiers it collected as being wanted
                                            (one per line), <literal>:MISSING_CHECK: END</literal>, and flushes any
                                            buffers.</para>
                    <para>Each &lt;wanted_hash&gt; specifier has the form &lt;hash&gt;[ &lt;parts&gt;] where
                                            &lt;parts&gt; is a string containing characters ‘d’ and/or ‘m’
                                            indicating that only data or meta part of object respectively is
                                            required to be sync’d.</para>
                  </step>
                  <step>
                    <para>Sender gets <literal>:MISSING_CHECK: START</literal> and reads the list
                                            of hashes desired by the receiver until reading
                                            <literal>:MISSING_CHECK: END</literal>.</para>
                  </step>
                </procedure>
                <para>The collection and then response is so the sender doesn’t
                                have to read while it writes to ensure network buffers don’t
                                fill up and block everything.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.ssync_receiver.Receiver.updates">
              <term>
                <property>swift.obj.ssync_receiver.Receiver.updates</property>
              </term>
              <listitem>
                <para>Handles the UPDATES step of an SSYNC request.</para>
                <para>Receives a set of PUT and DELETE subrequests that will be
                                routed to the object server itself for processing. These
                                contain the information requested by the MISSING_CHECK step.</para>
                <para>The PUT and DELETE subrequests are formatted pretty much
                                exactly like regular HTTP requests, excepting the HTTP
                                version on the first request line.</para>
                <para>The process is generally:</para>
                <procedure>
                  <step>
                    <para>Sender sends <literal>:UPDATES: START</literal> and begins sending the
                                            PUT and DELETE subrequests.</para>
                  </step>
                  <step>
                    <para>Receiver gets <literal>:UPDATES: START</literal> and begins routing the
                                            subrequests to the object server.</para>
                  </step>
                  <step>
                    <para>Sender sends <literal>:UPDATES: END</literal>.</para>
                  </step>
                  <step>
                    <para>Receiver gets <literal>:UPDATES: END</literal> and sends <literal>:UPDATES:
                                                START</literal> and <literal>:UPDATES: END</literal> (assuming no errors).</para>
                  </step>
                  <step>
                    <para>Sender gets <literal>:UPDATES: START</literal> and <literal>:UPDATES: END</literal>.</para>
                  </step>
                </procedure>
                <para>If too many subrequests fail, as configured by
                                replication_failure_threshold and replication_failure_ratio,
                                the receiver will hang up the request early so as to not
                                waste any more time.</para>
                <para>At step 4, the receiver will send back an error if there were
                                any failures (that didn’t cause a hangup due to the above
                                thresholds) so the sender knows the whole was not entirely a
                                success. This is so the sender knows if it can remove an out
                                of place partition, for example.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.ssync_receiver.decode_missing">
        <term>
          <function>swift.obj.ssync_receiver.decode_missing</function>
        </term>
        <listitem>
          <para>Parse a string of the form generated by
                        <xref linkend="swift.obj.ssync_sender.encode_missing"/> and return a dict
                        with keys <literal>object_hash</literal>, <literal>ts_data</literal>, <literal>ts_meta</literal>, <literal>ts_ctype</literal>.</para>
          <para>The encoder for this line is
                        <xref linkend="swift.obj.ssync_sender.encode_missing"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.ssync_receiver.encode_wanted">
        <term>
          <function>swift.obj.ssync_receiver.encode_wanted</function>
        </term>
        <listitem>
          <para>Compare a remote and local results and generate a wanted line.</para>
          <para>The decoder for this line is
                        <xref linkend="swift.obj.ssync_sender.decode_wanted"/></para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="object-reconstructor">
    <title>Object Reconstructor</title>
    <variablelist>
      <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor">
        <term>
          <literal>swift.obj.reconstructor.ObjectReconstructor</literal>
        </term>
        <listitem>
          <para>Bases: <literal>swift.common.daemon.Daemon</literal></para>
          <para>Reconstruct objects using erasure code.  And also rebalance EC Fragment
                        Archive objects off handoff nodes.</para>
          <para>Encapsulates most logic and data needed by the object reconstruction
                        process. Each call to .reconstruct() performs one pass.  It’s up to the
                        caller to do this in a loop.</para>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.aggregate_recon_update">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.aggregate_recon_update</property>
              </term>
              <listitem>
                <para>Aggregate per-disk rcache updates from child workers.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.build_reconstruction_jobs">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.build_reconstruction_jobs</property>
              </term>
              <listitem>
                <para>Helper function for collect_jobs to build jobs for reconstruction
                                using EC style storage policy</para>
                <para>N.B. If this function ever returns an empty list of jobs the entire
                                partition will be deleted.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.check_ring">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.check_ring</property>
              </term>
              <listitem>
                <para>Check to see if the ring has been updated</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.collect_parts">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.collect_parts</property>
              </term>
              <listitem>
                <para>Helper for getting partitions in the top level reconstructor</para>
                <para>In handoffs_only mode primary partitions will not be included in the
                                returned (possibly empty) list.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.delete_partition">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.delete_partition</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.delete_reverted_objs">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.delete_reverted_objs</property>
              </term>
              <listitem>
                <para>For EC we can potentially revert only some of a partition
                                so we’ll delete reverted objects here. Note that we delete
                                the fragment index of the file we sent to the remote node.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.detect_lockups">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.detect_lockups</property>
              </term>
              <listitem>
                <para>In testing, the pool.waitall() call very occasionally failed to return.
                                This is an attempt to make sure the reconstructor finishes its
                                reconstruction pass in some eventuality.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.final_recon_dump">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.final_recon_dump</property>
              </term>
              <listitem>
                <para>Add stats for this worker’s run to recon cache.</para>
                <para>When in worker mode (per_disk_stats == True) this worker’s stats are
                                added per device instead of in the top level keys (aggregation is
                                serialized in the parent process).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.get_local_devices">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.get_local_devices</property>
              </term>
              <listitem>
                <para>Returns a set of all local devices in all EC policies.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.get_policy2devices">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.get_policy2devices</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.get_suffix_delta">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.get_suffix_delta</property>
              </term>
              <listitem>
                <para>Compare the local suffix hashes with the remote suffix hashes
                                for the given local and remote fragment indexes.  Return those
                                suffixes which should be synced.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.get_worker_args">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.get_worker_args</property>
              </term>
              <listitem>
                <para>Take the set of all local devices for this node from all the EC
                                policies rings, and distribute them evenly into the number of workers
                                to be spawned according to the configured worker count. If <literal>devices</literal> is
                                given in <literal>kwargs</literal> then distribute only those devices.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.heartbeat">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.heartbeat</property>
              </term>
              <listitem>
                <para>Loop that runs in the background during reconstruction.  It
                                periodically logs progress.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.is_healthy">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.is_healthy</property>
              </term>
              <listitem>
                <para>Check whether rings have changed, and maybe do a recon update.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.kill_coros">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.kill_coros</property>
              </term>
              <listitem>
                <para>Utility function that kills all coroutines currently running.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.load_object_ring">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.load_object_ring</property>
              </term>
              <listitem>
                <para>Make sure the policy’s rings are loaded.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.make_rebuilt_fragment_iter">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.make_rebuilt_fragment_iter</property>
              </term>
              <listitem>
                <para>Turn a set of connections from backend object servers into a generator
                                that yields up the rebuilt fragment archive for frag_index.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.process_job">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.process_job</property>
              </term>
              <listitem>
                <para>Sync the local partition with the remote node(s) according to
                                the parameters of the job.  For primary nodes, the SYNC job type
                                will define both left and right hand sync_to nodes to ssync with
                                as defined by this primary nodes index in the node list based on
                                the fragment index found in the partition.  For non-primary
                                nodes (either handoff revert, or rebalance) the REVERT job will
                                define a single node in sync_to which is the proper/new home for
                                the fragment index.</para>
                <para>N.B. ring rebalancing can be time consuming and handoff nodes’
                                fragment indexes do not have a stable order, it’s possible to
                                have more than one REVERT job for a partition, and in some rare
                                failure conditions there may even also be a SYNC job for the
                                same partition - but each one will be processed separately
                                because each job will define a separate list of node(s) to
                                ‘sync_to’.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.reconstruct">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.reconstruct</property>
              </term>
              <listitem>
                <para>Run a reconstruction pass</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.reconstruct_fa">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.reconstruct_fa</property>
              </term>
              <listitem>
                <para>Reconstructs a fragment archive - this method is called from ssync
                                after a remote node responds that is missing this object - the local
                                diskfile is opened to provide metadata - but to reconstruct the
                                missing fragment archive we must connect to multiple object servers.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.rehash_remote">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.rehash_remote</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.run_forever">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.run_forever</property>
              </term>
              <listitem>
                <para>Override this to run forever</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.run_once">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.run_once</property>
              </term>
              <listitem>
                <para>Override this to run the script once</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.ObjectReconstructor.stats_line">
              <term>
                <property>swift.obj.reconstructor.ObjectReconstructor.stats_line</property>
              </term>
              <listitem>
                <para>Logs various stats for the currently running reconstruction pass.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.reconstructor.RebuildingECDiskFileStream">
        <term>
          <literal>swift.obj.reconstructor.RebuildingECDiskFileStream</literal>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>This class wraps the reconstructed fragment archive data and
                        metadata in the DiskFile interface for ssync.</para>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.RebuildingECDiskFileStream.content_length">
              <term>
                <property>swift.obj.reconstructor.RebuildingECDiskFileStream.content_length</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.RebuildingECDiskFileStream.get_datafile_metadata">
              <term>
                <property>swift.obj.reconstructor.RebuildingECDiskFileStream.get_datafile_metadata</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.RebuildingECDiskFileStream.get_metadata">
              <term>
                <property>swift.obj.reconstructor.RebuildingECDiskFileStream.get_metadata</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.reconstructor.RebuildingECDiskFileStream.reader">
              <term>
                <property>swift.obj.reconstructor.RebuildingECDiskFileStream.reader</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.reconstructor.get_data_dir">
        <term>
          <function>swift.obj.reconstructor.get_data_dir</function>
        </term>
        <listitem>
          <para>Helper function to construct a string from a base and the policy.
                        Used to encode the policy index into either a file name or a
                        directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.reconstructor.get_tmp_dir">
        <term>
          <function>swift.obj.reconstructor.get_tmp_dir</function>
        </term>
        <listitem>
          <para>Helper function to construct a string from a base and the policy.
                        Used to encode the policy index into either a file name or a
                        directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.reconstructor.parse_override_options">
        <term>
          <function>swift.obj.reconstructor.parse_override_options</function>
        </term>
        <listitem>
          <para>Return a dict with keys <literal>override_devices</literal> and <literal>override_partitions</literal> whose
                        values have been parsed from <literal>kwargs</literal>. If either key is found in <literal>kwargs</literal>
                        then copy its value from kwargs. Otherwise, if <literal>once</literal> is set in <literal>kwargs</literal>
                        then parse <literal>devices</literal> and <literal>partitions</literal> keys for the value of
                        <literal>override_devices</literal> and <literal>override_partitions</literal> respectively.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="object-server">
    <title>Object Server</title>
    <para>Object Server for Swift</para>
    <variablelist>
      <varlistentry xml:id="swift.obj.server.EventletPlungerString">
        <term>
          <literal>swift.obj.server.EventletPlungerString</literal>
        </term>
        <listitem>
          <para>Bases: <literal>str</literal></para>
          <para>Eventlet won’t send headers until it’s accumulated at least
                        eventlet.wsgi.MINIMUM_CHUNK_SIZE bytes or the app iter is exhausted. If we
                        want to send the response body behind Eventlet’s back, perhaps with some
                        zero-copy wizardry, then we have to unclog the plumbing in eventlet.wsgi
                        to force the headers out, so we use an EventletPlungerString to empty out
                        all of Eventlet’s buffers.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.server.ObjectController">
        <term>
          <literal>swift.obj.server.ObjectController</literal>
        </term>
        <listitem>
          <para>Bases: <literal>swift.common.base_storage_server.BaseStorageServer</literal></para>
          <para>Implements the WSGI application for the Swift Object Server.</para>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.DELETE">
              <term>
                <property>swift.obj.server.ObjectController.DELETE</property>
              </term>
              <listitem>
                <para>Handle HTTP DELETE requests for the Swift Object Server.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.GET">
              <term>
                <property>swift.obj.server.ObjectController.GET</property>
              </term>
              <listitem>
                <para>Handle HTTP GET requests for the Swift Object Server.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.HEAD">
              <term>
                <property>swift.obj.server.ObjectController.HEAD</property>
              </term>
              <listitem>
                <para>Handle HTTP HEAD requests for the Swift Object Server.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.POST">
              <term>
                <property>swift.obj.server.ObjectController.POST</property>
              </term>
              <listitem>
                <para>Handle HTTP POST requests for the Swift Object Server.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.PUT">
              <term>
                <property>swift.obj.server.ObjectController.PUT</property>
              </term>
              <listitem>
                <para>Handle HTTP PUT requests for the Swift Object Server.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.REPLICATE">
              <term>
                <property>swift.obj.server.ObjectController.REPLICATE</property>
              </term>
              <listitem>
                <para>Handle REPLICATE requests for the Swift Object Server.  This is used
                                by the object replicator to get hashes for directories.</para>
                <para>Note that the name REPLICATE is preserved for historical reasons as
                                this verb really just returns the hashes information for the specified
                                parameters and is used, for example, by both replication and EC.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.SSYNC">
              <term>
                <property>swift.obj.server.ObjectController.SSYNC</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.async_update">
              <term>
                <property>swift.obj.server.ObjectController.async_update</property>
              </term>
              <listitem>
                <para>Sends or saves an async update.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.container_update">
              <term>
                <property>swift.obj.server.ObjectController.container_update</property>
              </term>
              <listitem>
                <para>Update the container when objects are updated.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.delete_at_update">
              <term>
                <property>swift.obj.server.ObjectController.delete_at_update</property>
              </term>
              <listitem>
                <para>Update the expiring objects container when objects are updated.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.get_diskfile">
              <term>
                <property>swift.obj.server.ObjectController.get_diskfile</property>
              </term>
              <listitem>
                <para>Utility method for instantiating a DiskFile object supporting a given
                                REST API.</para>
                <para>An implementation of the object server that wants to use a different
                                DiskFile class would simply over-ride this method to provide that
                                behavior.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.server_type">
              <term>
                <property>swift.obj.server.ObjectController.server_type</property>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.server.ObjectController.setup">
              <term>
                <property>swift.obj.server.ObjectController.setup</property>
              </term>
              <listitem>
                <para>Implementation specific setup. This method is called at the very end
                                by the constructor to allow a specific implementation to modify
                                existing attributes or add its own attributes.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.server.app_factory">
        <term>
          <function>swift.obj.server.app_factory</function>
        </term>
        <listitem>
          <para>paste.deploy app factory for creating WSGI object server apps</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.server.drain">
        <term>
          <function>swift.obj.server.drain</function>
        </term>
        <listitem>
          <para>Read and discard any bytes from file_like.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.server.global_conf_callback">
        <term>
          <function>swift.obj.server.global_conf_callback</function>
        </term>
        <listitem>
          <para>Callback for swift.common.wsgi.run_wsgi during the global_conf
                        creation so that we can add our replication_semaphore, used to
                        limit the number of concurrent SSYNC_REQUESTS across all
                        workers.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.server.iter_mime_headers_and_bodies">
        <term>
          <function>swift.obj.server.iter_mime_headers_and_bodies</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="object-updater">
    <title>Object Updater</title>
    <variablelist>
      <varlistentry xml:id="swift.obj.updater.ObjectUpdater">
        <term>
          <literal>swift.obj.updater.ObjectUpdater</literal>
        </term>
        <listitem>
          <para>Bases: <literal>swift.common.daemon.Daemon</literal></para>
          <para>Update object information in container listings.</para>
          <variablelist>
            <varlistentry xml:id="swift.obj.updater.ObjectUpdater.get_container_ring">
              <term>
                <property>swift.obj.updater.ObjectUpdater.get_container_ring</property>
              </term>
              <listitem>
                <para>Get the container ring.  Load it, if it hasn’t been yet.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.updater.ObjectUpdater.object_sweep">
              <term>
                <property>swift.obj.updater.ObjectUpdater.object_sweep</property>
              </term>
              <listitem>
                <para>If there are async pendings on the device, walk each one and update.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.updater.ObjectUpdater.object_update">
              <term>
                <property>swift.obj.updater.ObjectUpdater.object_update</property>
              </term>
              <listitem>
                <para>Perform the object update to the container</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.updater.ObjectUpdater.process_object_update">
              <term>
                <property>swift.obj.updater.ObjectUpdater.process_object_update</property>
              </term>
              <listitem>
                <para>Process the object information to be updated and update.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.updater.ObjectUpdater.run_forever">
              <term>
                <property>swift.obj.updater.ObjectUpdater.run_forever</property>
              </term>
              <listitem>
                <para>Run the updater continuously.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry xml:id="swift.obj.updater.ObjectUpdater.run_once">
              <term>
                <property>swift.obj.updater.ObjectUpdater.run_once</property>
              </term>
              <listitem>
                <para>Run the updater once.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.updater.get_tmp_dir">
        <term>
          <function>swift.obj.updater.get_tmp_dir</function>
        </term>
        <listitem>
          <para>Helper function to construct a string from a base and the policy.
                        Used to encode the policy index into either a file name or a
                        directory name by various modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry xml:id="swift.obj.updater.random">
        <term>
          <function>swift.obj.updater.random</function>
        </term>
        <listitem>
          <para/>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
</section>
