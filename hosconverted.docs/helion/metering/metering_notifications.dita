<?xml version="1.0" encoding="UTF-8"?>
<!--Edit status: not edited-->
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="notifications">
  <title><ph conkeyref="HOS-conrefs/product-title"/>Ceilometer Metering Service Notifications</title>
  <body><!--not tested-->
    <p conkeyref="HOS-conrefs/applies-to"/>
    <p>Ceilometer uses the notification agent to listen to the message queue, convert notifications to Events and Samples, and apply pipeline actions.
      This topic provides the following information to help you manage notifications in Ceilometer:</p>
<ul>
  <li><xref type="section" href="#notifications/whitelist">Manage Whitelisting and Polling</xref></li>
  <li><xref type="section" href="#notifications/list">Edit the List of Meters</xref></li>
  <li><xref type="section" href="#notifications/meters_add">Add Resource Fields to Meters</xref></li>
  <li><xref type="section" href="#notifications/update_pollSwift">Update the Polling Strategy and Swift Considerations</xref></li>
</ul>    

    <section id="whitelist">
      <title>Manage Whitelisting and Polling</title>
      
      <p>Helion OpenStack is designed to reduce the amount of data that is stored. Helion's use of a
        SQL-based cluster, which is not recommended for big data, means you must control the data
        that Ceilometer collects. You can do this by filtering (whitelisting) the data or by using
        the configuration files for the Ceilometer Polling Agent and the Ceilometer Notificfoation
        Agent.</p>
      
      <p>Whitelisting is used in a rule specification as a positive filtering parameter. Whitelist is only included in rules that can be used in direct mappings, for identity service issues such as service discovery, provisioning users, groups, roles, projects, domains as well as user authentication and authorization.</p>
      
      <p>You can run tests against specific scenarios to see if filtering reduces the amount of data
        stored. You can create a test by editing or creating a run filter file (whitelist). For
        steps on how to do this, see: <xref
          href="../installation/api_verification.dita#api_verification/list">Run Tests Matching a
          Series of White and Blacklists</xref>.</p>
      
      <p>Ceilometer Polling Agent (polling agent) and Ceilometer Notification Agent (notification
        agent) use different pipeline.yaml files to configure meters that are collected. This
        prevents accidentally polling for meters which can be retrieved by the polling agent as well
        as the notification agent. For example, glance image and image.size are meters which can be
        retrieved both by polling and notifications.</p>
      
      <p>In both of the separate configuration files, there is a setting for
        <codeph>interval</codeph>. The interval attribute determines the frequency, in
        seconds, of how often data is collected. You can use this setting to control the
        amount of resources that are used for notifications and for polling. For example,
        you want to use more resources for notifications and less for polling. To accomplish
        this you would set the <codeph>interval</codeph> in the polling configuration file
        to a large amount of time, such as 604800 seconds, which polls only once a week.
        Then in the notifications configuration file, you can set the
        <codeph>interval</codeph> to a higher amount, such as collecting data every 30
        seconds.</p>
      
      <note type="important">Swift account data will be collected using the polling mechanism
        in an hourly interval.</note>
      
      <p>Setting this interval to manage both notifications and polling is the recommended
        procedure when using a SQL cluster back-end.</p>
      
      <p><b>Sample Ceilometer Polling Agent file:</b></p>
      <codeblock>#File:    ~/opt/stack/service/ceilometer-common/etc/pipeline-agent-central.yaml
---
sources:
    - name: meter_source
      interval: 600
      meters:
          - "!*"
      resources:
      discovery:
      sinks:
          - meter_sink
sinks:
    - name: meter_sink
      transformers:
      publishers:
         - notifier://</codeblock>         
      
      <p><b>Sample Ceilometer Notification Agent(notification agent) file:</b></p>
      <codeblock>#File:    ~/opt/stack/service/ceilometer-common/etc/pipeline.yaml
---          
sources:
    - name: meter_source
      interval: 30
      meters:
          - "instance"
          - "image"
          - "image.size"
          - "image.upload"
          - "image.delete"
          - "volume"
          - "volume.size"
          - "snapshot"
          - "snapshot.size"
          - "ip.floating"
          - "network"
          - "network.create"
          - "network.update"
resources:
discovery:
sinks:
          - meter_sink
sinks:
    - name: meter_sink
      transformers:
      publishers:
         - notifier://</codeblock>
      
      
      
      <p>Both of the pipeline files have two major sections:
        <dl>
          <dlentry>
            <dt>Sources</dt>
            <dd>represents the data that is collected either from notifications posted
              by services or through polling. In the Sources section there is a list
              of meters. These meters define what kind of data is collected. For a
              full list refer to the Ceilometer documentation available at: <xref
                href="http://docs.openstack.org/admin-guide/telemetry-measurements.html"
                format="html" scope="external">Telemetry Measurements</xref></dd>
          </dlentry>
          <dlentry>
            <dt>Sinks</dt>
            <dd>represents how the data is modified before it is published to the internal
              queue for collection and storage. </dd>
          </dlentry>
        </dl>You will only need to change a setting in the Sources section to control the data collection interval.</p>
      
      <p>For more information, see <xref
        href="http://docs.openstack.org/admin-guide-cloud/telemetry-measurements.html"
        format="html" scope="external"
        >Telemetry Measurements</xref>
      </p>
      
      <p><b>To change the Ceilometer Polling Agent interval setting:</b></p>
      <ol>
        <li>To find the polling agent configuration file, run:
          <codeblock>cd ~/opt/stack/service/ceilometer-common/etc</codeblock></li>
        <li>In a text editor, open the following file:       
          <codeblock>pipeline-agent-central.yaml</codeblock></li>
        <li>In the following section, change the value of <codeph>interval</codeph> to the
          desired amount of time:
          <codeblock>sources:
    - name: meter_source
      interval: 600
      meters:
          - "!*"
      resources:
      discovery:</codeblock>
          In the sample code above, the polling agent will collect data every 600 seconds,
          or 10 minutes.</li>
      </ol>                 
      
      <p><b>To change the Ceilometer Notification Agent (notification agent) interval
        setting:</b></p>
      <ol>
        <li>To find the notification agent configuration file, run:
          <codeblock>cd ~~/opt/stack/service/ceilometer-common/etc</codeblock></li>
        <li>In a text editor, open the following file:       
          <codeblock>pipeline.yaml</codeblock></li>
        <li>In the following section, change the value of <codeph>interval</codeph> to
          the desired amount of time:
          <codeblock>sources:
    - name: meter_source
      interval: 30
      meters:
          - "instance"
          - "image"
          - "image.size"
          - "image.upload"
          - "image.delete"
          - "volume"
          - "volume.size"
          - "snapshot"
          - "snapshot.size"
          - "ip.floating"
          - "network"
          - "network.create"
          - "network.update"</codeblock>
          In the sample code above, the notification agent will collect data every 30
          seconds.</li>
      </ol> 
      
      <note>The <codeph>pipeline.yaml</codeph> file needs to be changed
        on all controller nodes to change the white-listing and polling strategy.</note>
      
    </section>
   
    <section id="list">
      <title>Edit the List of Meters</title>
      <p>The number of enabled meters can be reduced or increased by editing the pipeline
        configuration of the notification and polling agents. To deploy these changes you must then
        restart the agent. If pollsters and notifications are both modified, then you will have to
        restart both the Polling Agent and the Notification Agent. Ceilometer Collector will also
        need to be restarted. The following code is an example of a compute-only Ceilometer
        Notification Agent (notification agent) <b>pipeline.yml </b>file:</p>
      <codeblock>---
sources:
    - name: meter_source
      interval: 86400
      meters:
          - "instance"
          - "memory"
          - "vcpus"
          - "compute.instance.create.end"
          - "compute.instance.delete.end"
          - "compute.instance.update"
          - "compute.instance.exists"
      sinks:
          - meter_sink
sinks:
    - name: meter_sink
      transformers:
      publishers:
          - notifier://</codeblock>
        
        <note type="important">If you enable meters at the container level in this file, every time the polling interval
          triggers a collection, at least 5 messages per existing container in Swift are collected.</note> 
          
          <p>The following table illustrates the amount of data produced hourly in different scenarios: </p>
          <table>
        <tgroup cols="4">
          <tbody>
            <row>
              <entry>Swift Containers</entry>
              <entry>Swift Objects per container</entry>
              <entry>Samples per Hour</entry>
              <entry>Samples stored per 24 hours</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>10</entry>
              <entry>500</entry>
              <entry>12000</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>100</entry>
              <entry>5000</entry>
              <entry>120000</entry>
            </row>
            <row>
              <entry>100</entry>
              <entry>100</entry>
              <entry>50000</entry>
              <entry>1200000</entry>
            </row>
            <row>
              <entry>100</entry>
              <entry>1000</entry>
              <entry>500000</entry>
              <entry>12000000</entry>
            </row>
          </tbody>
        </tgroup>
      </table><p>The data in the table shows that even a very small Swift storage with 10 containers
        and 100 files will store 120,000 samples in 24 hours, generating a total of 3.6 million
        samples.</p>
      
      <note type="important">The size of each file does not have any impact on the
        number of samples collected. As shown in the table above, the smallest number of samples
        results from polling when there are a small number of files and a small number of
        containers. When there are a lot of small files and containers, the number of samples is the
        highest. </note>
    </section>
    
    <section id="meters_add">
      <title>Add Resource Fields to Meters</title>
      
      <p>By default, not all the resource metadata fields for an event are recorded and stored in
        Ceilometer. If you want to collect metadata fields for a consumer application, for example,
        it is easier to add a field to an existing meter rather than creating a new meter. If you
        create a new meter, you must also reconfigure Ceilometer.</p>
      
      <note type="attention">Consider the following information before you add or edit a meter: <ul>
          <li>You can add a maximum of 12 new fields.</li>
          <li>Adding or editing a meter causes all non-default meters to STOP receiving
            notifications. You will need to restart Ceilometer.</li>
        <li>New meters added to the <codeph>pipeline-polling.yaml.j2</codeph> file must also be added to the
            <codeph>pipeline-agent-notification.yaml.j2</codeph> file. This is due to the fact that polling meters
            are drained by the notification agent and not by the collector.</li>
          <li>After Helion is installed, services like compute, cinder, glance, and neutron are
            configured to publish Ceilometer meters by default. Other meters can also be enabled
            after the services are configured to start publishing the meter. The only requirement
            for publishing a meter is that the <codeph>origin</codeph> must have a value of
              <codeph>notification</codeph>. For a complete list of meters, see the OpenStack
            documentation on <xref
              href="http://docs.openstack.org/admin-guide/telemetry-measurements.html"
              scope="external" format="html">Measurements</xref>.</li>
          <li>Not all meters are supported. Meters collected by Ceilometer Compute Agent or any
            agent other than Ceilometer Polling are not supported or tested with Helion.</li>
          <li>Identity meters are disabled by Keystone in Helion OpenStack 3.0 and have not been
            tested.</li>
          <li>To enable Ceilometer to start collecting meters, some services require you enable the
            meters you need in the service first before enabling them in Ceilometer. One example is
            Ceph. Refer to the documentation for the specific service before you add new meters or
            resource fields.</li>
        </ul></note> 
        
      <p><b>To add Resource Metadata fields:</b></p>
        <ol>
          <li>Log on to the Lifecycle manager (deployer node).</li>
          <li>To change to the Ceilometer directory, run:
          <codeblock>cd /home/stack/helion/my_cloud/config/ceilometer </codeblock></li>
          <li>In a text editor, open the target configuration file (for example, monasca-field-definitions.yaml.j2).</li>
          <li>In the metadata section, either add a new meter or edit an existing one provided by Helion.</li>
          <li>Include the metadata fields you need. You can use the <codeph>instance meter</codeph> in the file as an example.</li>
          <li>Save and close the configuration file.</li>
          <li>To save your changes in Helion, run:
          <codeblock>cd /home/stack/helion
git add -A
git commit -m "My config"</codeblock></li>
        <li>If you added a new meter, reconfigure Ceilometer:
          <codeblock>cd /home/stack/helion/hos/ansible/
# To run the config-processor playbook:
ansible-playbook -i hosts/localhost config-processor-run.yml 
#To run the ready-deployment playbook:
ansible-playbook -i hosts/localhost ready-deployment.yml
cd /home/stack/scratch/ansible/next/hos/ansible/
ansible-playbook -i hosts/verb_hosts ceilometer-reconfigure.yml</codeblock></li>
        </ol>
    </section>
    
    <section id="update_pollSwift">
      <title>Update the Polling Strategy and Swift Considerations</title><p>Polling can be
        very taxing on the system due to the sheer volume of data thtyat the system may have to
        process. It also has a severe impact on queries since the database will now have a very
        large amount of data to scan to respond to the query. This consumes a great amount of cpu
        and memory. This can result in long wait times for query responses, and in extreme cases can
        result in timeouts.</p> There are 3 polling meters in Swift: <ul>
        <li>storage.objects </li>
        <li>storage.objects.size </li>
        <li>storage.objects.containers</li>
      </ul> Here is an example of <b>pipeline.yml </b>in which Swift polling is set to occur hourly.
        <codeblock>---
      sources:
      - name: swift_source
      interval: 3600
      meters:
      - "storage.objects"
      - "storage.objects.size"
      - "storage.objects.containers"
      resources:
      discovery:
      sinks:
      - meter_sink
      sinks:
      - name: meter_sink
      transformers:
      publishers:
      - notifier://</codeblock><p>With
        this configuration above, we did not enable polling of container based meters and we only
        collect 3 messages for any given tenant, one for each meter listed in the configuration
        files. Since we have 3 messages only per tenant, it doesn't create a heavy load on the MySQL
        database as it would have if container-based meters were enabled. Hence, other APIs doesn't
        get hit because of this data collection configuration. </p></section>
   
   
   
  </body>
</topic>
