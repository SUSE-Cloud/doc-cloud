<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd" >
<topic id="writing_custom_plugins">
    <title>Writing Custom Plugins</title>
        <body>
        <p>When the pre-built Monasca plugins don't meet your monitoring needs, you can write custom
            plugins to monitor your cloud. After you have written a plugin, you must install and
            configure it.</p>
        <p>When your needs dictate a very specific custom monitoring check, you must provide both a
            detection and check plugin.</p>
        <p>The steps involved in configuring a custom plugin include running a detection plugin and
            passing any necesssary parameters to the detection plugin so the resulting check
            configuration file is created with all necessary data.</p>
        <p>When using an existing check plugin to monitor a third-party component, a custom
            detection plugin is needed only if there is not an associated default detection
            plugin.</p>
        <p/>
        <p><b>Check plugin configuration files</b></p>
        <p>Each plugin needs a corresponding YAML configuration file with the same stem name as the
            plugin check file. For example, the plugin file http_check.py should have a
            corresponding configuration file, http_check.yaml. The stem name <b>http_check</b> must
            be the same for both files.</p>
        <p>Permissions for the YAML configuration file must be <b>read+write</b> for mon-agent user
            (the user that must also own the file),  and <b>read</b> for the mon-agent group.
            Permissions for the file must be restricted to the <b>mon-agent</b> user and
                <b>mon-agent</b> group. The following example shows correct permissions settings for
            the file
            http_check.yaml.<codeblock>-rw-r----- 1 mon-agent mon-agent 10043 Sep 21 19:05 http_check.yaml</codeblock></p>
        <p/>
        <p>A check plugin YAML configuration file has the following
            structure.<codeblock>init_config:
    key1: value1
    key2: value2
 
instances:
    - name: john_smith
      username: john_smith
      password: 123456
    - name: jane_smith
      username: jane_smith
      password: 789012</codeblock></p>
        <p>In the above file structure, the <codeph>init_config</codeph> section allows you to
            specify any number of global <b>key:value</b> pairs. Each pair will be available on
            every run of the check that relates to the YAML configuration file.</p>
        <p>The <codeph>instances</codeph> section allows you to list the instances that the related
            check will be run on. The check will be run once on each instance listed in the
                <codeph>instances</codeph> section. Ensure that each instance listed in the
                <codeph>instances</codeph> section has a unique name. </p>
        <p/>
        <p><b>Custom detection plugins</b></p>
        <p>Detection plugins should be written to perform checks that ensure that a component can be
            monitored on a host. Any arguments needed by the associated check plugin are passed into
            the detection plugin at setup (configuration) time. The detection plugin will write to
            the associated check configuration file. </p>
        <p>When a detection plugin is successfully run in the configuration step, it will write to
            the check configuration YAML file. The configuration file for the check is written to
            the following directory.<codeblock>
/etc/monasca/agent/conf.d/</codeblock></p>
        <p/>
        <p><b>Writing process detection plugin using the ServicePlugin class</b></p>
        <p>The monasca-agent provides a <b>ServicePlugin</b> class that makes process detection
            monitoring easy.</p>
        <p><b>Process check</b></p>
        <p>The process check plugin generates metrics based on the process status for specified
            process names. It generates <b>process.pid_count</b> metrics for the specified
            dimensions, and a set of detailed process metrics for the specified dimensions by
            default.</p>
        <p>The ServicePlugin class allows you to specify a list of process name(s) to detect, and
            uses <b>psutil</b> to see if the process exists on the host. It then appends the
            process.yaml configuration file with the process name(s), if they don't already
            exist.</p>
        <p/>
        <p>The following is an example of a <b>process.py</b> check <b>ServicePlugin</b>.</p>
        <p>
            <codeblock>import monasca_setup.detection
 
class MonascaTransformDetect(monasca_setup.detection.ServicePlugin):
    """Detect Monasca Transform daemons and setup configuration to monitor them."""
    def __init__(self, template_dir, overwrite=False, args=None):
        log.info("\tWatching the monasca transform processes.")
        service_params = {
            'args': {},
            'template_dir': template_dir,
            'overwrite': overwrite,
            'service_name': 'monasca-transform',
            'process_names': ['monasca-transform','pyspark',
                              'transform/lib/driver']
        }
        super(MonascaTransformDetect, self).__init__(service_params)</codeblock>
        </p>
        <p/>
        <p><b>Writing a Custom Detection Plugin using Plugin or ArgsPlugin classes</b></p>
        <p>A custom detection plugin class should derive from either the Plugin or ArgsPlugin
            classes provided in the <codeph>monasca-agent/monasca_setup/detection</codeph>
            directory.</p>
        <p>If the plugin parses command line arguments, the ArgsPlugin class is useful. The
            ArgsPlugin class derives from the Plugin class. The ArgsPlugin class has a method to
            check for required arguments, and a method to return the instance that will be used for
            writing to the configuration file with the dimensions from the command line parsed and
            included.</p>
        <p>If the ArgsPlugin methods do not seem to apply, then derive directly from the Plugin
            class.</p>
        <p>When deriving from these classes, the following methods should be implemented.</p>
        <ul id="ul_dfd_kvs_px">
            <li>_<i>detect - set self.available=True when conditions are met that the thing to
                    monitor exists on a host.</i></li>
            <li><i>build</i>_config - writes the instance information to the configuration and
                return the configuration.</li>
            <li>dependencies_installed (default implementation is in ArgsPlugin, but not Plugin) -
                return true when python dependent libraries are installed.</li>
        </ul>
        <p>The following is an example custom detection
            plugin.<codeblock>
# (C) Copyright 2015-2016 Hewlett Packard Enterprise Development Company LP
 
import ast
import logging
 
import monasca_setup.agent_config
import monasca_setup.detection
 
log = logging.getLogger(__name__)
 
 
class HttpCheck(monasca_setup.detection.ArgsPlugin):
    """Setup an http_check according to the passed in args.
       Despite being a detection plugin this plugin does no detection and will be a noop without   arguments.
       Expects space separated arguments, the required argument is url. Optional parameters include:
       disable_ssl_validation and match_pattern.
    """
 
    def _detect(self):
        """Run detection, set self.available True if the service is detected.
        """
        self.available = self._check_required_args(['url'])
 
    def build_config(self):
        """Build the config as a Plugins object and return.
        """
        config = monasca_setup.agent_config.Plugins()
        # No support for setting headers at this time
        instance = self._build_instance(['url', 'timeout', 'username', 'password',
                                         'match_pattern', 'disable_ssl_validation',
                                         'name', 'use_keystone', 'collect_response_time'])
 
        # Normalize any boolean parameters
        for param in ['use_keystone', 'collect_response_time']:
            if param in self.args:
                instance[param] = ast.literal_eval(self.args[param].capitalize())
        # Set some defaults
        if 'collect_response_time' not in instance:
            instance['collect_response_time'] = True
        if 'name' not in instance:
            instance['name'] = self.args['url']
 
        config['http_check'] = {'init_config': None, 'instances': [instance]}
 
        return config</codeblock></p>
        <p/>
        <p><b>Installing a detection plugin in HPE Helion OpenStack</b></p>
        <p>Install a plugin by copying the plugin to the appropriate directory.</p>
        <p>The plugin should have file permissions of <b>read+write</b> for the root user (the user
            that should also own the file) and <b>read</b> for the root group and all other
            users.</p>
        <p>The following is an example of correct file permissions for the <b>http_check.py</b>
            file.<codeblock>-rw-r--r-- 1 root root 1769 Sep 19 20:14 http_check.py</codeblock></p>
        <p/>
        <p>Detection plugins should be placed in the following directory.</p>
        <p>
            <codeblock>/usr/lib/monasca/agent/custom_detect.d/</codeblock>
        </p>
        <p/>
        <p>The detection plugin directory name should be accessed using the
                <codeph>monasca_agent_detection_plugin_dir</codeph> Ansible variable. This variable
            is defined in the <codeph>roles/monasca-agent/vars/main.yml</codeph>
            file.<codeblock>monasca_agent_detection_plugin_dir: /usr/lib/monasca/agent/custom_detect.d/</codeblock></p>
        <p/>
        <p>Example Ansible <codeph>monasca_configure</codeph> task to install the
            plugin.<codeblock>---
- name: _CEI-CMN | monasca_configure |
    Copy Ceilometer Custom plugin
  become: yes
  copy:
    src: hlmceilometer_mon_plugin.py
    dest: "{{ monasca_agent_detection_plugin_dir }}"
    owner: root
    group: root
    mode: 0440</codeblock></p>
        <p/>
        <p><b>Custom check plugins</b></p>
        <p>Custom check plugins generate metrics. Scalability should be taken into consideration on
            systems that will have hundreds of servers, as a large number of metrics can affect
            performance by impacting disk performance, RAM and CPU usage. If too many metrics are
            added, the license for the Vertica database may be exceeded. </p>
        <p>You may want to tune your configuration parameters so that less-important metrics are not
            monitored as frequently. When check plugins are configured (when they have an associated
            YAML configuration file) the agent will attempt to run them.</p>
        <p>Checks should be abel to run within the 30-second metric collection window. If your check
            runs a command, you should provide a timeout to prevent the check from running longer
            than the default 30-second window. You can use the
                <codeph>monasca_agent.common.util.timeout_command</codeph> to set a timeout for your
            checks.</p>
        <p>Find a description of how to write custom check plugins at the following link. <xref
                href="https://github.com/openstack/monasca-agent/blob/master/docs/Customizations.md#creating-a-custom-check-plugin"
                format="html" scope="external"
                >https://github.com/openstack/monasca-agent/blob/master/docs/Customizations.md#creating-a-custom-check-plugin</xref></p>
        <p>Custom checks derive from the AgentCheck class located in the
                <codeph>monasca_agent/collector/checks/check.py</codeph> file. A check method is
            required.</p>
        <p>Metrics should contain dimensions that make each item that you are monitoring unique
            (such as service, component, hostname). The hostname dimension is defined by default
            within the AgentCheck class, so every metric has this dimension.</p>
        <p>A custom check will do the following.</p>
        <ul id="ul_lmm_h1t_px">
            <li>Read the configuration instance passed into the check method.</li>
            <li>Set dimensions that will be included in the metric.</li>
            <li>Create the metric with gauge, rate, or counter types.</li>
        </ul>
        <p>Metric Types:</p>
        <ul id="ul_mmm_h1t_px">
            <li>gauge: Instantaneous reading of a particular value (for example, mem.free_mb).</li>
            <li>rate: Measurement over a time period. The following equation can be used to define
                rate.<codeblock>rate=delta_v/float(delta_t)</codeblock></li>
            <li>counter: The number of events.Iincrement and decrement methods, for example,
                zookeeper.timeouts</li>
        </ul>
        <p/>
        <p>The following is an example component check named
            SimpleVerticaExample.<codeblock>import monasca_agent.collector.checks as checks
from monasca_agent.common.util import timeout_command
 
VERTICA_VERSION_QUERY = "SELECT version();"
 
 
class SimpleVerticaExample(checks.AgentCheck):
 
    def __init__(self, name, init_config, agent_config):
        super(SimpleVerticaExample, self).__init__(name, init_config, agent_config)
 
    @staticmethod
    def _get_config(instance):
        user = instance.get('user')
        password = instance.get('password')
        service = instance.get('service')
        timeout = int(instance.get('timeout'))
 
        return user, password, service, timeout
 
    def check(self, instance):
        user, password, service, node_name, timeout = self._get_config(instance)
 
        dimensions = self._set_dimensions({'component': 'vertica', 'service': service}, instance)
 
        results, connection_status = self._query_database(user, password, timeout, VERTICA_VERSION_QUERY)
 
        if connection_status != 0:
            self.gauge('vertica.connection_status', 1, dimensions=dimensions)
        else:
            # successful connection status
            self.gauge('vertica.connection_status', 0, dimensions=dimensions)
 
    def _query_database(self, user, password, timeout, query):
        stdout, stderr, return_code = timeout_command(["/opt/vertica/bin/vsql", "-U", user, "-w", password, "-A", "-R",
                                                       "|", "-t", "-F", ",", "-x"], timeout, command_input=query)
        if return_code == 0:
            # remove trailing newline
            stdout = stdout.rstrip()
            return stdout, 0
        else:
            self.log.error("Error querying vertica with return code of {0} and error {1}".format(return_code, stderr))
            return stderr, 1</codeblock></p>
        <p/>
        <p><b>Installing check plugin</b></p>
        <p>The check plugin needs to have the same file permissions as the detection plugin. File
            permissions must be <b>read+write</b> for the root user (the user that should own the
            file), and <b>read</b> for the root group and all other users.</p>
        <p>Check plugins should be placed in the following
            directory.<codeblock>/usr/lib/monasca/agent/custom_checks.d/</codeblock></p>
        <p/>
        <p>The check plugin directory should be accessed using the
                <codeph>monasca_agent_check_plugin_dir</codeph> Ansible variable. This variable is
            defined in the <codeph>roles/monasca-agent/vars/main.yml</codeph>
            file.<codeblock>monasca_agent_check_plugin_dir: /usr/lib/monasca/agent/custom_checks.d/</codeblock></p>
    </body>
</topic>
