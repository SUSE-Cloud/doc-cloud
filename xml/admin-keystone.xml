<chapter xml:id="administrator-guides" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
    <title>Keystone Administrator Guide</title>
    <section xml:id="identity-management" xml:base="admin/index">
      <title>Keystone Administrator Guide</title>
      <para>OpenStack Identity (Keystone), is the default Identity
            management system for OpenStack. After you install Identity, you
            configure it through the <literal>/etc/keystone/keystone.conf</literal>
            configuration file and, possibly, a separate logging configuration
            file. You initialize data into Identity by using the <literal>keystone</literal>
            command-line client.</para>
      <section xml:id="identity-concepts" xml:base="identity-concepts">
        <title>Identity concepts</title>
        <variablelist>
          <varlistentry>
            <term>Authentication</term>
            <listitem>
              <para>The process of confirming the identity of a user. To confirm an incoming
                        request, OpenStack Identity validates a set of credentials users
                        supply. Initially, these credentials are a user name and password, or a
                        user name and API key. When OpenStack Identity validates user credentials,
                        it issues an authentication token. Users provide the token in
                        subsequent requests.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Credentials</term>
            <listitem>
              <para>Data that confirms the identity of the user. For example, user
                        name and password, user name and API key, or an authentication
                        token that the Identity service provides.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Domain</term>
            <listitem>
              <para>An Identity service API v3 entity. Domains are a collection of
                        projects and users that define administrative boundaries for
                        managing Identity entities. Domains can represent an
                        individual, company, or operator-owned space. They expose
                        administrative activities directly to system users. Users can be
                        granted the administrator role for a domain. A domain
                        administrator can create projects, users, and groups in a domain
                        and assign roles to users and groups in a domain.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Endpoint</term>
            <listitem>
              <para>A network-accessible address, usually a URL, through which you can
                        access a service. If you are using an extension for templates, you
                        can create an endpoint template that represents the templates of
                        all consumable services that are available across the regions.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Group</term>
            <listitem>
              <para>An Identity service API v3 entity. Groups are a collection of
                        users owned by a domain. A group role, granted to a domain
                        or project, applies to all users in the group. Adding or removing
                        users to or from a group grants or revokes their role and
                        authentication to the associated domain or project.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>OpenStackClient</term>
            <listitem>
              <para>A command-line interface for several OpenStack services including
                        the Identity API. For example, a user can run the
                        <command>openstack service create</command> and
                        <command>openstack endpoint create</command> commands to register services
                        in their OpenStack installation.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Project</term>
            <listitem>
              <para>A container that groups or isolates resources or identity objects.
                        Depending on the service operator, a project might map to a
                        customer, account, organization, or tenant.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Region</term>
            <listitem>
              <para>An Identity service API v3 entity. Represents a general division
                        in an OpenStack deployment. You can associate zero or more
                        sub-regions with a region to make a tree-like structured hierarchy.
                        Although a region does not have a geographical connotation, a
                        deployment can use a geographical name for a region, such as <literal>us-east</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Role</term>
            <listitem>
              <para>A personality with a defined set of user rights and privileges to
                        perform a specific set of operations. The Identity service issues
                        a token to a user that includes a list of roles. When a user calls
                        a service, that service interprets the user role set, and
                        determines to which operations or resources each role grants
                        access.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Service</term>
            <listitem>
              <para>An OpenStack service, such as Compute (nova), Object Storage
                        (swift), or Image service (glance), that provides one or more
                        endpoints through which users can access resources and perform
                        operations.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Token</term>
            <listitem>
              <para>An alpha-numeric text string that enables access to OpenStack APIs
                        and resources. A token may be revoked at any time and is valid for
                        a finite duration. While OpenStack Identity supports token-based
                        authentication in this release, it intends to support additional
                        protocols in the future. OpenStack Identity is an integration
                        service that does not aspire to be a full-fledged identity store
                        and management solution.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>User</term>
            <listitem>
              <para>A digital representation of a person, system, or service that uses
                        OpenStack cloud services. The Identity service validates that
                        incoming requests are made by the user who claims to be making the
                        call. Users have a login and can access resources by using
                        assigned tokens. Users can be directly assigned to a particular
                        project and behave as if they are contained in that project.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <section xml:id="user-management">
          <title>User management</title>
          <para>Identity user management examples:</para>
          <itemizedlist>
            <listitem>
              <para>Create a user named <literal>alice</literal>:</para>
              <screen language="console">$ openstack user create --password-prompt --email alice@example.com alice</screen>
            </listitem>
            <listitem>
              <para>Create a project named <literal>acme</literal>:</para>
              <screen language="console">$ openstack project create acme --domain default</screen>
            </listitem>
            <listitem>
              <para>Create a domain named <literal>emea</literal>:</para>
              <screen language="console">$ openstack --os-identity-api-version=3 domain create emea</screen>
            </listitem>
            <listitem>
              <para>Create a role named <literal>compute-user</literal>:</para>
              <screen language="console">$ openstack role create compute-user</screen>
              <note>
                <para>Individual services assign meaning to roles, typically through
                            limiting or granting access to users with the role to the
                            operations that the service supports. Role access is typically
                            configured in the service’s <literal>policy.json</literal> file. For example,
                            to limit Compute access to the <literal>compute-user</literal> role, edit the
                            Compute service’s <literal>policy.json</literal> file to require this role for
                            Compute operations.</para>
              </note>
            </listitem>
          </itemizedlist>
          <para>The Identity service assigns a project and a role to a user. You might
                assign the <literal>compute-user</literal> role to the <literal>alice</literal> user in the <literal>acme</literal>
                project:</para>
          <screen language="console">$ openstack role add --project acme --user alice compute-user</screen>
          <para>A user can have different roles in different projects. For example, Alice
                might also have the <literal>admin</literal> role in the <literal>Cyberdyne</literal> project. A user
                can also have multiple roles in the same project.</para>
          <para>The <literal>/etc/[SERVICE_CODENAME]/policy.json</literal> file controls the
                tasks that users can perform for a given service. For example, the
                <literal>/etc/nova/policy.json</literal> file specifies the access policy for the
                Compute service, the <literal>/etc/glance/policy.json</literal> file specifies
                the access policy for the Image service, and the
                <literal>/etc/keystone/policy.json</literal> file specifies the access policy for
                the Identity service.</para>
          <para>The default <literal>policy.json</literal> files in the Compute, Identity, and
                Image services recognize only the <literal>admin</literal> role. Any user with
                any role in a project can access all operations that do not require the
                <literal>admin</literal> role.</para>
          <para>To restrict users from performing operations in, for example, the
                Compute service, you must create a role in the Identity service and
                then modify the <literal>/etc/nova/policy.json</literal> file so that this role
                is required for Compute operations.</para>
          <para>For example, the following line in the <literal>/etc/cinder/policy.json</literal>
                file does not restrict which users can create volumes:</para>
          <screen language="none">"volume:create": "",</screen>
          <para>If the user has any role in a project, they can create volumes in that
                project.</para>
          <para>To restrict the creation of volumes to users who have the
                <literal>compute-user</literal> role in a particular project, you add <literal>"role:compute-user"</literal>:</para>
          <screen language="none">"volume:create": "role:compute-user",</screen>
          <para>To restrict all Compute service requests to require this role, the
                resulting file looks like:</para>
          <screen language="json">{
   "admin_or_owner": "role:admin or project_id:%(project_id)s",
   "default": "rule:admin_or_owner",
   "compute:create": "role:compute-user",
   "compute:create:attach_network": "role:compute-user",
   "compute:create:attach_volume": "role:compute-user",
   "compute:get_all": "role:compute-user",
   "compute:unlock_override": "rule:admin_api",
   "admin_api": "role:admin",
   "compute_extension:accounts": "rule:admin_api",
   "compute_extension:admin_actions": "rule:admin_api",
   "compute_extension:admin_actions:pause": "rule:admin_or_owner",
   "compute_extension:admin_actions:unpause": "rule:admin_or_owner",
   "compute_extension:admin_actions:suspend": "rule:admin_or_owner",
   "compute_extension:admin_actions:resume": "rule:admin_or_owner",
   "compute_extension:admin_actions:lock": "rule:admin_or_owner",
   "compute_extension:admin_actions:unlock": "rule:admin_or_owner",
   "compute_extension:admin_actions:resetNetwork": "rule:admin_api",
   "compute_extension:admin_actions:injectNetworkInfo": "rule:admin_api",
   "compute_extension:admin_actions:createBackup": "rule:admin_or_owner",
   "compute_extension:admin_actions:migrateLive": "rule:admin_api",
   "compute_extension:admin_actions:migrate": "rule:admin_api",
   "compute_extension:aggregates": "rule:admin_api",
   "compute_extension:certificates": "role:compute-user",
   "compute_extension:cloudpipe": "rule:admin_api",
   "compute_extension:console_output": "role:compute-user",
   "compute_extension:consoles": "role:compute-user",
   "compute_extension:createserverext": "role:compute-user",
   "compute_extension:deferred_delete": "role:compute-user",
   "compute_extension:disk_config": "role:compute-user",
   "compute_extension:evacuate": "rule:admin_api",
   "compute_extension:extended_server_attributes": "rule:admin_api",
   "compute_extension:extended_status": "role:compute-user",
   "compute_extension:flavorextradata": "role:compute-user",
   "compute_extension:flavorextraspecs": "role:compute-user",
   "compute_extension:flavormanage": "rule:admin_api",
   "compute_extension:floating_ip_dns": "role:compute-user",
   "compute_extension:floating_ip_pools": "role:compute-user",
   "compute_extension:floating_ips": "role:compute-user",
   "compute_extension:hosts": "rule:admin_api",
   "compute_extension:keypairs": "role:compute-user",
   "compute_extension:multinic": "role:compute-user",
   "compute_extension:networks": "rule:admin_api",
   "compute_extension:quotas": "role:compute-user",
   "compute_extension:rescue": "role:compute-user",
   "compute_extension:security_groups": "role:compute-user",
   "compute_extension:server_action_list": "rule:admin_api",
   "compute_extension:server_diagnostics": "rule:admin_api",
   "compute_extension:simple_tenant_usage:show": "rule:admin_or_owner",
   "compute_extension:simple_tenant_usage:list": "rule:admin_api",
   "compute_extension:users": "rule:admin_api",
   "compute_extension:virtual_interfaces": "role:compute-user",
   "compute_extension:virtual_storage_arrays": "role:compute-user",
   "compute_extension:volumes": "role:compute-user",
   "compute_extension:volume_attachments:index": "role:compute-user",
   "compute_extension:volume_attachments:show": "role:compute-user",
   "compute_extension:volume_attachments:create": "role:compute-user",
   "compute_extension:volume_attachments:delete": "role:compute-user",
   "compute_extension:volumetypes": "role:compute-user",
   "volume:create": "role:compute-user",
   "volume:get_all": "role:compute-user",
   "volume:get_volume_metadata": "role:compute-user",
   "volume:get_snapshot": "role:compute-user",
   "volume:get_all_snapshots": "role:compute-user",
   "network:get_all_networks": "role:compute-user",
   "network:get_network": "role:compute-user",
   "network:delete_network": "role:compute-user",
   "network:disassociate_network": "role:compute-user",
   "network:get_vifs_by_instance": "role:compute-user",
   "network:allocate_for_instance": "role:compute-user",
   "network:deallocate_for_instance": "role:compute-user",
   "network:validate_networks": "role:compute-user",
   "network:get_instance_uuids_by_ip_filter": "role:compute-user",
   "network:get_floating_ip": "role:compute-user",
   "network:get_floating_ip_pools": "role:compute-user",
   "network:get_floating_ip_by_address": "role:compute-user",
   "network:get_floating_ips_by_project": "role:compute-user",
   "network:get_floating_ips_by_fixed_address": "role:compute-user",
   "network:allocate_floating_ip": "role:compute-user",
   "network:deallocate_floating_ip": "role:compute-user",
   "network:associate_floating_ip": "role:compute-user",
   "network:disassociate_floating_ip": "role:compute-user",
   "network:get_fixed_ip": "role:compute-user",
   "network:add_fixed_ip_to_instance": "role:compute-user",
   "network:remove_fixed_ip_from_instance": "role:compute-user",
   "network:add_network_to_project": "role:compute-user",
   "network:get_instance_nw_info": "role:compute-user",
   "network:get_dns_domains": "role:compute-user",
   "network:add_dns_entry": "role:compute-user",
   "network:modify_dns_entry": "role:compute-user",
   "network:delete_dns_entry": "role:compute-user",
   "network:get_dns_entries_by_address": "role:compute-user",
   "network:get_dns_entries_by_name": "role:compute-user",
   "network:create_private_dns_domain": "role:compute-user",
   "network:create_public_dns_domain": "role:compute-user",
   "network:delete_dns_domain": "role:compute-user"
}</screen>
        </section>
        <section xml:id="service-management">
          <title>Service management</title>
          <para>The Identity service provides identity, token, catalog, and policy
                services. It consists of:</para>
          <itemizedlist>
            <listitem>
              <variablelist>
                <varlistentry>
                  <term>keystone Web Server Gateway Interface (WSGI) service</term>
                  <listitem>
                    <para>Can be run in a WSGI-capable web server such as Apache httpd to provide
                                    the Identity service. The service and administrative APIs are run as
                                    separate instances of the WSGI service.</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
            <listitem>
              <variablelist>
                <varlistentry>
                  <term>Identity service functions</term>
                  <listitem>
                    <para>Each has a pluggable back end that allow different ways to use the
                                    particular service. Most support standard back ends like LDAP or SQL.</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
            <listitem>
              <variablelist>
                <varlistentry>
                  <term>keystone-all</term>
                  <listitem>
                    <para>Starts both the service and administrative APIs in a single process.
                                    Using federation with <literal>keystone-all</literal> is not supported. <literal>keystone-all</literal> is
                                    deprecated in favor of the WSGI service. Also, this will be removed
                                    in Newton.</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
          </itemizedlist>
          <para>The Identity service also maintains a user that corresponds to each
                service, such as, a user named <literal>nova</literal> for the Compute service, and a
                special service project called <literal>service</literal>.</para>
          <para>For information about how to create services and endpoints, see the
                <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://docs.openstack.org/admin-guide/cli-manage-services.html">OpenStack Administrator Guide</link>.</para>
        </section>
        <section xml:id="groups">
          <title>Groups</title>
          <para>A group is a collection of users in a domain. Administrators can
                create groups and add users to them. A role can then be assigned to
                the group, rather than individual users. Groups were introduced with
                the Identity API v3.</para>
          <para>Identity API V3 provides the following group-related operations:</para>
          <itemizedlist>
            <listitem>
              <para>Create a group</para>
            </listitem>
            <listitem>
              <para>Delete a group</para>
            </listitem>
            <listitem>
              <para>Update a group (change its name or description)</para>
            </listitem>
            <listitem>
              <para>Add a user to a group</para>
            </listitem>
            <listitem>
              <para>Remove a user from a group</para>
            </listitem>
            <listitem>
              <para>List group members</para>
            </listitem>
            <listitem>
              <para>List groups for a user</para>
            </listitem>
            <listitem>
              <para>Assign a role on a project to a group</para>
            </listitem>
            <listitem>
              <para>Assign a role on a domain to a group</para>
            </listitem>
            <listitem>
              <para>Query role assignments to groups</para>
            </listitem>
          </itemizedlist>
          <note>
            <para>The Identity service server might not allow all operations. For
                    example, if you use the Identity server with the LDAP Identity
                    back end and group updates are disabled, a request to create,
                    delete, or update a group fails.</para>
          </note>
          <para>Here are a couple of examples:</para>
          <itemizedlist>
            <listitem>
              <para>Group A is granted Role A on Project A. If User A is a member of Group
                        A, when User A gets a token scoped to Project A, the token also
                        includes Role A.</para>
            </listitem>
            <listitem>
              <para>Group B is granted Role B on Domain B. If User B is a member of
                        Group B, when User B gets a token scoped to Domain B, the token also
                        includes Role B.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
      <section xml:id="bootstrapping-identity" xml:base="identity-bootstrap">
        <title>Bootstrapping Identity</title>
        <para>After keystone is deployed and configured, it must be pre-populated with some
            initial data before it can be used. This process is known as bootstrapping and
            it typically involves creating the system’s first user, project, domain,
            service, and endpoint, among other things. The goal of bootstrapping is to put
            enough information into the system such that it can function solely through the
            API using normal authentication flows. After the first user is created, which
            must be an administrator, you can use that account to interact with keystone
            via the API.</para>
        <para>Keystone provides two separate ways to bootstrap a deployment. The first is
            with the <literal>keystone-manage bootstrap</literal> command. This is the perferred and
            recommended way to boostrap new installations. The second, and original way of
            bootstrapping involves configuring a secret and deploying special middleware in
            front of the identity service. The secret is known as the <literal>ADMIN_TOKEN</literal>. Any
            requests made to the identity API with the <literal>ADMIN_TOKEN</literal> will completely
            bypass authentication allowing access to the entire API.</para>
        <section xml:id="using-the-cli">
          <title>Using the CLI</title>
          <para>The process requires access to an environment with keystone binaries
                installed, typically on the service host.</para>
          <para>The <literal>keystone-manage bootstrap</literal> command will create a user, project and role,
                and will assign the newly created role to the newly created user on the newly
                created project. By default, the names of these new resources will be called
                <literal>admin</literal>.</para>
          <para>The defaults may be overridden by calling <literal>--bootstrap-username</literal>,
                <literal>--bootstrap-project-name</literal> and <literal>--bootstrap-role-name</literal>. Each of these have
                an environment variable equivalent: <literal>OS_BOOTSTRAP_USERNAME</literal>,
                <literal>OS_BOOTSTRAP_PROJECT_NAME</literal> and <literal>OS_BOOTSTRAP_ROLE_NAME</literal>.</para>
          <para>A user password must also be supplied. This can be passed in as either
                <literal>--bootstrap-password</literal>, or set as an environment variable using
                <literal>OS_BOOTSTRAP_PASSWORD</literal>.</para>
          <para>Optionally, if specified by <literal>--bootstrap-public-url</literal>,
                <literal>--bootstrap-admin-url</literal>, <literal>--bootstrap-internal-url</literal> or the equivalent
                environment variables, the command creates an identity service with the
                specified endpoint information. You may also configure the
                <literal>--bootstrap-region-id</literal> and <literal>--bootstrap-service-name</literal> for the endpoints to
                your deployment’s requirements.</para>
          <note>
            <para>We strongly recommend that you configure the identity service and its
                    endpoints while bootstrapping keystone.</para>
          </note>
          <para>Minimally, keystone can be bootstrapped with:</para>
          <screen language="bash">$ keystone-manage bootstrap --bootstrap-password s3cr3t</screen>
          <para>Verbosely, keystone can be bootstrapped with:</para>
          <screen language="bash">$ keystone-manage bootstrap \
    --bootstrap-password s3cr3t \
    --bootstrap-username admin \
    --bootstrap-project-name admin \
    --bootstrap-role-name admin \
    --bootstrap-service-name keystone \
    --bootstrap-region-id RegionOne \
    --bootstrap-admin-url http://localhost:35357 \
    --bootstrap-public-url http://localhost:5000 \
    --bootstrap-internal-url http://localhost:5000</screen>
          <para>This will create an <literal>admin</literal> user with the <literal>admin</literal> role on the <literal>admin</literal>
                project. The user will have the password specified in the command. Note that
                both the user and the project will be created in the <literal>default</literal> domain. By not
                creating an endpoint in the catalog users will need to provide endpoint
                overrides to perform additional identity operations.</para>
          <para>By creating an <literal>admin</literal> user and an identity endpoint you may
                authenticate to keystone and perform identity operations like creating
                additional services and endpoints using the <literal>admin</literal> user. This will preclude
                the need to ever use or configure the <literal>admin_token</literal> (described below). It is
                also, by design, more secure.</para>
          <para>To test a proper configuration, a user can use OpenStackClient CLI:</para>
          <screen language="bash">$ openstack project list --os-username admin --os-project-name admin \
    --os-user-domain-id default --os-project-domain-id default \
    --os-identity-api-version 3 --os-auth-url http://localhost:5000 \
    --os-password s3cr3t</screen>
        </section>
        <section xml:id="using-a-shared-secret">
          <title>Using a shared secret</title>
          <note>
            <para>We strongly recommended that you configure the identity service with the
                    <literal>keystone-manage bootstrap</literal> command and not the <literal>ADMIN_TOKEN</literal>. The
                    <literal>ADMIN_TOKEN</literal> can leave your deployment vulnerable by exposing
                    administrator functionality through the API based solely on a single
                    secret.</para>
          </note>
          <para>Before you can use the identity API, you need to configure keystone with a
                shared secret. Requests made with this secret will bypass authentication and
                grant administrative access to the identity API. The following configuration
                snippet shows the shared secret as being <literal>ADMIN</literal>:</para>
          <screen language="bash">[DEFAULT]
admin_token = ADMIN</screen>
          <para>You can use the shared secret, or <literal>admin_token</literal>, to make API request to
                keystone that bootstrap the rest of the deployment.  You must create a project,
                user, and role in order to use normal user authentication through the API.</para>
          <para>The <literal>admin_token</literal> does not represent a user or explicit authorization of any
                kind. It is imperative that you disable the <literal>AdminTokenAuthMiddleware</literal> from
                your paste application pipelines after bootstrapping, especially in production
                deployments. Failure to remove this functionality exposes an additional attack
                vector and security risk.</para>
        </section>
      </section>
      <section xml:id="manage-projects-users-and-roles" xml:base="cli-manage-projects-users-and-roles">
        <title>Manage projects, users, and roles</title>
        <para>As an administrator, you manage projects, users, and
            roles. Projects are organizational units in the cloud to which
            you can assign users. Projects are also known as <emphasis>projects</emphasis> or
            <emphasis>accounts</emphasis>. Users can be members of one or more projects. Roles
            define which actions users can perform. You assign roles to
            user-project pairs.</para>
        <para>You can define actions for OpenStack service roles in the
            <literal>/etc/PROJECT/policy.json</literal> files. For example, define actions for
            Compute service roles in the <literal>/etc/nova/policy.json</literal> file.</para>
        <para>You can manage projects, users, and roles independently from each other.</para>
        <para>During cloud set up, the operator defines at least one project, user,
            and role.</para>
        <para>You can add, update, and delete projects and users, assign users to
            one or more projects, and change or remove the assignment. To enable or
            temporarily disable a project or user, update that project or user.
            You can also change quotas at the project level.</para>
        <para>Before you can delete a user account, you must remove the user account
            from its primary project.</para>
        <para>Before you can run client commands, you must download and
            source an OpenStack RC file. See <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://docs.openstack.org/user-guide/common/cli-set-environment-variables-using-openstack-rc.html#download-and-source-the-openstack-rc-file">Download and source the OpenStack RC file</link>.</para>
        <section xml:id="projects">
          <title>Projects</title>
          <para>A project is a group of zero or more users. In Compute, a project owns
                virtual machines. In Object Storage, a project owns containers. Users
                can be associated with more than one project. Each project and user
                pairing can have a role associated with it.</para>
          <section xml:id="list-projects">
            <title>List projects</title>
            <para>List all projects with their ID, name, and whether they are
                    enabled or disabled:</para>
            <screen language="console">$ openstack project list
+----------------------------------+--------------------+
| ID                               | Name               |
+----------------------------------+--------------------+
| f7ac731cc11f40efbc03a9f9e1d1d21f | admin              |
| c150ab41f0d9443f8874e32e725a4cc8 | alt_demo           |
| a9debfe41a6d4d09a677da737b907d5e | demo               |
| 9208739195a34c628c58c95d157917d7 | invisible_to_admin |
| 3943a53dc92a49b2827fae94363851e1 | service            |
| 80cab5e1f02045abad92a2864cfd76cb | test_project       |
+----------------------------------+--------------------+</screen>
          </section>
          <section xml:id="create-a-project">
            <title>Create a project</title>
            <para>Create a project named <literal>new-project</literal>:</para>
            <screen language="console">$ openstack project create --description 'my new project' new-project \
  --domain default
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description | my new project                   |
| domain_id   | e601210181f54843b51b3edff41d4980 |
| enabled     | True                             |
| id          | 1a4a0618b306462c9830f876b0bd6af2 |
| is_domain   | False                            |
| name        | new-project                      |
| parent_id   | e601210181f54843b51b3edff41d4980 |
+-------------+----------------------------------+</screen>
          </section>
          <section xml:id="keystone-update-a-project">
            <title>Update a project</title>
            <para>Specify the project ID to update a project. You can update the name,
                    description, and enabled status of a project.</para>
            <itemizedlist>
              <listitem>
                <para>To temporarily disable a project:</para>
                <screen language="console">$ openstack project set PROJECT_ID --disable</screen>
              </listitem>
              <listitem>
                <para>To enable a disabled project:</para>
                <screen language="console">$ openstack project set PROJECT_ID --enable</screen>
              </listitem>
              <listitem>
                <para>To update the name of a project:</para>
                <screen language="console">$ openstack project set PROJECT_ID --name project-new</screen>
              </listitem>
              <listitem>
                <para>To verify your changes, show information for the updated project:</para>
                <screen language="console">$ openstack project show PROJECT_ID
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description | my new project                   |
| enabled     | True                             |
| id          | 0b0b995694234521bf93c792ed44247f |
| name        | new-project                      |
| properties  |                                  |
+-------------+----------------------------------+</screen>
              </listitem>
            </itemizedlist>
          </section>
          <section xml:id="keystone-delete-a-project">
            <title>Delete a project</title>
            <para>Specify the project ID to delete a project:</para>
            <screen language="console">$ openstack project delete PROJECT_ID</screen>
          </section>
        </section>
        <section xml:id="users">
          <title>Users</title>
          <section xml:id="list-users">
            <title>List users</title>
            <para>List all users:</para>
            <screen language="console">$ openstack user list
+----------------------------------+----------+
| ID                               | Name     |
+----------------------------------+----------+
| 352b37f5c89144d4ad0534139266d51f | admin    |
| 86c0de739bcb4802b8dc786921355813 | demo     |
| 32ec34aae8ea432e8af560a1cec0e881 | glance   |
| 7047fcb7908e420cb36e13bbd72c972c | nova     |
+----------------------------------+----------+</screen>
          </section>
          <section xml:id="create-a-user">
            <title>Create a user</title>
            <para>To create a user, you must specify a name. Optionally, you can
                    specify a project ID, password, and email address. We recommend
                    including the project ID and password because the user cannot
                    log in to the dashboard without this information.</para>
            <para>Create the <literal>new-user</literal> user:</para>
            <screen language="console">$ openstack user create --project new-project --password PASSWORD new-user
+------------+----------------------------------+
| Field      | Value                            |
+------------+----------------------------------+
| email      | None                             |
| enabled    | True                             |
| id         | 6322872d9c7e445dbbb49c1f9ca28adc |
| name       | new-user                         |
| project_id | 0b0b995694234521bf93c792ed44247f |
| username   | new-user                         |
+------------+----------------------------------+</screen>
          </section>
          <section xml:id="keystone-update-a-user">
            <title>Update a user</title>
            <para>You can update the name, email address, and enabled status for a user.</para>
            <itemizedlist>
              <listitem>
                <para>To temporarily disable a user account:</para>
                <screen language="console">$ openstack user set USER_NAME --disable</screen>
                <para>If you disable a user account, the user cannot log in to the
                            dashboard. However, data for the user account is maintained, so you
                            can enable the user at any time.</para>
              </listitem>
              <listitem>
                <para>To enable a disabled user account:</para>
                <screen language="console">$ openstack user set USER_NAME --enable</screen>
              </listitem>
              <listitem>
                <para>To change the name and description for a user account:</para>
                <screen language="console">$ openstack user set USER_NAME --name user-new --email new-user@example.com
User has been updated.</screen>
              </listitem>
            </itemizedlist>
          </section>
          <section xml:id="delete-a-user">
            <title>Delete a user</title>
            <para>Delete a specified user account:</para>
            <screen language="console">$ openstack user delete USER_NAME</screen>
          </section>
        </section>
        <section xml:id="roles-and-role-assignments">
          <title>Roles and role assignments</title>
          <section xml:id="list-available-roles">
            <title>List available roles</title>
            <para>List the available roles:</para>
            <screen language="console">$ openstack role list
+----------------------------------+---------------+
| ID                               | Name          |
+----------------------------------+---------------+
| 71ccc37d41c8491c975ae72676db687f | Member        |
| 149f50a1fe684bfa88dae76a48d26ef7 | ResellerAdmin |
| 9fe2ff9ee4384b1894a90878d3e92bab | _member_      |
| 6ecf391421604da985db2f141e46a7c8 | admin         |
| deb4fffd123c4d02a907c2c74559dccf | anotherrole   |
+----------------------------------+---------------+</screen>
          </section>
          <section xml:id="keystone-create-a-role">
            <title>Create a role</title>
            <para>Users can be members of multiple projects. To assign users to multiple
                    projects, define a role and assign that role to a user-project pair.</para>
            <para>Create the <literal>new-role</literal> role:</para>
            <screen language="console">$ openstack role create new-role
+-----------+----------------------------------+
| Field     | Value                            |
+-----------+----------------------------------+
| domain_id | None                             |
| id        | a34425c884c74c8881496dc2c2e84ffc |
| name      | new-role                         |
+-----------+----------------------------------+</screen>
            <note>
              <para>If you are using identity v3, you may need to use the
                        <literal>--domain</literal> option with a specific domain name.</para>
            </note>
          </section>
          <section xml:id="assign-a-role">
            <title>Assign a role</title>
            <para>To assign a user to a project, you must assign the role to a
                    user-project pair. To do this, you need the user, role, and project
                    IDs.</para>
            <procedure>
              <step>
                <para>List users and note the user ID you want to assign to the role:</para>
                <screen language="console">$ openstack user list
+----------------------------------+----------+
| ID                               | Name     |
+----------------------------------+----------+
| 6ab5800949644c3e8fb86aaeab8275c8 | admin    |
| dfc484b9094f4390b9c51aba49a6df34 | demo     |
| 55389ff02f5e40cf85a053cc1cacb20c | alt_demo |
| bc52bcfd882f4d388485451c4a29f8e0 | nova     |
| 255388ffa6e54ec991f584cb03085e77 | glance   |
| 48b6e6dec364428da89ba67b654fac03 | cinder   |
| c094dd5a8e1d4010832c249d39541316 | neutron  |
| 6322872d9c7e445dbbb49c1f9ca28adc | new-user |
+----------------------------------+----------+</screen>
              </step>
              <step>
                <para>List role IDs and note the role ID you want to assign:</para>
                <screen language="console">$ openstack role list
+----------------------------------+---------------+
| ID                               | Name          |
+----------------------------------+---------------+
| 71ccc37d41c8491c975ae72676db687f | Member        |
| 149f50a1fe684bfa88dae76a48d26ef7 | ResellerAdmin |
| 9fe2ff9ee4384b1894a90878d3e92bab | _member_      |
| 6ecf391421604da985db2f141e46a7c8 | admin         |
| deb4fffd123c4d02a907c2c74559dccf | anotherrole   |
| bef1f95537914b1295da6aa038ef4de6 | new-role      |
+----------------------------------+---------------+</screen>
              </step>
              <step>
                <para>List projects and note the project ID you want to assign to the role:</para>
                <screen language="console">$ openstack project list
+----------------------------------+--------------------+
| ID                               | Name               |
+----------------------------------+--------------------+
| 0b0b995694234521bf93c792ed44247f | new-project        |
| 29c09e68e6f741afa952a837e29c700b | admin              |
| 3a7ab11d3be74d3c9df3ede538840966 | invisible_to_admin |
| 71a2c23bab884c609774c2db6fcee3d0 | service            |
| 87e48a8394e34d13afc2646bc85a0d8c | alt_demo           |
| fef7ae86615f4bf5a37c1196d09bcb95 | demo               |
+----------------------------------+--------------------+</screen>
              </step>
              <step>
                <para>Assign a role to a user-project pair:</para>
                <screen language="console">$ openstack role add --user USER_NAME --project TENANT_ID ROLE_NAME</screen>
                <para>For example, assign the <literal>new-role</literal> role to the <literal>demo</literal> and
                            <literal>test-project</literal> pair:</para>
                <screen language="console">$ openstack role add --user demo --project test-project new-role</screen>
              </step>
              <step>
                <para>Verify the role assignment:</para>
                <screen language="console">$ openstack role assignment list --user USER_NAME \
  --project PROJECT_ID --names
+----------------------------------+-------------+---------+------+
| ID                               | Name        | Project | User |
+----------------------------------+-------------+---------+------+
| a34425c884c74c8881496dc2c2e84ffc | new-role    | demo    | demo |
| 04a7e3192c0745a2b1e3d2baf5a3ee0f | Member      | demo    | demo |
| 62bcf3e27eef4f648eb72d1f9920f6e5 | anotherrole | demo    | demo |
+----------------------------------+-------------+---------+------+</screen>
              </step>
            </procedure>
            <note>
              <para>Before the Newton release, users would run
                        the <command>openstack role list --user USER_NAME --project TENANT_ID</command> command to
                        verify the role assignment.</para>
            </note>
          </section>
          <section xml:id="view-role-details">
            <title>View role details</title>
            <para>View details for a specified role:</para>
            <screen language="console">$ openstack role show ROLE_NAME
+-----------+----------------------------------+
| Field     | Value                            |
+-----------+----------------------------------+
| domain_id | None                             |
| id        | a34425c884c74c8881496dc2c2e84ffc |
| name      | new-role                         |
+-----------+----------------------------------+</screen>
          </section>
          <section xml:id="remove-a-role">
            <title>Remove a role</title>
            <para>Remove a role from a user-project pair:</para>
            <procedure>
              <step>
                <para>Run the <command>openstack role remove</command> command:</para>
                <screen language="console">$ openstack role remove --user USER_NAME --project TENANT_ID ROLE_NAME</screen>
              </step>
              <step>
                <para>Verify the role removal:</para>
                <screen language="console">$ openstack role list --user USER_NAME --project TENANT_ID</screen>
                <para>If the role was removed, the command output omits the removed role.</para>
              </step>
            </procedure>
          </section>
        </section>
      </section>
      <section xml:id="create-and-manage-services-and-service-users" xml:base="cli-keystone-manage-services">
        <title>Create and manage services and service users</title>
        <para>The Identity service enables you to define services, as
            follows:</para>
        <itemizedlist>
          <listitem>
            <para>Service catalog template. The Identity service acts
                    as a service catalog of endpoints for other OpenStack
                    services. The <literal>/etc/keystone/default_catalog.templates</literal>
                    template file defines the endpoints for services. When
                    the Identity service uses a template file back end,
                    any changes that are made to the endpoints are cached.
                    These changes do not persist when you restart the
                    service or reboot the machine.</para>
          </listitem>
          <listitem>
            <para>An SQL back end for the catalog service. When the
                    Identity service is online, you must add the services
                    to the catalog. When you deploy a system for
                    production, use the SQL back end.</para>
          </listitem>
        </itemizedlist>
        <para>The <literal>auth_token</literal> middleware supports the
            use of either a shared secret or users for each
            service.</para>
        <para>To authenticate users against the Identity service, you must
            create a service user for each OpenStack service. For example,
            create a service user for the Compute, Block Storage, and
            Networking services.</para>
        <para>To configure the OpenStack services with service users,
            create a project for all services and create users for each
            service. Assign the admin role to each service user and
            project pair. This role enables users to validate tokens and
            authenticate and authorize other user requests.</para>
        <section xml:id="create-a-service">
          <title>Create a service</title>
          <procedure>
            <step>
              <para>List the available services:</para>
              <screen language="console">$ openstack service list
+----------------------------------+----------+------------+
| ID                               | Name     | Type       |
+----------------------------------+----------+------------+
| 9816f1faaa7c4842b90fb4821cd09223 | cinder   | volume     |
| 1250f64f31e34dcd9a93d35a075ddbe1 | cinderv2 | volumev2   |
| da8cf9f8546b4a428c43d5e032fe4afc | ec2      | ec2        |
| 5f105eeb55924b7290c8675ad7e294ae | glance   | image      |
| dcaa566e912e4c0e900dc86804e3dde0 | keystone | identity   |
| 4a715cfbc3664e9ebf388534ff2be76a | nova     | compute    |
| 1aed4a6cf7274297ba4026cf5d5e96c5 | novav21  | computev21 |
| bed063c790634c979778551f66c8ede9 | neutron  | network    |
| 6feb2e0b98874d88bee221974770e372 |    s3    |    s3      |
+----------------------------------+----------+------------+</screen>
            </step>
            <step>
              <para>To create a service, run this command:</para>
              <screen language="console">$ openstack service create --name SERVICE_NAME --description SERVICE_DESCRIPTION SERVICE_TYPE</screen>
              <variablelist>
                <varlistentry>
                  <term>The arguments are:</term>
                  <listitem>
                    <itemizedlist>
                      <listitem>
                        <para><literal>service_name</literal>: the unique name of the new service.</para>
                      </listitem>
                      <listitem>
                        <para><literal>service_type</literal>: the service type, such as <literal>identity</literal>,
                                            <literal>compute</literal>, <literal>network</literal>, <literal>image</literal>, <literal>object-store</literal>
                                            or any other service identifier string.</para>
                      </listitem>
                      <listitem>
                        <para><literal>service_description</literal>: the description of the service.</para>
                      </listitem>
                    </itemizedlist>
                  </listitem>
                </varlistentry>
              </variablelist>
              <para>For example, to create a <literal>swift</literal> service of type
                        <literal>object-store</literal>, run this command:</para>
              <screen language="console">$ openstack service create --name swift --description "object store service" object-store
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description | object store service             |
| enabled     | True                             |
| id          | 84c23f4b942c44c38b9c42c5e517cd9a |
| name        | swift                            |
| type        | object-store                     |
+-------------+----------------------------------+</screen>
            </step>
            <step>
              <para>To get details for a service, run this command:</para>
              <screen language="console">$ openstack service show SERVICE_TYPE|SERVICE_NAME|SERVICE_ID</screen>
              <para>For example:</para>
              <screen language="console">$ openstack service show object-store
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description | object store service             |
| enabled     | True                             |
| id          | 84c23f4b942c44c38b9c42c5e517cd9a |
| name        | swift                            |
| type        | object-store                     |
+-------------+----------------------------------+</screen>
            </step>
          </procedure>
        </section>
        <section xml:id="create-service-users">
          <title>Create service users</title>
          <procedure>
            <step>
              <para>Create a project for the service users.
                        Typically, this project is named <literal>service</literal>,
                        but choose any name you like:</para>
              <screen language="console">$ openstack project create service --domain default
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description | None                             |
| domain_id   | e601210181f54843b51b3edff41d4980 |
| enabled     | True                             |
| id          | 3e9f3f5399624b2db548d7f871bd5322 |
| is_domain   | False                            |
| name        | service                          |
| parent_id   | e601210181f54843b51b3edff41d4980 |
+-------------+----------------------------------+</screen>
            </step>
            <step>
              <para>Create service users for the relevant services for your
                        deployment.</para>
            </step>
            <step>
              <para>Assign the admin role to the user-project pair.</para>
              <screen language="console">$ openstack role add --project service --user SERVICE_USER_NAME admin
+-------+----------------------------------+
| Field | Value                            |
+-------+----------------------------------+
| id    | 233109e756c1465292f31e7662b429b1 |
| name  | admin                            |
+-------+----------------------------------+</screen>
            </step>
          </procedure>
        </section>
        <section xml:id="delete-a-service">
          <title>Delete a service</title>
          <para>To delete a specified service, specify its ID.</para>
          <screen language="console">$ openstack service delete SERVICE_TYPE|SERVICE_NAME|SERVICE_ID</screen>
          <para>For example:</para>
          <screen language="console">$ openstack service delete object-store</screen>
        </section>
      </section>
      <section xml:id="certificates-for-pki" xml:base="identity-certificates-for-pki">
        <title>Certificates for PKI</title>
        <para>PKI stands for Public Key Infrastructure. Tokens are documents,
            cryptographically signed using the X509 standard. In order to work
            correctly token generation requires a public/private key pair. The
            public key must be signed in an X509 certificate, and the certificate
            used to sign it must be available as a Certificate Authority (CA)
            certificate. These files can be generated either using the
            <command>keystone-manage</command> utility, or externally generated. The files need to
            be in the locations specified by the top level Identity service
            configuration file <literal>/etc/keystone/keystone.conf</literal> as specified in the
            above section. Additionally, the private key should only be readable by
            the system user that will run the Identity service.</para>
        <warning>
          <para>The certificates can be world readable, but the private key cannot
                be. The private key should only be readable by the account that is
                going to sign tokens. When generating files with the
                <command>keystone-manage pki_setup</command> command, your best option is to run
                as the pki user. If you run <command>keystone-manage</command> as root, you can
                append <literal>--keystone-user</literal> and <literal>--keystone-group</literal> parameters
                to set the user name and group keystone is going to run under.</para>
        </warning>
        <para>The values that specify where to read the certificates are under the
            <literal>[signing]</literal> section of the configuration file. The configuration
            values are:</para>
        <itemizedlist>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>certfile</literal>
                </term>
                <listitem>
                  <para>Location of certificate used to verify tokens. Default is
                                <literal>/etc/keystone/ssl/certs/signing_cert.pem</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>keyfile</literal>
                </term>
                <listitem>
                  <para>Location of private key used to sign tokens. Default is
                                <literal>/etc/keystone/ssl/private/signing_key.pem</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>ca_certs</literal>
                </term>
                <listitem>
                  <para>Location of certificate for the authority that issued
                                the above certificate. Default is
                                <literal>/etc/keystone/ssl/certs/ca.pem</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>ca_key</literal>
                </term>
                <listitem>
                  <para>Location of the private key used by the CA. Default is
                                <literal>/etc/keystone/ssl/private/cakey.pem</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>key_size</literal>
                </term>
                <listitem>
                  <para>Default is <literal>2048</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>valid_days</literal>
                </term>
                <listitem>
                  <para>Default is <literal>3650</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>cert_subject</literal>
                </term>
                <listitem>
                  <para>Certificate subject (auto generated certificate) for token signing.
                                Default is <literal>/C=US/ST=Unset/L=Unset/O=Unset/CN=www.example.com</literal>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </itemizedlist>
        <para>When generating certificates with the <command>keystone-manage pki_setup</command>
            command, the <literal>ca_key</literal>, <literal>key_size</literal>, and <literal>valid_days</literal> configuration
            options are used.</para>
        <para>If the <command>keystone-manage pki_setup</command> command is not used to generate
            certificates, or you are providing your own certificates, these values
            do not need to be set.</para>
        <para>If <literal>provider=keystone.token.providers.uuid.Provider</literal> in the
            <literal>[token]</literal> section of the keystone configuration file, a typical token
            looks like <literal>53f7f6ef0cc344b5be706bcc8b1479e1</literal>. If
            <literal>provider=keystone.token.providers.pki.Provider</literal>, a typical token is a
            much longer string, such as:</para>
        <screen>MIIKtgYJKoZIhvcNAQcCoIIKpzCCCqMCAQExCTAHBgUrDgMCGjCCCY8GCSqGSIb3DQEHAaCCCYAEggl8eyJhY2Nlc3MiOiB7InRva2VuIjogeyJpc3N1ZWRfYXQiOiAiMjAxMy0wNS0z
MFQxNTo1MjowNi43MzMxOTgiLCAiZXhwaXJlcyI6ICIyMDEzLTA1LTMxVDE1OjUyOjA2WiIsICJpZCI6ICJwbGFjZWhvbGRlciIsICJ0ZW5hbnQiOiB7ImRlc2NyaXB0aW9uIjogbnVs
bCwgImVuYWJsZWQiOiB0cnVlLCAiaWQiOiAiYzJjNTliNGQzZDI4NGQ4ZmEwOWYxNjljYjE4MDBlMDYiLCAibmFtZSI6ICJkZW1vIn19LCAic2VydmljZUNhdGFsb2ciOiBbeyJlbmRw
b2ludHMiOiBbeyJhZG1pblVSTCI6ICJodHRwOi8vMTkyLjE2OC4yNy4xMDA6ODc3NC92Mi9jMmM1OWI0ZDNkMjg0ZDhmYTA5ZjE2OWNiMTgwMGUwNiIsICJyZWdpb24iOiAiUmVnaW9u
T25lIiwgImludGVybmFsVVJMIjogImh0dHA6Ly8xOTIuMTY4LjI3LjEwMDo4Nzc0L3YyL2MyYzU5YjRkM2QyODRkOGZhMDlmMTY5Y2IxODAwZTA2IiwgImlkIjogIjFmYjMzYmM5M2Y5
ODRhNGNhZTk3MmViNzcwOTgzZTJlIiwgInB1YmxpY1VSTCI6ICJodHRwOi8vMTkyLjE2OC4yNy4xMDA6ODc3NC92Mi9jMmM1OWI0ZDNkMjg0ZDhmYTA5ZjE2OWNiMTgwMGUwNiJ9XSwg
ImVuZHBvaW50c19saW5rcyI6IFtdLCAidHlwZSI6ICJjb21wdXRlIiwgIm5hbWUiOiAibm92YSJ9LCB7ImVuZHBvaW50cyI6IFt7ImFkbWluVVJMIjogImh0dHA6Ly8xOTIuMTY4LjI3
LjEwMDozMzMzIiwgInJlZ2lvbiI6ICJSZWdpb25PbmUiLCAiaW50ZXJuYWxVUkwiOiAiaHR0cDovLzE5Mi4xNjguMjcuMTAwOjMzMzMiLCAiaWQiOiAiN2JjMThjYzk1NWFiNDNkYjhm
MGU2YWNlNDU4NjZmMzAiLCAicHVibGljVVJMIjogImh0dHA6Ly8xOTIuMTY4LjI3LjEwMDozMzMzIn1dLCAiZW5kcG9pbnRzX2xpbmtzIjogW10sICJ0eXBlIjogInMzIiwgIm5hbWUi
OiAiczMifSwgeyJlbmRwb2ludHMiOiBbeyJhZG1pblVSTCI6ICJodHRwOi8vMTkyLjE2OC4yNy4xMDA6OTI5MiIsICJyZWdpb24iOiAiUmVnaW9uT25lIiwgImludGVybmFsVVJMIjog
Imh0dHA6Ly8xOTIuMTY4LjI3LjEwMDo5MjkyIiwgImlkIjogIjczODQzNTJhNTQ0MjQ1NzVhM2NkOTVkN2E0YzNjZGY1IiwgInB1YmxpY1VSTCI6ICJodHRwOi8vMTkyLjE2OC4yNy4x
MDA6OTI5MiJ9XSwgImVuZHBvaW50c19saW5rcyI6IFtdLCAidHlwZSI6ICJpbWFnZSIsICJuYW1lIjogImdsYW5jZSJ9LCB7ImVuZHBvaW50cyI6IFt7ImFkbWluVVJMIjogImh0dHA6
Ly8xOTIuMTY4LjI3LjEwMDo4Nzc2L3YxL2MyYzU5YjRkM2QyODRkOGZhMDlmMTY5Y2IxODAwZTA2IiwgInJlZ2lvbiI6ICJSZWdpb25PbmUiLCAiaW50ZXJuYWxVUkwiOiAiaHR0cDov
LzE5Mi4xNjguMjcuMTAwOjg3NzYvdjEvYzJjNTliNGQzZDI4NGQ4ZmEwOWYxNjljYjE4MDBlMDYiLCAiaWQiOiAiMzQ3ZWQ2ZThjMjkxNGU1MGFlMmJiNjA2YWQxNDdjNTQiLCAicHVi
bGljVVJMIjogImh0dHA6Ly8xOTIuMTY4LjI3LjEwMDo4Nzc2L3YxL2MyYzU5YjRkM2QyODRkOGZhMDlmMTY5Y2IxODAwZTA2In1dLCAiZW5kcG9pbnRzX2xpbmtzIjogW10sICJ0eXBl
IjogInZvbHVtZSIsICJuYW1lIjogImNpbmRlciJ9LCB7ImVuZHBvaW50cyI6IFt7ImFkbWluVVJMIjogImh0dHA6Ly8xOTIuMTY4LjI3LjEwMDo4NzczL3NlcnZpY2VzL0FkbWluIiwg
InJlZ2lvbiI6ICJSZWdpb25PbmUiLCAiaW50ZXJuYWxVUkwiOiAiaHR0cDovLzE5Mi4xNjguMjcuMTAwOjg3NzMvc2VydmljZXMvQ2xvdWQiLCAiaWQiOiAiMmIwZGMyYjNlY2U4NGJj
YWE1NDAzMDMzNzI5YzY3MjIiLCAicHVibGljVVJMIjogImh0dHA6Ly8xOTIuMTY4LjI3LjEwMDo4NzczL3NlcnZpY2VzL0Nsb3VkIn1dLCAiZW5kcG9pbnRzX2xpbmtzIjogW10sICJ0
eXBlIjogImVjMiIsICJuYW1lIjogImVjMiJ9LCB7ImVuZHBvaW50cyI6IFt7ImFkbWluVVJMIjogImh0dHA6Ly8xOTIuMTY4LjI3LjEwMDozNTM1Ny92Mi4wIiwgInJlZ2lvbiI6ICJS
ZWdpb25PbmUiLCAiaW50ZXJuYWxVUkwiOiAiaHR0cDovLzE5Mi4xNjguMjcuMTAwOjUwMDAvdjIuMCIsICJpZCI6ICJiNTY2Y2JlZjA2NjQ0ZmY2OWMyOTMxNzY2Yjc5MTIyOSIsICJw
dWJsaWNVUkwiOiAiaHR0cDovLzE5Mi4xNjguMjcuMTAwOjUwMDAvdjIuMCJ9XSwgImVuZHBvaW50c19saW5rcyI6IFtdLCAidHlwZSI6ICJpZGVudGl0eSIsICJuYW1lIjogImtleXN0
b25lIn1dLCAidXNlciI6IHsidXNlcm5hbWUiOiAiZGVtbyIsICJyb2xlc19saW5rcyI6IFtdLCAiaWQiOiAiZTVhMTM3NGE4YTRmNDI4NWIzYWQ3MzQ1MWU2MDY4YjEiLCAicm9sZXMi
OiBbeyJuYW1lIjogImFub3RoZXJyb2xlIn0sIHsibmFtZSI6ICJNZW1iZXIifV0sICJuYW1lIjogImRlbW8ifSwgIm1ldGFkYXRhIjogeyJpc19hZG1pbiI6IDAsICJyb2xlcyI6IFsi
YWRiODM3NDVkYzQzNGJhMzk5ODllNjBjOTIzYWZhMjgiLCAiMzM2ZTFiNjE1N2Y3NGFmZGJhNWUwYTYwMWUwNjM5MmYiXX19fTGB-zCB-AIBATBcMFcxCzAJBgNVBAYTAlVTMQ4wDAYD
VQQIEwVVbnNldDEOMAwGA1UEBxMFVW5zZXQxDjAMBgNVBAoTBVVuc2V0MRgwFgYDVQQDEw93d3cuZXhhbXBsZS5jb20CAQEwBwYFKw4DAhowDQYJKoZIhvcNAQEBBQAEgYCAHLpsEs2R
nouriuiCgFayIqCssK3SVdhOMINiuJtqv0sE-wBDFiEj-Prcudqlz-n+6q7VgV4mwMPszz39-rwp+P5l4AjrJasUm7FrO-4l02tPLaaZXU1gBQ1jUG5e5aL5jPDP08HbCWuX6wr-QQQB
SrWY8lF3HrTcJT23sZIleg==</screen>
        <section xml:id="sign-certificate-issued-by-external-ca">
          <title>Sign certificate issued by external CA</title>
          <para>You can use a signing certificate issued by an external CA instead of
                generated by <command>keystone-manage</command>. However, a certificate issued by an
                external CA must satisfy the following conditions:</para>
          <itemizedlist>
            <listitem>
              <para>All certificate and key files must be in Privacy Enhanced Mail (PEM)
                        format</para>
            </listitem>
            <listitem>
              <para>Private key files must not be protected by a password</para>
            </listitem>
          </itemizedlist>
          <para>When using a signing certificate issued by an external CA, you do not
                need to specify <literal>key_size</literal>, <literal>valid_days</literal>, and <literal>ca_password</literal> as
                they will be ignored.</para>
          <para>The basic workflow for using a signing certificate issued by an external
                CA involves:</para>
          <procedure>
            <step>
              <para>Request Signing Certificate from External CA</para>
            </step>
            <step>
              <para>Convert certificate and private key to PEM if needed</para>
            </step>
            <step>
              <para>Install External Signing Certificate</para>
            </step>
          </procedure>
        </section>
        <section xml:id="request-a-signing-certificate-from-an-external-ca">
          <title>Request a signing certificate from an external CA</title>
          <para>One way to request a signing certificate from an external CA is to first
                generate a PKCS #10 Certificate Request Syntax (CRS) using OpenSSL CLI.</para>
          <para>Create a certificate request configuration file. For example, create the
                <literal>cert_req.conf</literal> file, as follows:</para>
          <screen language="ini">[ req ]
default_bits            = 4096
default_keyfile         = keystonekey.pem
default_md              = sha256

prompt                  = no
distinguished_name      = distinguished_name

[ distinguished_name ]
countryName             = US
stateOrProvinceName     = CA
localityName            = Sunnyvale
organizationName        = OpenStack
organizationalUnitName  = Keystone
commonName              = Keystone Signing
emailAddress            = keystone@openstack.org</screen>
          <para>Then generate a CRS with OpenSSL CLI. <emphasis role="bold">Do not encrypt the generated
                    private key. You must use the -nodes option.</emphasis></para>
          <para>For example:</para>
          <screen language="console">$ openssl req -newkey rsa:1024 -keyout signing_key.pem -keyform PEM \
  -out signing_cert_req.pem -outform PEM -config cert_req.conf -nodes</screen>
          <para>If everything is successful, you should end up with
                <literal>signing_cert_req.pem</literal> and <literal>signing_key.pem</literal>. Send
                <literal>signing_cert_req.pem</literal> to your CA to request a token signing certificate
                and make sure to ask the certificate to be in PEM format. Also, make sure your
                trusted CA certificate chain is also in PEM format.</para>
        </section>
        <section xml:id="install-an-external-signing-certificate">
          <title>Install an external signing certificate</title>
          <para>Assuming you have the following already:</para>
          <itemizedlist>
            <listitem>
              <variablelist>
                <varlistentry>
                  <term>
                    <literal>signing_cert.pem</literal>
                  </term>
                  <listitem>
                    <para>(Keystone token) signing certificate in PEM format</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
            <listitem>
              <variablelist>
                <varlistentry>
                  <term>
                    <literal>signing_key.pem</literal>
                  </term>
                  <listitem>
                    <para>Corresponding (non-encrypted) private key in PEM format</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
            <listitem>
              <variablelist>
                <varlistentry>
                  <term>
                    <literal>cacert.pem</literal>
                  </term>
                  <listitem>
                    <para>Trust CA certificate chain in PEM format</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
          </itemizedlist>
          <para>Copy the above to your certificate directory. For example:</para>
          <screen language="console"># mkdir -p /etc/keystone/ssl/certs
# cp signing_cert.pem /etc/keystone/ssl/certs/
# cp signing_key.pem /etc/keystone/ssl/certs/
# cp cacert.pem /etc/keystone/ssl/certs/
# chmod -R 700 /etc/keystone/ssl/certs</screen>
          <note>
            <para>Make sure the certificate directory is only accessible by root.</para>
          </note>
          <note>
            <para>The procedure of copying the key and cert files may be improved if
                    done after first running <command>keystone-manage pki_setup</command> since this
                    command also creates other needed files, such as the <literal>index.txt</literal>
                    and <literal>serial</literal> files.</para>
            <para>Also, when copying the necessary files to a different server for
                    replicating the functionality, the entire directory of files is
                    needed, not just the key and cert files.</para>
          </note>
          <para>If your certificate directory path is different from the default
                <literal>/etc/keystone/ssl/certs</literal>, make sure it is reflected in the
                <literal>[signing]</literal> section of the configuration file.</para>
        </section>
        <section xml:id="switching-out-expired-signing-certificates">
          <title>Switching out expired signing certificates</title>
          <para>The following procedure details how to switch out expired signing
                certificates with no cloud outages.</para>
          <procedure>
            <step>
              <para>Generate a new signing key.</para>
            </step>
            <step>
              <para>Generate a new certificate request.</para>
            </step>
            <step>
              <para>Sign the new certificate with the existing CA to generate a new
                        <literal>signing_cert</literal>.</para>
            </step>
            <step>
              <para>Append the new <literal>signing_cert</literal> to the old <literal>signing_cert</literal>. Ensure the
                        old certificate is in the file first.</para>
            </step>
            <step>
              <para>Remove all signing certificates from all your hosts to force OpenStack
                        Compute to download the new <literal>signing_cert</literal>.</para>
            </step>
            <step>
              <para>Replace the old signing key with the new signing key. Move the new
                        signing certificate above the old certificate in the <literal>signing_cert</literal>
                        file.</para>
            </step>
            <step>
              <para>After the old certificate reads as expired, you can safely remove the
                        old signing certificate from the file.</para>
            </step>
          </procedure>
        </section>
      </section>
      <section xml:id="domain-specific-configuration" xml:base="identity-domain-specific-config">
        <title>Domain-specific configuration</title>
        <para>The Identity service supports domain-specific Identity drivers.
            The drivers allow a domain to have its own LDAP or SQL back end.
            By default, domain-specific drivers are disabled.</para>
        <para>Domain-specific Identity configuration options can be stored in
            domain-specific configuration files, or in the Identity SQL
            database using API REST calls.</para>
        <note>
          <para>Storing and managing configuration options in an SQL database is
                experimental in Kilo, and added to the Identity service in the
                Liberty release.</para>
        </note>
        <section xml:id="enable-drivers-for-domain-specific-configuration-files">
          <title>Enable drivers for domain-specific configuration files</title>
          <para>To enable domain-specific drivers, set these options in the
                <literal>/etc/keystone/keystone.conf</literal> file:</para>
          <screen language="ini">[identity]
domain_specific_drivers_enabled = True
domain_config_dir = /etc/keystone/domains</screen>
          <para>When you enable domain-specific drivers, Identity looks in the
                <literal>domain_config_dir</literal> directory for configuration files that are named as
                <literal>keystone.DOMAIN_NAME.conf</literal>. A domain without a domain-specific
                configuration file uses options in the primary configuration file.</para>
        </section>
        <section xml:id="enable-drivers-for-storing-configuration-options-in-sql-database">
          <title>Enable drivers for storing configuration options in SQL database</title>
          <para>To enable domain-specific drivers, set these options in the
                <literal>/etc/keystone/keystone.conf</literal> file:</para>
          <screen language="ini">[identity]
domain_specific_drivers_enabled = True
domain_configurations_from_database = True</screen>
          <para>Any domain-specific configuration options specified through the
                Identity v3 API will override domain-specific configuration files in the
                <literal>/etc/keystone/domains</literal> directory.</para>
        </section>
        <section xml:id="migrate-domain-specific-configuration-files-to-the-sql-database">
          <title>Migrate domain-specific configuration files to the SQL database</title>
          <para>You can use the <literal>keystone-manage</literal> command to migrate configuration
                options in domain-specific configuration files to the SQL database:</para>
          <screen language="console"># keystone-manage domain_config_upload --all</screen>
          <para>To upload options from a specific domain-configuration file, specify the
                domain name:</para>
          <screen language="console"># keystone-manage domain_config_upload --domain-name DOMAIN_NAME</screen>
        </section>
      </section>
      <section xml:id="url-safe-naming-of-projects-and-domains" xml:base="identity-url-safe-naming">
        <title>URL safe naming of projects and domains</title>
        <para>In the future, keystone may offer the ability to identify a project in a
            hierarchy via a URL style of naming from the root of the hierarchy (for example
            specifying ‘projectA/projectB/projectC’ as the project name in an
            authentication request). In order to prepare for this, keystone supports the
            optional ability to ensure both projects and domains are named without
            including any of the reserved characters specified in section 2.2 of
            <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="http://tools.ietf.org/html/rfc3986">rfc3986</link>.</para>
        <para>The safety of the names of projects and domains can be controlled via two
            configuration options:</para>
        <screen language="ini">[resource]
project_name_url_safe = off
domain_name_url_safe = off</screen>
        <para>When set to <literal>off</literal> (which is the default), no checking is done on the URL
            safeness of names. When set to <literal>new</literal>, an attempt to create a new project or
            domain with an unsafe name (or update the name of a project or domain to be
            unsafe) will cause a status code of 400 (Bad Request) to be returned. Setting
            the configuration option to <literal>strict</literal> will, in addition to preventing the
            creation and updating of entities with unsafe names, cause an authentication
            attempt which specifies a project or domain name that is unsafe to return a
            status code of 401 (Unauthorized).</para>
        <para>We recommend that installations take the steps necessary to where they
            can run with both options set to <literal>strict</literal> as soon as is practical.</para>
      </section>
      <section xml:id="external-authentication-with-identity" xml:base="identity-external-authentication">
        <title>External authentication with Identity</title>
        <para>When Identity runs in <literal>apache-httpd</literal>, you can use external
            authentication methods that differ from the authentication provided by
            the identity store back end. For example, you can use an SQL identity
            back end together with X.509 authentication and Kerberos, instead of
            using the user name and password combination.</para>
        <section xml:id="use-httpd-authentication">
          <title>Use HTTPD authentication</title>
          <para>Web servers, like Apache HTTP, support many methods of authentication.
                Identity can allow the web server to perform the authentication. The web
                server then passes the authenticated user to Identity by using the
                <literal>REMOTE_USER</literal> environment variable. This user must already exist in
                the Identity back end to get a token from the controller. To use this
                method, Identity should run on <literal>apache-httpd</literal>.</para>
        </section>
        <section xml:id="use-x-509">
          <title>Use X.509</title>
          <para>The following Apache configuration snippet authenticates the user based
                on a valid X.509 certificate from a known CA:</para>
          <screen language="none">&lt;VirtualHost _default_:5000&gt;
    SSLEngine on
    SSLCertificateFile    /etc/ssl/certs/ssl.cert
    SSLCertificateKeyFile /etc/ssl/private/ssl.key

    SSLCACertificatePath /etc/ssl/allowed_cas
    SSLCARevocationPath  /etc/ssl/allowed_cas
    SSLUserName          SSL_CLIENT_S_DN_CN
    SSLVerifyClient      require
    SSLVerifyDepth       10

    (...)
&lt;/VirtualHost&gt;</screen>
        </section>
      </section>
      <section xml:id="integrate-identity-with-ldap" xml:base="identity-integrate-with-ldap">
        <title>Integrate Identity with LDAP</title>
        <para>The OpenStack Identity service supports integration with existing LDAP
            directories for authentication and authorization services. LDAP back
            ends require initialization before configuring the OpenStack Identity
            service to work with it. For more information, see <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://wiki.openstack.org/wiki/OpenLDAP">Setting up LDAP
                for use with Keystone</link>.</para>
        <para>When the OpenStack Identity service is configured to use LDAP back ends,
            you can split authentication (using the <emphasis>identity</emphasis> feature) and
            authorization (using the <emphasis>assignment</emphasis> feature). OpenStack Identity only
            supports read-only LDAP integration.</para>
        <para>The <emphasis>identity</emphasis> feature enables administrators to manage users and groups
            by each domain or the OpenStack Identity service entirely.</para>
        <para>The <emphasis>assignment</emphasis> feature enables administrators to manage project role
            authorization using the OpenStack Identity service SQL database, while
            providing user authentication through the LDAP directory.</para>
        <note>
          <para>It is possible to isolate identity related information to LDAP in a
                deployment and keep resource information in a separate datastore. It is not
                possible to do the opposite, where resource information is stored in LDAP
                and identity information is stored in SQL. If the resource or assignment
                back ends are integrated with LDAP, the identity back end must also be
                integrated with LDAP.</para>
        </note>
        <section xml:id="identity-ldap-server-setup">
          <title>Identity LDAP server set up</title>
          <important>
            <para>If you are using SELinux, then in order for the OpenStack Identity service to access LDAP servers,
                    you must enable the <literal>authlogin_nsswitch_use_ldap</literal> boolean value for
                    SELinux on the server running the OpenStack Identity service. To enable
                    and make the option persistent across reboots, set the following boolean
                    value as the root user:</para>
            <screen language="console"># setsebool -P authlogin_nsswitch_use_ldap on</screen>
          </important>
          <para>The Identity configuration is split into two separate back ends; identity
                (back end for users and groups), and assignments (back end for domains,
                projects, roles, role assignments). To configure Identity, set options
                in the <literal>/etc/keystone/keystone.conf</literal> file. See
                <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#integrate-identity-backend-ldap">Integrate Identity back end with LDAP</link> for Identity back end configuration
                examples. Modify these examples as needed.</para>
          <para>
            <emphasis role="bold">To define the destination LDAP server</emphasis>
          </para>
          <para>Define the destination LDAP server in the <literal>/etc/keystone/keystone.conf</literal> file:</para>
          <screen language="ini">[ldap]
url = ldap://localhost
user = dc=Manager,dc=example,dc=org
password = samplepassword
suffix = dc=example,dc=org</screen>
          <para>Multiple LDAP servers can be supplied to <literal>url</literal> to provide high-availability
                support for a single LDAP backend. To specify multiple LDAP servers, simply
                change the <literal>url</literal> option in the <literal>[ldap]</literal> section to be a list, separated by
                commas:</para>
          <screen language="ini">url = "ldap://localhost,ldap://backup.localhost"</screen>
          <para>
            <emphasis role="bold">Additional LDAP integration settings</emphasis>
          </para>
          <para>Set these options in the <literal>/etc/keystone/keystone.conf</literal> file for a
                single LDAP server, or <literal>/etc/keystone/domains/keystone.DOMAIN_NAME.conf</literal>
                files for multiple back ends. Example configurations appear below each
                setting summary:</para>
          <para>
            <emphasis role="bold">Query option</emphasis>
          </para>
          <itemizedlist>
            <listitem>
              <para>Use <literal>query_scope</literal> to control the scope level of data presented
                                (search only the first level or search an entire sub-tree)
                                through LDAP.</para>
            </listitem>
            <listitem>
              <para>Use <literal>page_size</literal> to control the maximum results per page. A value
                                of zero disables paging.</para>
            </listitem>
            <listitem>
              <para>Use <literal>alias_dereferencing</literal> to control the LDAP dereferencing
                                option for queries.</para>
            </listitem>
          </itemizedlist>
          <screen language="ini">[ldap]
query_scope = sub
page_size = 0
alias_dereferencing = default
chase_referrals =</screen>
          <para>
            <emphasis role="bold">Debug</emphasis>
          </para>
          <para>Use <literal>debug_level</literal> to set the LDAP debugging level for LDAP calls.
                A value of zero means that debugging is not enabled.</para>
          <screen language="ini">[ldap]
debug_level = 4095</screen>
          <para>This setting sets <literal>OPT_DEBUG_LEVEL</literal> in the underlying python library. This
                field is a bit mask (integer), and the possible flags are documented in the
                OpenLDAP manpages. Commonly used values include 255 and 4095, with 4095 being
                more verbose and 0 being disabled. We recommend consulting the documentation
                for your LDAP back end when using this option.</para>
          <warning>
            <para>Enabling <literal>debug_level</literal> will negatively impact performance.</para>
          </warning>
          <para>
            <emphasis role="bold">Connection pooling</emphasis>
          </para>
          <para>Various LDAP back ends use a common LDAP module to interact with LDAP data. By
                default, a new connection is established for each LDAP operation. This is
                expensive when TLS support is enabled, which is a likely configuration in an
                enterprise setup. Reusing connections from a connection pool drastically
                reduces overhead of initiating a new connection for every LDAP operation.</para>
          <para>Use <literal>use_pool</literal> to enable LDAP connection pooling. Configure the
                connection pool size, maximum retry, reconnect trials, timeout (-1
                indicates indefinite wait) and lifetime in seconds.</para>
          <screen language="ini">[ldap]
use_pool = true
pool_size = 10
pool_retry_max = 3
pool_retry_delay = 0.1
pool_connection_timeout = -1
pool_connection_lifetime = 600</screen>
          <para>
            <emphasis role="bold">Connection pooling for end user authentication</emphasis>
          </para>
          <para>LDAP user authentication is performed via an LDAP bind operation. In large
                deployments, user authentication can use up all available connections in a
                connection pool. OpenStack Identity provides a separate connection pool
                specifically for user authentication.</para>
          <para>Use <literal>use_auth_pool</literal> to enable LDAP connection pooling for end user
                authentication. Configure the connection pool size and lifetime in seconds.
                Both <literal>use_pool</literal> and <literal>use_auth_pool</literal> must be enabled to pool connections for
                user authentication.</para>
          <screen language="ini">[ldap]
use_auth_pool = false
auth_pool_size = 100
auth_pool_connection_lifetime = 60</screen>
          <para>When you have finished the configuration, restart the OpenStack Identity
                service.</para>
          <warning>
            <para>During the service restart, authentication and authorization are
                    unavailable.</para>
          </warning>
        </section>
        <section xml:id="integrate-identity-backend-ldap">
          <title>Integrate Identity back end with LDAP</title>
          <para>The Identity back end contains information for users, groups, and group
                member lists. Integrating the Identity back end with LDAP allows
                administrators to use users and groups in LDAP.</para>
          <important>
            <para>For OpenStack Identity service to access LDAP servers, you must
                    define the destination LDAP server in the
                    <literal>/etc/keystone/keystone.conf</literal> file. For more information,
                    see <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#identity-ldap-server-setup">Identity LDAP server set up</link>.</para>
          </important>
          <para>
            <emphasis role="bold">To integrate one Identity back end with LDAP</emphasis>
          </para>
          <procedure>
            <step>
              <para>Enable the LDAP Identity driver in the <literal>/etc/keystone/keystone.conf</literal>
                        file. This allows LDAP as an identity back end:</para>
              <screen language="ini">[identity]
#driver = sql
driver = ldap</screen>
            </step>
            <step>
              <para>Create the organizational units (OU) in the LDAP directory, and define
                        the corresponding location in the <literal>/etc/keystone/keystone.conf</literal>
                        file:</para>
              <screen language="ini">[ldap]
user_tree_dn = ou=Users,dc=example,dc=org
user_objectclass = inetOrgPerson

group_tree_dn = ou=Groups,dc=example,dc=org
group_objectclass = groupOfNames</screen>
              <note>
                <para>These schema attributes are extensible for compatibility with
                            various schemas. For example, this entry maps to the person
                            attribute in Active Directory:</para>
                <screen language="ini">user_objectclass = person</screen>
              </note>
              <para>Restart the OpenStack Identity service.</para>
              <warning>
                <para>During service restart, authentication and authorization are
                            unavailable.</para>
              </warning>
            </step>
          </procedure>
          <para>
            <emphasis role="bold">To integrate multiple Identity back ends with LDAP</emphasis>
          </para>
          <procedure>
            <step>
              <para>Set the following options in the <literal>/etc/keystone/keystone.conf</literal>
                        file:</para>
              <substeps>
                <step>
                  <para>Enable the LDAP driver:</para>
                  <screen language="ini">[identity]
#driver = sql
driver = ldap</screen>
                </step>
                <step>
                  <para>Enable domain-specific drivers:</para>
                  <screen language="ini">[identity]
domain_specific_drivers_enabled = True
domain_config_dir = /etc/keystone/domains</screen>
                </step>
              </substeps>
            </step>
            <step>
              <para>Restart the OpenStack Identity service.</para>
              <warning>
                <para>During service restart, authentication and authorization are
                            unavailable.</para>
              </warning>
            </step>
            <step>
              <para>List the domains using the dashboard, or the OpenStackClient CLI. Refer
                        to the <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://docs.openstack.org/developer/python-openstackclient/command-list.html">Command List</link>
                        for a list of OpenStackClient commands.</para>
            </step>
            <step>
              <para>Create domains using OpenStack dashboard, or the OpenStackClient CLI.</para>
            </step>
            <step>
              <para>For each domain, create a domain-specific configuration file in the
                        <literal>/etc/keystone/domains</literal> directory. Use the file naming convention
                        <literal>keystone.DOMAIN_NAME.conf</literal>, where <literal>DOMAIN_NAME</literal> is the domain name
                        assigned in the previous step.</para>
              <note>
                <para>The options set in the
                            <literal>/etc/keystone/domains/keystone.DOMAIN_NAME.conf</literal> file will
                            override options in the <literal>/etc/keystone/keystone.conf</literal> file.</para>
              </note>
            </step>
            <step>
              <para>Define the destination LDAP server in the
                        <literal>/etc/keystone/domains/keystone.DOMAIN_NAME.conf</literal> file. For example:</para>
              <screen language="ini">[ldap]
url = ldap://localhost
user = dc=Manager,dc=example,dc=org
password = samplepassword
suffix = dc=example,dc=org</screen>
            </step>
            <step>
              <para>Create the organizational units (OU) in the LDAP directories, and define
                        their corresponding locations in the
                        <literal>/etc/keystone/domains/keystone.DOMAIN_NAME.conf</literal> file. For example:</para>
              <screen language="ini">[ldap]
user_tree_dn = ou=Users,dc=example,dc=org
user_objectclass = inetOrgPerson

group_tree_dn = ou=Groups,dc=example,dc=org
group_objectclass = groupOfNames</screen>
              <note>
                <para>These schema attributes are extensible for compatibility with
                            various schemas. For example, this entry maps to the person
                            attribute in Active Directory:</para>
                <screen language="ini">user_objectclass = person</screen>
              </note>
            </step>
            <step>
              <para>Restart the OpenStack Identity service.</para>
              <warning>
                <para>During service restart, authentication and authorization are
                            unavailable.</para>
              </warning>
            </step>
          </procedure>
          <para>
            <emphasis role="bold">Additional LDAP integration settings</emphasis>
          </para>
          <para>Set these options in the <literal>/etc/keystone/keystone.conf</literal> file for a
                single LDAP server, or <literal>/etc/keystone/domains/keystone.DOMAIN_NAME.conf</literal>
                files for multiple back ends. Example configurations appear below each
                setting summary:</para>
          <variablelist>
            <varlistentry>
              <term>Filters</term>
              <listitem>
                <para>Use filters to control the scope of data presented through LDAP.</para>
                <screen language="ini">[ldap]
user_filter = (memberof=cn=openstack-users,ou=workgroups,dc=example,dc=org)
group_filter =</screen>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Identity attribute mapping</term>
              <listitem>
                <para>Mask account status values (include any additional attribute
                            mappings) for compatibility with various directory services.
                            Superfluous accounts are filtered with <literal>user_filter</literal>.</para>
                <para>Setting attribute ignore to list of attributes stripped off on
                            update.</para>
                <para>For example, you can mask Active Directory account status attributes
                            in the <literal>/etc/keystone/keystone.conf</literal> file:</para>
                <screen language="ini">[ldap]
user_id_attribute      = cn
user_name_attribute    = sn
user_mail_attribute    = mail
user_pass_attribute    = userPassword
user_enabled_attribute = userAccountControl
user_enabled_mask      = 2
user_enabled_invert    = false
user_enabled_default   = 512
user_default_project_id_attribute =
user_additional_attribute_mapping =

group_id_attribute     = cn
group_name_attribute   = ou
group_member_attribute = member
group_desc_attribute   = description
group_additional_attribute_mapping =</screen>
                <para>It is possible to model more complex LDAP schemas. For example, in the user
                            object, the objectClass posixAccount from <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://tools.ietf.org/html/rfc2307">RFC2307</link>
                            is very common. If this is the underlying objectClass, then the <literal>uid</literal>
                            field should probably be <literal>uidNumber</literal> and the <literal>username</literal> field should be
                            either <literal>uid</literal> or <literal>cn</literal>. The following illustrates the configuration:</para>
                <screen language="ini">[ldap]
user_id_attribute = uidNumber
user_name_attribute = cn</screen>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Enabled emulation</term>
              <listitem>
                <para>OpenStack Identity supports emulation for integrating with LDAP servers that
                            do not provide an <literal>enabled</literal> attribute for users. This allows OpenStack
                            Identity to advertise <literal>enabled</literal> attributes when the user entity in LDAP
                            does not. The <literal>user_enabled_emulation</literal> option must be enabled and the
                            <literal>user_enabled_emulation_dn</literal> option must be a valid LDAP group. Users in
                            the group specified by <literal>user_enabled_emulation_dn</literal> will be marked as
                            <literal>enabled</literal>. For example, the following will mark any user who is a member
                            of the <literal>enabled_users</literal> group as enabled:</para>
                <screen language="ini">[ldap]
user_enabled_emulation = True
user_enabled_emulation_dn = cn=enabled_users,cn=groups,dc=openstack,dc=org</screen>
                <para>If the directory server has an enabled attribute, but it is not a boolean
                            type, a mask can be used to convert it. This is useful when the enabled
                            attribute is an integer value. The following configuration highlights the
                            usage:</para>
                <screen language="ini">[ldap]
user_enabled_attribute = userAccountControl
user_enabled_mask = 2
user_enabled_default = 512</screen>
                <para>In this case, the attribute is an integer and the enabled attribute is
                            listed in bit 1. If the mask configured <literal>user_enabled_mask</literal> is different
                            from 0, it retrieves the attribute from <literal>user_enabled_attribute</literal> and
                            performs an add operation with the <literal>user_enabled_mask</literal>. If the sum of the
                            operation matches the mask, then the account is disabled.</para>
                <para>The value of <literal>user_enabled_attribute</literal> is also saved before applying the
                            add operation in <literal>enabled_nomask</literal>. This is done in case the user needs to
                            be enabled or disabled. Lastly, setting <literal>user_enabled_default</literal> is needed
                            in order to create a default value on the integer attribute (512 = NORMAL
                            ACCOUNT in Active Directory).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>When you have finished configuration, restart the OpenStack Identity
                service.</para>
          <warning>
            <para>During service restart, authentication and authorization are
                    unavailable.</para>
          </warning>
        </section>
        <section xml:id="secure-the-openstack-identity-service-connection-to-an-ldap-back-end">
          <title>Secure the OpenStack Identity service connection to an LDAP back end</title>
          <para>We recommend securing all connections between OpenStack Identity and LDAP. The
                Identity service supports the use of TLS to encrypt LDAP traffic. Before
                configuring this, you must first verify where your certificate authority file
                is located. For more information, see the <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://docs.openstack.org/security-guide/secure-communication/introduction-to-ssl-and-tls.html">OpenStack Security Guide SSL
                    introduction</link>.</para>
          <para>Once you verify the location of your certificate authority file:</para>
          <para>
            <emphasis role="bold">To configure TLS encryption on LDAP traffic</emphasis>
          </para>
          <procedure>
            <step>
              <para>Open the <literal>/etc/keystone/keystone.conf</literal> configuration file.</para>
            </step>
            <step>
              <para>Find the <literal>[ldap]</literal> section.</para>
            </step>
            <step>
              <para>In the <literal>[ldap]</literal> section, set the <literal>use_tls</literal> configuration key to
                        <literal>True</literal>. Doing so will enable TLS.</para>
            </step>
            <step>
              <para>Configure the Identity service to use your certificate authorities file.
                        To do so, set the <literal>tls_cacertfile</literal> configuration key in the <literal>ldap</literal>
                        section to the certificate authorities file’s path.</para>
              <note>
                <para>You can also set the <literal>tls_cacertdir</literal> (also in the <literal>ldap</literal>
                            section) to the directory where all certificate authorities files
                            are kept. If both <literal>tls_cacertfile</literal> and <literal>tls_cacertdir</literal> are set,
                            then the latter will be ignored.</para>
              </note>
            </step>
            <step>
              <para>Specify what client certificate checks to perform on incoming TLS
                        sessions from the LDAP server. To do so, set the <literal>tls_req_cert</literal>
                        configuration key in the <literal>[ldap]</literal> section to <literal>demand</literal>, <literal>allow</literal>, or
                        <literal>never</literal>:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>demand</literal> - The LDAP server always receives certificate
                                        requests. The session terminates if no certificate
                                        is provided, or if the certificate provided cannot be verified
                                        against the existing certificate authorities file.</para>
                </listitem>
                <listitem>
                  <para><literal>allow</literal> - The LDAP server always receives certificate
                                        requests. The session will proceed as normal even if a certificate
                                        is not provided. If a certificate is provided but it cannot be
                                        verified against the existing certificate authorities file, the
                                        certificate will be ignored and the session will proceed as
                                        normal.</para>
                </listitem>
                <listitem>
                  <para><literal>never</literal> - A certificate will never be requested.</para>
                </listitem>
              </itemizedlist>
            </step>
          </procedure>
          <para>When you have finished configuration, restart the OpenStack Identity
                service.</para>
          <note>
            <para>If you are unable to connect to LDAP via OpenStack Identity, or observe a
                    <emphasis>SERVER DOWN</emphasis> error, set the <literal>TLS_CACERT</literal> in <literal>/etc/ldap/ldap.conf</literal> to
                    the same value specified in the <literal>[ldap] tls_certificate</literal> section of
                    <literal>keystone.conf</literal>.</para>
          </note>
          <para>On distributions that include openstack-config, you can configure TLS
                encryption on LDAP traffic by running the following commands instead.</para>
          <screen language="console"># openstack-config --set /etc/keystone/keystone.conf \
  ldap use_tls True
# openstack-config --set /etc/keystone/keystone.conf \
  ldap tls_cacertfile ``CA_FILE``
# openstack-config --set /etc/keystone/keystone.conf \
  ldap tls_req_cert ``CERT_BEHAVIOR``</screen>
          <para>Where:</para>
          <itemizedlist>
            <listitem>
              <para><literal>CA_FILE</literal> is the absolute path to the certificate authorities file
                        that should be used to encrypt LDAP traffic.</para>
            </listitem>
            <listitem>
              <para><literal>CERT_BEHAVIOR</literal> specifies what client certificate checks to perform
                        on an incoming TLS session from the LDAP server (<literal>demand</literal>,
                        <literal>allow</literal>, or <literal>never</literal>).</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
      <section xml:id="upgrading-keystone" xml:base="identity-upgrading">
        <title>Upgrading Keystone</title>
        <para>As of the Newton release, keystone supports two different approaches to
            upgrading across releases. The traditional approach requires a significant
            outage to be scheduled for the entire duration of the upgrade process. The more
            modern approach results in zero downtime, but is more complicated due to a
            longer upgrade procedure.</para>
        <note>
          <para>The details of these steps are entirely dependent on the details of your
                specific deployment, such as your chosen application server and database
                management system. Use it only as a guide when implementing your own
                upgrade process.</para>
        </note>
        <section xml:id="before-you-begin">
          <title>Before you begin</title>
          <para>Plan your upgrade:</para>
          <itemizedlist>
            <listitem>
              <para>Read and ensure you understand the <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://docs.openstack.org/releasenotes/keystone/">release notes</link> for the next release.</para>
            </listitem>
            <listitem>
              <para>Resolve any outstanding deprecation warnings in your logs. Some deprecation
                        cycles are as short as a single release, so it’s possible to break a
                        deployment if you leave <emphasis>any</emphasis> outstanding warnings. It might be a good idea
                        to re-read the release notes for the previous release (or two!).</para>
            </listitem>
            <listitem>
              <para>Prepare your new configuration files, including <literal>keystone.conf</literal>,
                        <literal>logging.conf</literal>, <literal>policy.json</literal>, <literal>keystone-paste.ini</literal>, and anything else
                        in <literal>/etc/keystone/</literal>, by customizing the corresponding files from the next
                        release.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section xml:id="upgrading-with-downtime">
          <title>Upgrading with downtime</title>
          <para>This is a high-level description of our upgrade strategy built around
                <literal>keystone-manage db_sync</literal>. It assumes that you are willing to have downtime
                of your control plane during the upgrade process and presents minimal risk.
                With keystone unavailable, no other OpenStack services will be able to
                authenticate requests, effectively preventing the rest of the control plane
                from functioning normally.</para>
          <procedure>
            <step>
              <para>Stop all keystone processes. Otherwise, you’ll risk multiple releases of
                        keystone trying to write to the database at the same time, which may result
                        in data being inconsistently written and read.</para>
            </step>
            <step>
              <para>Make a backup of your database. Keystone does not support downgrading the
                        database, so restoring from a full backup is your only option for recovery
                        in the event of an upgrade failure.</para>
            </step>
            <step>
              <para>Upgrade all keystone nodes to the next release.</para>
            </step>
            <step>
              <para>Update your configuration files (<literal>/etc/keystone/</literal>) with those
                        corresponding from the latest release.</para>
            </step>
            <step>
              <para>Run <literal>keystone-manage db_sync</literal> from any single node to upgrade both the
                        database schema and run any corresponding database migrations.</para>
            </step>
            <step>
              <para>(<emphasis>New in Newton</emphasis>) Run <literal>keystone-manage doctor</literal> to diagnose symptoms of
                        common deployment issues and receive instructions for resolving them.</para>
            </step>
            <step>
              <para>Start all keystone processes.</para>
            </step>
          </procedure>
        </section>
        <section xml:id="upgrading-with-minimal-downtime">
          <title>Upgrading with minimal downtime</title>
          <para>If you run a multi-node keystone cluster that uses a replicated database, like
                a Galera cluster, it is possible to upgrade with minimal downtime. This method
                also optimizes recovery time from a failed upgrade. This section assumes
                familiarity with the base case (<xref linkend="upgrading-with-downtime"/>) outlined above.
                In these steps the nodes will be divided into <literal>first</literal> and <literal>other</literal> nodes.</para>
          <procedure>
            <step>
              <para>Backup your database. There is no way to rollback the upgrade of keystone
                        and this is your worst-case fallback option.</para>
            </step>
            <step>
              <para>Disable keystone on all nodes but the <literal>first</literal> node. This can be done via a
                        variety of mechanisms that will depend on the deployment. If you are unable
                        to disable a service or place a service into maintenance mode in your load
                        balancer, you can stop the keystone processes.</para>
            </step>
            <step>
              <para>Stop the database service on one of the <literal>other</literal> nodes in the cluster. This
                        will isolate the old dataset on a single node in the cluster. In the event
                        of a failed update this data can be used to rebuild the cluster without
                        having to restore from backup.</para>
            </step>
            <step>
              <para>Update the configuration files on the <literal>first</literal> node.</para>
            </step>
            <step>
              <para>Upgrade keystone on the <literal>first</literal> node. keystone is now down for your cloud.</para>
            </step>
            <step>
              <para>Run <literal>keystone-manage db_sync</literal> on the <literal>first</literal> node. As soon as this
                        finishes, keystone is now working again on a single node in the cluster.</para>
            </step>
            <step>
              <para>keystone is now upgraded on a single node. Your load balancers will be
                        sending all traffic to this single node. This is your chance to run
                        ensure keystone up and running, and not broken. If keystone is broken, see
                        the <xref linkend="rollback-after-a-failed-upgrade"/> section below.</para>
            </step>
            <step>
              <para>Once you have verified that keystone is up and running, begin the upgrade on
                        the <literal>other</literal> nodes. This entails updating configuration files and upgrading
                        the code. The <literal>db_sync</literal> does not need to be run again.</para>
            </step>
            <step>
              <para>On the node where you stopped the database service, be sure to restart
                        it and ensure that it properly rejoins the cluster.</para>
            </step>
          </procedure>
          <para>Using this model, the outage window is minimized because the only time
                when your cluster is totally offline is between loading the newer version
                of keystone and running the <literal>db_sync</literal> command. Typically the outage with
                this method can be measured in tens of seconds especially if automation is
                used.</para>
          <section xml:id="rollback-after-a-failed-upgrade">
            <title>Rollback after a failed upgrade</title>
            <para>If the upgrade fails, only a single node has been affected. This makes the
                    recovery simpler and quicker. If issues are not discovered until the entire
                    cluster is upgraded, a full shutdown and restore from backup will be required.
                    That will take much longer than just fixing a single node with an old copy of
                    the database still available. This process will be dependent on your
                    architecture and it is highly recommended that you’ve practiced this in a
                    development environment before trying to use it for the first time.</para>
            <procedure>
              <step>
                <para>Isolate the bad node. Shutdown keystone and the database services
                            on the upgraded “bad” node.</para>
              </step>
              <step>
                <para>Bootstrap the database cluster from the node holding the old data.
                            This may require wiping the data first on any nodes who are not
                            holding old data.</para>
              </step>
              <step>
                <para>Enable keystone on the old nodes in your load balancer or if
                            the processes were stopped, restart them.</para>
              </step>
              <step>
                <para>Validate that keystone is working.</para>
              </step>
              <step>
                <para>Downgrade the code and config files on the bad node.</para>
              </step>
            </procedure>
            <para>This process should be doable in a matter of minutes and will minimize cloud
                    downtime if it is required.</para>
          </section>
        </section>
        <section xml:id="upgrading-without-downtime">
          <title>Upgrading without downtime</title>
          <para>This is a high-level description of our upgrade strategy built around
                additional options in <literal>keystone-manage db_sync</literal>. Although it is much more
                complex than the upgrade process described above, it assumes that you are not
                willing to have downtime of your control plane during the upgrade process. With
                this upgrade process, end users will still be able to authenticate to receive
                tokens normally, and other OpenStack services will still be able to
                authenticate requests normally.</para>
          <procedure>
            <step>
              <para>Make a backup of your database. keystone does not support downgrading the
                        database, so restoring from a full backup is your only option for recovery
                        in the event of an upgrade failure.</para>
            </step>
            <step>
              <para>Stop the keystone processes on the first node (or really, any arbitrary
                        node). This node will serve to orchestrate database upgrades.</para>
            </step>
            <step>
              <para>Upgrade your first node to the next release, but do not start any keystone
                        processes.</para>
            </step>
            <step>
              <para>Update your configuration files on the first node (<literal>/etc/keystone/</literal>) with
                        those corresponding to the latest release.</para>
            </step>
            <step>
              <para>(<emphasis>New in Newton</emphasis>) Run <literal>keystone-manage doctor</literal> on the first node to
                        diagnose symptoms of common deployment issues and receive instructions for
                        resolving them.</para>
            </step>
            <step>
              <para>(<emphasis>New in Newton</emphasis>) Run <literal>keystone-manage db_sync --expand</literal> on the first node
                        to expand the database schema to a superset of what both the previous and
                        next release can utilize, and create triggers to facilitate the live
                        migration process.</para>
              <warning>
                <para>For MySQL, using the <literal>keystone-manage db_sync --expand</literal> command requires
                            that you either grant your keystone user <literal>SUPER</literal> privileges, or run
                            <literal>set global log_bin_trust_function_creators=1;</literal> in mysql beforehand.</para>
              </warning>
              <para>At this point, new columns and tables may exist in the database, but will
                        <emphasis>not</emphasis> all be populated in such a way that the next release will be able to
                        function normally.</para>
              <para>As the previous release continues to write to the old schema, database
                        triggers will live migrate the data to the new schema so it can be read by
                        the next release.</para>
            </step>
            <step>
              <para>(<emphasis>New in Newton</emphasis>) Run <literal>keystone-manage db_sync --migrate</literal> on the first
                        node to forcefully perform data migrations. This process will migrate all
                        data from the old schema to the new schema while the previous release
                        continues to operate normally.</para>
              <para>When this process completes, all data will be available in both the new
                        schema and the old schema, so both the previous release and the next release
                        will be capable of operating normally.</para>
            </step>
            <step>
              <para>Update your configuration files (<literal>/etc/keystone/</literal>) on all nodes (except
                        the first node, which you’ve already done) with those corresponding to the
                        latest release.</para>
            </step>
            <step>
              <para>Upgrade all keystone nodes to the next release, and restart them one at a
                        time. During this step, you’ll have a mix of releases operating side by
                        side, both writing to the database.</para>
              <para>As the next release begins writing to the new schema, database triggers will
                        also migrate the data to the old schema, keeping both data schemas in sync.</para>
            </step>
            <step>
              <para>(<emphasis>New in Newton</emphasis>) Run <literal>keystone-manage db_sync --contract</literal> to remove the
                        old schema and all data migration triggers.</para>
              <para>When this process completes, the database will no longer be able to support
                        the previous release.</para>
            </step>
          </procedure>
          <section xml:id="using-db-sync-check">
            <title>Using db_sync check</title>
            <para>(<emphasis>New in Pike</emphasis>) In order to check the current state of your rolling upgrades,
                    you may run the command <literal>keystone-manage db_sync --check</literal>. This will inform
                    you of any outstanding actions you have left to take as well as any possible
                    upgrades you can make from your current version. Here are a list of possible
                    return codes.</para>
            <itemizedlist>
              <listitem>
                <para>A return code of <literal>0</literal> means you are currently up to date with the latest
                            migration script version and all <literal>db_sync</literal> commands are complete.</para>
              </listitem>
              <listitem>
                <para>A return code of <literal>1</literal> generally means something serious is wrong with your
                            database and operator intervention will be required.</para>
              </listitem>
              <listitem>
                <para>A return code of <literal>2</literal> means that an upgrade from your current database
                            version is available, your database is not currently under version control,
                            or the database is already under control. Your first step is to run
                            <literal>keystone-manage db_sync --expand</literal>.</para>
              </listitem>
              <listitem>
                <para>A return code of <literal>3</literal> means that the expansion stage is complete, and the
                            next step is to run <literal>keystone-manage db_sync --migrate</literal>.</para>
              </listitem>
              <listitem>
                <para>A return code of <literal>4</literal> means that the expansion and data migration stages are
                            complete, and the next step is to run <literal>keystone-manage db_sync --contract</literal>.</para>
              </listitem>
            </itemizedlist>
          </section>
        </section>
      </section>
      <section xml:id="keystone-tokens" xml:base="identity-tokens">
        <title>Keystone tokens</title>
        <para>Tokens are used to authenticate and authorize your interactions with the
            various OpenStack APIs. Tokens come in many flavors, representing various
            authorization scopes and sources of identity. There are also several different
            “token providers”, each with their own user experience, performance, and
            deployment characteristics.</para>
        <section xml:id="authorization-scopes">
          <title>Authorization scopes</title>
          <para>Tokens can express your authorization in different scopes. You likely have
                different sets of roles, in different projects, and in different domains.
                While tokens always express your identity, they may only ever express one set
                of roles in one authorization scope at a time.</para>
          <para>Each level of authorization scope is useful for certain types of operations in
                certain OpenStack services, and are not interchangeable.</para>
          <section xml:id="unscoped-tokens">
            <title>Unscoped tokens</title>
            <para>An unscoped token contains neither a service catalog, any roles, a project
                    scope, nor a domain scope. Their primary use case is simply to prove your
                    identity to keystone at a later time (usually to generate scoped tokens),
                    without repeatedly presenting your original credentials.</para>
            <para>The following conditions must be met to receive an unscoped token:</para>
            <itemizedlist>
              <listitem>
                <para>You must not specify an authorization scope in your authentication request
                            (for example, on the command line with arguments such as
                            <literal>--os-project-name</literal> or <literal>--os-domain-id</literal>).</para>
              </listitem>
              <listitem>
                <para>Your identity must not have a “default project” associated with it that you
                            also have role assignments, and thus authorization, upon.</para>
              </listitem>
            </itemizedlist>
          </section>
          <section xml:id="project-scoped-tokens">
            <title>Project-scoped tokens</title>
            <para>Project-scoped tokens are the bread and butter of OpenStack. They express your
                    authorization to operate in a specific tenancy of the cloud and are useful to
                    authenticate yourself when working with most other services.</para>
            <para>They contain a service catalog, a set of roles, and details of the project upon
                    which you have authorization.</para>
          </section>
          <section xml:id="domain-scoped-tokens">
            <title>Domain-scoped tokens</title>
            <para>Domain-scoped tokens also have limited use cases in OpenStack. They express
                    your authorization to operate a domain-level, above that of the user and
                    projects contained therein (typically as a domain-level administrator).
                    Depending on Keystone’s configuration, they are useful for working with a
                    single domain in Keystone.</para>
            <para>They contain a limited service catalog (only those services which do not
                    explicitly require per-project endpoints), a set of roles, and details of the
                    project upon which you have authorization.</para>
            <para>They can also be used to work with domain-level concerns in other services,
                    such as to configure domain-wide quotas that apply to all users or projects in
                    a specific domain.</para>
          </section>
        </section>
        <section xml:id="token-providers">
          <title>Token providers</title>
          <para>The token type issued by keystone is configurable through the
                <literal>/etc/keystone/keystone.conf</literal> file. Currently, there are two supported
                token types, <literal>UUID</literal> and <literal>fernet</literal>.</para>
          <section xml:id="uuid-tokens">
            <title>UUID tokens</title>
            <para>UUID was the first token type supported and is currently the default token
                    provider. UUID tokens are 32 bytes in length and must be persisted in a back
                    end. Clients must pass their UUID token to the Identity service in order to
                    validate it.</para>
            <para>As mentioned above, UUID tokens must be persisted. By default, keystone
                    persists UUID tokens using a SQL backend. An unfortunate side-effect is that
                    the size of the database will grow over time regardless of the token’s
                    expiration time. Expired UUID tokens can be pruned from the backend using
                    keystone’s command line utility:</para>
            <screen language="bash">$ keystone-manage token_flush</screen>
            <para>We recommend invoking this command periodically using <literal>cron</literal>.</para>
            <note>
              <para>It is not required to run this command at all if using Fernet tokens. Fernet
                        tokens are not persisted and do not contribute to database bloat.</para>
            </note>
          </section>
          <section xml:id="fernet-tokens">
            <title>Fernet tokens</title>
            <para>The fernet token format was introduced in the OpenStack Kilo release. Unlike
                    the other token types mentioned in this document, fernet tokens do not need to
                    be persisted in a back end. <literal>AES256</literal> encryption is used to protect the
                    information stored in the token and integrity is verified with a <literal>SHA256
HMAC</literal> signature. Only the Identity service should have access to the keys used
                    to encrypt and decrypt fernet tokens. Like UUID tokens, fernet tokens must be
                    passed back to the Identity service in order to validate them. For more
                    information on the fernet token type, see the <xref linkend="fernet-frequently-asked-questions"/>.</para>
            <informaltable>
              <tgroup cols="4">
                <colspec colname="c0" colwidth="1"/>
                <colspec colname="c1" colwidth="1"/>
                <colspec colname="c2" colwidth="1"/>
                <colspec colname="c3" colwidth="1"/>
                <thead>
                  <row>
                    <entry>
                      <para>
                        <emphasis>Feature</emphasis>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <emphasis>Status</emphasis>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <emphasis role="bold">Fernet tokens</emphasis>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <emphasis role="bold">UUID tokens</emphasis>
                      </para>
                    </entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_unscoped_token">
                          <emphasis role="bold">Create unscoped token</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>mandatory</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_unscoped_token_fernet">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_unscoped_token_uuid">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_project_scoped_token">
                          <emphasis role="bold">Create project-scoped token</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>mandatory</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_project_scoped_token_fernet">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_project_scoped_token_uuid">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_domain_scoped_token">
                          <emphasis role="bold">Create domain-scoped token</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>optional</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_domain_scoped_token_fernet">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_domain_scoped_token_uuid">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_trust_scoped_token">
                          <emphasis role="bold">Create trust-scoped token</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>optional</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_trust_scoped_token_fernet">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_trust_scoped_token_uuid">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_token_using_oauth">
                          <emphasis role="bold">Create a token given an OAuth access token</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>optional</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_token_using_oauth_fernet">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_token_using_oauth_uuid">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_token_with_bind">
                          <emphasis role="bold">Create a token with a bind attribute</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>optional</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_token_with_bind_fernet">
                          <literal>✖</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_create_token_with_bind_uuid">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_revoke_token">
                          <emphasis role="bold">Revoke a token</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>optional</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_revoke_token_fernet">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#operation_revoke_token_uuid">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#feature_online_validation">
                          <emphasis role="bold">Online validation</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>mandatory</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#feature_online_validation_fernet">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#feature_online_validation_uuid">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#feature_offline_validation">
                          <emphasis role="bold">Offline validation</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>optional</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#feature_offline_validation_fernet">
                          <literal>✖</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#feature_offline_validation_uuid">
                          <literal>✖</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#feature_non_persistent">
                          <emphasis role="bold">Non-persistent</emphasis>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>optional</para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#feature_non_persistent_fernet">
                          <literal>✔</literal>
                        </link>
                      </para>
                    </entry>
                    <entry>
                      <para>
                        <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="#feature_non_persistent_uuid">
                          <literal>✖</literal>
                        </link>
                      </para>
                    </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
            <itemizedlist>
              <listitem>
                <para>
                  <emphasis role="bold">Create unscoped token</emphasis>
                </para>
                <para><emphasis role="bold">Status: mandatory. </emphasis>All token providers must be capable of issuing tokens without an explicit
                                scope of authorization.</para>
                <para>
                  <emphasis role="bold">CLI commands:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <screen>openstack --os-username=&lt;username&gt; --os-user-domain-name=&lt;domain&gt;
--os-password=&lt;password&gt; token issue</screen>
                  </listitem>
                </itemizedlist>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">Create project-scoped token</emphasis>
                </para>
                <para><emphasis role="bold">Status: mandatory. </emphasis>All token providers must be capable of issuing project-scoped tokens.</para>
                <para>
                  <emphasis role="bold">CLI commands:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <screen>openstack --os-username=&lt;username&gt; --os-user-domain-name=&lt;domain&gt;
--os-password=&lt;password&gt; --os-project-name=&lt;project&gt;
--os-project-domain-name=&lt;domain&gt; token issue</screen>
                  </listitem>
                </itemizedlist>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">Create domain-scoped token</emphasis>
                </para>
                <para><emphasis role="bold">Status: optional. </emphasis>Domain-scoped tokens are not required for all use cases, and for some use
                                cases, projects can be used instead.</para>
                <para>
                  <emphasis role="bold">CLI commands:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <screen>openstack --os-username=&lt;username&gt; --os-user-domain-name=&lt;domain&gt;
--os-password=&lt;password&gt; --os-domain-name=&lt;domain&gt; token issue</screen>
                  </listitem>
                </itemizedlist>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">Create trust-scoped token</emphasis>
                </para>
                <para><emphasis role="bold">Status: optional. </emphasis>Tokens scoped to a trust convey only the user impersonation and
                                project-based authorization attributes included in the delegation.</para>
                <para>
                  <emphasis role="bold">CLI commands:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <screen>openstack --os-username=&lt;username&gt; --os-user-domain-name=&lt;domain&gt;
--os-password=&lt;password&gt; --os-trust-id=&lt;trust&gt; token issue</screen>
                  </listitem>
                </itemizedlist>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">Create a token given an OAuth access token</emphasis>
                </para>
                <para><emphasis role="bold">Status: optional. </emphasis>OAuth access tokens can be exchanged for keystone tokens.</para>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">Create a token with a bind attribute</emphasis>
                </para>
                <para><emphasis role="bold">Status: optional. </emphasis>Tokens can express a binding to an additional authentication method, such
                                as kerberos or x509.</para>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>missing</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">Revoke a token</emphasis>
                </para>
                <para><emphasis role="bold">Status: optional. </emphasis>Tokens may be individually revoked, such as when a user logs out of
                                Horizon. Under certain circumstances, it’s acceptable for more than just a
                                single token may be revoked as a result of this operation (such as when the
                                revoked token was previously used to create additional tokens).</para>
                <para>
                  <emphasis role="bold">CLI commands:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <screen>openstack token revoke</screen>
                  </listitem>
                </itemizedlist>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">Online validation</emphasis>
                </para>
                <para><emphasis role="bold">Status: mandatory. </emphasis>Keystone must be able to validate the tokens that it issues when
                                presented with a token that it previously issued.</para>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">Offline validation</emphasis>
                </para>
                <para><emphasis role="bold">Status: optional. </emphasis>Services using Keystone for authentication may want to validate tokens
                                themselves, rather than calling back to keystone, in order to improve
                                performance and scalability.</para>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>missing</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>missing</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">Non-persistent</emphasis>
                </para>
                <para><emphasis role="bold">Status: optional. </emphasis>If a token format does not require persistence (such as to a SQL
                                backend), then there is no scalability limit to the number of tokens that
                                keystone can issue at once, and there is no need to perform clean up
                                operations such as `keystone-manage token_flush`.</para>
                <para>
                  <emphasis role="bold">drivers:</emphasis>
                </para>
                <itemizedlist>
                  <listitem>
                    <para>
                      <emphasis role="bold">UUID tokens: </emphasis>
                    </para>
                    <para>
                      <literal>missing</literal>
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="bold">Fernet tokens: </emphasis>
                    </para>
                    <para>
                      <literal>complete</literal>
                    </para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
          </section>
        </section>
      </section>
      <section xml:id="configure-identity-service-for-token-binding" xml:base="identity-token-binding">
        <title>Configure Identity service for token binding</title>
        <para>Token binding embeds information from an external authentication
            mechanism, such as a Kerberos server or X.509 certificate, inside a
            token. By using token binding, a client can enforce the use of a
            specified external authentication mechanism with the token. This
            additional security mechanism ensures that if a token is stolen, for
            example, it is not usable without external authentication.</para>
        <para>You configure the authentication types for a token binding in the
            <literal>/etc/keystone/keystone.conf</literal> file:</para>
        <screen language="ini">[token]
bind = kerberos</screen>
        <para>or</para>
        <screen language="ini">[token]
bind = x509</screen>
        <para>Currently <literal>kerberos</literal> and <literal>x509</literal> are supported.</para>
        <para>To enforce checking of token binding, set the <literal>enforce_token_bind</literal>
            option to one of these modes:</para>
        <itemizedlist>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>disabled</literal>
                </term>
                <listitem>
                  <para>Disables token bind checking.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>permissive</literal>
                </term>
                <listitem>
                  <para>Enables bind checking. If a token is bound to an unknown
                                authentication mechanism, the server ignores it. The default is this
                                mode.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>strict</literal>
                </term>
                <listitem>
                  <para>Enables bind checking. If a token is bound to an unknown
                                authentication mechanism, the server rejects it.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>required</literal>
                </term>
                <listitem>
                  <para>Enables bind checking. Requires use of at least authentication
                                mechanism for tokens.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>kerberos</literal>
                </term>
                <listitem>
                  <para>Enables bind checking. Requires use of kerberos as the authentication
                                mechanism for tokens:</para>
                  <screen language="ini">[token]
enforce_token_bind = kerberos</screen>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
          <listitem>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>x509</literal>
                </term>
                <listitem>
                  <para>Enables bind checking. Requires use of X.509 as the authentication
                                mechanism for tokens:</para>
                  <screen language="ini">[token]
enforce_token_bind = x509</screen>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </itemizedlist>
      </section>
      <section xml:id="fernet-frequently-asked-questions">
        <title>Fernet - Frequently Asked Questions</title>
        <para>The following questions have been asked periodically since the initial release
            of the fernet token format in Kilo.</para>
        <section xml:id="what-is-a-fernet-token">
          <title>What is a fernet token?</title>
          <para>A fernet token is a bearer token that represents user authentication. Fernet
                tokens contain a limited amount of identity and authorization data in a
                <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="http://msgpack.org/">MessagePacked</link> payload. The payload is then wrapped as
                a <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://github.com/fernet/spec">Fernet</link> message for transport, where
                Fernet provides the required web safe characteristics for use in URLs and
                headers. The data inside a fernet token is protected using symmetric encryption
                keys, or fernet keys.</para>
        </section>
        <section xml:id="what-is-a-fernet-key">
          <title>What is a fernet key?</title>
          <para>A fernet key is used to encrypt and decrypt fernet tokens. Each key is actually
                composed of two smaller keys: a 128-bit AES encryption key and a 128-bit SHA256
                HMAC signing key. The keys are held in a key repository that keystone passes to
                a library that handles the encryption and decryption of tokens.</para>
        </section>
        <section xml:id="what-are-the-different-types-of-keys">
          <title>What are the different types of keys?</title>
          <para>A key repository is required by keystone in order to create fernet tokens.
                These keys are used to encrypt and decrypt the information that makes up the
                payload of the token. Each key in the repository can have one of three states.
                The state of the key determines how keystone uses a key with fernet tokens. The
                different types are as follows:</para>
          <variablelist>
            <varlistentry>
              <term>Primary key:</term>
              <listitem>
                <para>There is only ever one primary key in a key repository. The primary key is
                            allowed to encrypt and decrypt tokens. This key is always named as the
                            highest index in the repository.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Secondary key:</term>
              <listitem>
                <para>A secondary key was at one point a primary key, but has been demoted in place
                            of another primary key. It is only allowed to decrypt tokens. Since it was
                            the primary at some point in time, its existence in the key repository is
                            justified. Keystone needs to be able to decrypt tokens that were created with
                            old primary keys.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Staged key:</term>
              <listitem>
                <para>The staged key is a special key that shares some similarities with secondary
                            keys. There can only ever be one staged key in a repository and it must
                            exist. Just like secondary keys, staged keys have the ability to decrypt
                            tokens. Unlike secondary keys, staged keys have never been a primary key. In
                            fact, they are opposites since the staged key will always be the next primary
                            key. This helps clarify the name because they are the next key staged to be
                            the primary key. This key is always named as <literal>0</literal> in the key repository.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section xml:id="so-how-does-a-staged-key-help-me-and-why-do-i-care-about-it">
          <title>So, how does a staged key help me and why do I care about it?</title>
          <para>The fernet keys have a natural lifecycle. Each key starts as a staged key, is
                promoted to be the primary key, and then demoted to be a secondary key. New
                tokens can only be encrypted with a primary key. Secondary and staged keys are
                never used to encrypt token. The staged key is a special key given the order of
                events and the attributes of each type of key. The staged key is the only key
                in the repository that has not had a chance to encrypt any tokens yet, but it
                is still allowed to decrypt tokens. As an operator, this gives you the chance
                to perform a key rotation on one keystone node, and distribute the new key set
                over a span of time. This does not require the distribution to take place in an
                ultra short period of time. Tokens encrypted with a primary key can be
                decrypted, and validated, on other nodes where that key is still staged.</para>
        </section>
        <section xml:id="where-do-i-put-my-key-repository">
          <title>Where do I put my key repository?</title>
          <para>The key repository is specified using the <literal>key_repository</literal> option in the
                keystone configuration file. The keystone process should be able to read and
                write to this location but it should be kept secret otherwise. Currently,
                keystone only supports file-backed key repositories.</para>
          <screen language="ini">[fernet_tokens]
key_repository = /etc/keystone/fernet-keys/</screen>
        </section>
        <section xml:id="what-is-the-recommended-way-to-rotate-and-distribute-keys">
          <title>What is the recommended way to rotate and distribute keys?</title>
          <para>The <command>keystone-manage</command> command line utility includes a key rotation
                mechanism. This mechanism will initialize and rotate keys but does not make
                an effort to distribute keys across keystone nodes. The distribution of keys
                across a keystone deployment is best handled through configuration management
                tooling. Use <command>keystone-manage fernet_rotate</command> to rotate the key
                repository.</para>
        </section>
        <section xml:id="do-fernet-tokens-still-expire">
          <title>Do fernet tokens still expire?</title>
          <para>Yes, fernet tokens can expire just like any other keystone token formats.</para>
        </section>
        <section xml:id="why-should-i-choose-fernet-tokens-over-uuid-tokens">
          <title>Why should I choose fernet tokens over UUID tokens?</title>
          <para>Even though fernet tokens operate very similarly to UUID tokens, they do not
                require persistence or leverage the configured token persistence driver in any
                way. The keystone token database no longer suffers bloat as a side effect of
                authentication. Pruning expired tokens from the token database is no longer
                required when using fernet tokens. Because fernet tokens do not require
                persistence, they do not have to be replicated. As long as each keystone node
                shares the same key repository, fernet tokens can be created and validated
                instantly across nodes.</para>
        </section>
        <section xml:id="why-should-i-choose-fernet-tokens-over-pki-or-pkiz-tokens">
          <title>Why should I choose fernet tokens over PKI or PKIZ tokens?</title>
          <para>The arguments for using fernet over PKI and PKIZ remain the same as UUID, in
                addition to the fact that fernet tokens are much smaller than PKI and PKIZ
                tokens. PKI and PKIZ tokens still require persistent storage and can sometimes
                cause issues due to their size. This issue is mitigated when switching to
                fernet because fernet tokens are kept under a 250 byte limit. PKI and PKIZ
                tokens typically exceed 1600 bytes in length. The length of a PKI or PKIZ token
                is dependent on the size of the deployment. Bigger service catalogs will result
                in longer token lengths. This pattern does not exist with fernet tokens because
                the contents of the encrypted payload is kept to a minimum.</para>
        </section>
        <section xml:id="should-i-rotate-and-distribute-keys-from-the-same-keystone-node-every-rotation">
          <title>Should I rotate and distribute keys from the same keystone node every rotation?</title>
          <para>No, but the relationship between rotation and distribution should be lock-step.
                Once you rotate keys on one keystone node, the key repository from that node
                should be distributed to the rest of the cluster. Once you confirm that each
                node has the same key repository state, you could rotate and distribute from
                any other node in the cluster.</para>
          <para>If the rotation and distribution are not lock-step, a single keystone node in
                the deployment will create tokens with a primary key that no other node has as
                a staged key. This will cause tokens generated from one keystone node to fail
                validation on other keystone nodes.</para>
        </section>
        <section xml:id="how-do-i-add-new-keystone-nodes-to-a-deployment">
          <title>How do I add new keystone nodes to a deployment?</title>
          <para>The keys used to create fernet tokens should be treated like super secret
                configuration files, similar to an SSL secret key. Before a node is allowed to
                join an existing cluster, issuing and validating tokens, it should have the
                same key repository as the rest of the nodes in the cluster.</para>
        </section>
        <section xml:id="how-should-i-approach-key-distribution">
          <title>How should I approach key distribution?</title>
          <para>Remember that key distribution is only required in multi-node keystone
                deployments. If you only have one keystone node serving requests in your
                deployment, key distribution is unnecessary.</para>
          <para>Key distribution is a problem best approached from the deployment’s current
                configuration management system. Since not all deployments use the same
                configuration management systems, it makes sense to explore options around what
                is already available for managing keys, while keeping the secrecy of the keys
                in mind. Many configuration management tools can leverage something like
                <literal>rsync</literal> to manage key distribution.</para>
          <para>Key rotation is a single operation that promotes the current staged key to
                primary, creates a new staged key, and prunes old secondary keys. It is easiest
                to do this on a single node and verify the rotation took place properly before
                distributing the key repository to the rest of the cluster. The concept behind
                the staged key breaks the expectation that key rotation and key distribution
                have to be done in a single step. With the staged key, we have time to inspect
                the new key repository before syncing state with the rest of the cluster. Key
                distribution should be an operation that can run in succession until it
                succeeds. The following might help illustrate the isolation between key
                rotation and key distribution.</para>
          <procedure>
            <step>
              <para>Ensure all keystone nodes in the deployment have the same key repository.</para>
            </step>
            <step>
              <para>Pick a keystone node in the cluster to rotate from.</para>
            </step>
            <step>
              <para>Rotate keys.</para>
              <substeps>
                <step>
                  <para>Was it successful?</para>
                  <substeps>
                    <step>
                      <para>If no, investigate issues with the particular keystone node you
                                        rotated keys on. Fernet keys are small and the operation for
                                        rotation is trivial. There should not be much room for error in key
                                        rotation. It is possible that the user does not have the ability to
                                        write new keys to the key repository. Log output from
                                        <literal>keystone-manage fernet_rotate</literal> should give more information into
                                        specific failures.</para>
                    </step>
                    <step>
                      <para>If yes, you should see a new staged key. The old staged key should
                                        be the new primary. Depending on the <literal>max_active_keys</literal> limit you
                                        might have secondary keys that were pruned. At this point, the node
                                        that you rotated on will be creating fernet tokens with a primary
                                        key that all other nodes should have as the staged key. This is why
                                        we checked the state of all key repositories in Step one. All other
                                        nodes in the cluster should be able to decrypt tokens created with
                                        the new primary key. At this point, we are ready to distribute the
                                        new key set.</para>
                    </step>
                  </substeps>
                </step>
              </substeps>
            </step>
            <step>
              <para>Distribute the new key repository.</para>
              <substeps>
                <step>
                  <para>Was it successful?</para>
                  <substeps>
                    <step>
                      <para>If yes, you should be able to confirm that all nodes in the cluster
                                        have the same key repository that was introduced in Step 3.  All
                                        nodes in the cluster will be creating tokens with the primary key
                                        that was promoted in Step 3. No further action is required until the
                                        next schedule key rotation.</para>
                    </step>
                    <step>
                      <para>If no, try distributing again. Remember that we already rotated the
                                        repository and performing another rotation at this point will
                                        result in tokens that cannot be validated across certain hosts.
                                        Specifically, the hosts that did not get the latest key set. You
                                        should be able to distribute keys until it is successful. If certain
                                        nodes have issues syncing, it could be permission or network issues
                                        and those should be resolved before subsequent rotations.</para>
                    </step>
                  </substeps>
                </step>
              </substeps>
            </step>
          </procedure>
        </section>
        <section xml:id="how-long-should-i-keep-my-keys-around">
          <title>How long should I keep my keys around?</title>
          <para>The fernet tokens that keystone creates are only secure as the keys creating
                them. With staged keys the penalty of key rotation is low, allowing you to err
                on the side of security and rotate weekly, daily, or even hourly.  Ultimately,
                this should be less time than it takes an attacker to break a <literal>AES256</literal> key
                and a <literal>SHA256 HMAC</literal>.</para>
        </section>
        <section xml:id="is-a-fernet-token-still-a-bearer-token">
          <title>Is a fernet token still a bearer token?</title>
          <para>Yes, and they follow exactly the same validation path as UUID tokens, with the
                exception of being written to, and read from, a back end. If someone
                compromises your fernet token, they have the power to do all the operations you
                are allowed to do.</para>
        </section>
        <section xml:id="what-if-i-need-to-revoke-all-my-tokens">
          <title>What if I need to revoke all my tokens?</title>
          <para>To invalidate every token issued from keystone and start fresh, remove the
                current key repository, create a new key set, and redistribute it to all nodes
                in the cluster. This will render every token issued from keystone as invalid
                regardless if the token has actually expired. When a client goes to
                re-authenticate, the new token will have been created with a new fernet key.</para>
        </section>
        <section xml:id="what-can-an-attacker-do-if-they-compromise-a-fernet-key-in-my-deployment">
          <title>What can an attacker do if they compromise a fernet key in my deployment?</title>
          <para>If any key used in the key repository is compromised, an attacker will be able
                to build their own tokens. If they know the ID of an administrator on a
                project, they could generate administrator tokens for the project. They will be
                able to generate their own tokens until the compromised key has been removed
                from from the repository.</para>
        </section>
        <section xml:id="i-rotated-keys-and-now-tokens-are-invalidating-early-what-did-i-do">
          <title>I rotated keys and now tokens are invalidating early, what did I do?</title>
          <para>Using fernet tokens requires some awareness around token expiration and the key
                lifecycle. You do not want to rotate so often that secondary keys are removed
                that might still be needed to decrypt unexpired tokens. If this happens, you
                will not be able to decrypt the token because the key the was used to encrypt
                it is now gone. Only remove keys that you know are not being used to encrypt or
                decrypt tokens.</para>
          <para>For example, your token is valid for 24 hours and we want to rotate keys every
                six hours. We will need to make sure tokens that were created at 08:00 AM on
                Monday are still valid at 07:00 AM on Tuesday, assuming they were not
                prematurely revoked. To accomplish this, we will want to make sure we set
                <literal>max_active_keys=6</literal> in our keystone configuration file. This will allow us to
                hold all keys that might still be required to validate a previous token, but
                keeps the key repository limited to only the keys that are needed.</para>
          <para>The number of <literal>max_active_keys</literal> for a deployment can be determined by
                dividing the token lifetime, in hours, by the frequency of rotation in hours
                and adding two. Better illustrated as:</para>
          <screen>token_expiration = 24
rotation_frequency = 6
max_active_keys = (token_expiration / rotation_frequency) + 2</screen>
          <para>The reason for adding two additional keys to the count is to include the staged
                key and a buffer key. This can be shown based on the previous example. We
                initially setup the key repository at 6:00 AM on Monday, and the initial state
                looks like:</para>
          <screen language="console">$ ls -la /etc/keystone/fernet-keys/
drwx------ 2 keystone keystone 4096 .
drwxr-xr-x 3 keystone keystone 4096 ..
-rw------- 1 keystone keystone   44 0    (staged key)
-rw------- 1 keystone keystone   44 1    (primary key)</screen>
          <para>All tokens created after 6:00 AM are encrypted with key <literal>1</literal>. At 12:00 PM we
                will rotate keys again, resulting in:</para>
          <screen language="console">$ ls -la /etc/keystone/fernet-keys/
drwx------ 2 keystone keystone 4096 .
drwxr-xr-x 3 keystone keystone 4096 ..
-rw------- 1 keystone keystone   44 0    (staged key)
-rw------- 1 keystone keystone   44 1    (secondary key)
-rw------- 1 keystone keystone   44 2    (primary key)</screen>
          <para>We are still able to validate tokens created between 6:00 - 11:59 AM because
                the <literal>1</literal> key still exists as a secondary key. All tokens issued after 12:00 PM
                will be encrypted with key <literal>2</literal>. At 6:00 PM we do our next rotation, resulting
                in:</para>
          <screen language="console">$ ls -la /etc/keystone/fernet-keys/
drwx------ 2 keystone keystone 4096 .
drwxr-xr-x 3 keystone keystone 4096 ..
-rw------- 1 keystone keystone   44 0    (staged key)
-rw------- 1 keystone keystone   44 1    (secondary key)
-rw------- 1 keystone keystone   44 2    (secondary key)
-rw------- 1 keystone keystone   44 3    (primary key)</screen>
          <para>It is still possible to validate tokens issued from 6:00 AM - 5:59 PM because
                keys <literal>1</literal> and <literal>2</literal> exist as secondary keys. Every token issued until 11:59 PM
                will be encrypted with key <literal>3</literal>, and at 12:00 AM we do our next rotation:</para>
          <screen language="console">$ ls -la /etc/keystone/fernet-keys/
drwx------ 2 keystone keystone 4096 .
drwxr-xr-x 3 keystone keystone 4096 ..
-rw------- 1 keystone keystone   44 0    (staged key)
-rw------- 1 keystone keystone   44 1    (secondary key)
-rw------- 1 keystone keystone   44 2    (secondary key)
-rw------- 1 keystone keystone   44 3    (secondary key)
-rw------- 1 keystone keystone   44 4    (primary key)</screen>
          <para>Just like before, we can still validate tokens issued from 6:00 AM the previous
                day until 5:59 AM today because keys <literal>1</literal> - <literal>4</literal> are present. At 6:00 AM,
                tokens issued from the previous day will start to expire and we do our next
                scheduled rotation:</para>
          <screen language="console">$ ls -la /etc/keystone/fernet-keys/
drwx------ 2 keystone keystone 4096 .
drwxr-xr-x 3 keystone keystone 4096 ..
-rw------- 1 keystone keystone   44 0    (staged key)
-rw------- 1 keystone keystone   44 1    (secondary key)
-rw------- 1 keystone keystone   44 2    (secondary key)
-rw------- 1 keystone keystone   44 3    (secondary key)
-rw------- 1 keystone keystone   44 4    (secondary key)
-rw------- 1 keystone keystone   44 5    (primary key)</screen>
          <para>Tokens will naturally expire after 6:00 AM, but we will not be able to remove
                key <literal>1</literal> until the next rotation because it encrypted all tokens from 6:00 AM
                to 12:00 PM the day before. Once we do our next rotation, which is at 12:00 PM,
                the <literal>1</literal> key will be pruned from the repository:</para>
          <screen language="console">$ ls -la /etc/keystone/fernet-keys/
drwx------ 2 keystone keystone 4096 .
drwxr-xr-x 3 keystone keystone 4096 ..
-rw------- 1 keystone keystone   44 0    (staged key)
-rw------- 1 keystone keystone   44 2    (secondary key)
-rw------- 1 keystone keystone   44 3    (secondary key)
-rw------- 1 keystone keystone   44 4    (secondary key)
-rw------- 1 keystone keystone   44 5    (secondary key)
-rw------- 1 keystone keystone   44 6    (primary key)</screen>
          <para>If keystone were to receive a token that was created between 6:00 AM and 12:00
                PM the day before, encrypted with the <literal>1</literal> key, it would not be valid because
                it was already expired. This makes it possible for us to remove the <literal>1</literal> key
                from the repository without negative validation side-effects.</para>
        </section>
      </section>
      <section xml:id="use-trusts" xml:base="identity-use-trusts">
        <title>Use trusts</title>
        <para>OpenStack Identity manages authentication and authorization. A trust is
            an OpenStack Identity extension that enables delegation and, optionally,
            impersonation through <literal>keystone</literal>. A trust extension defines a
            relationship between:</para>
        <variablelist>
          <varlistentry>
            <term>
              <emphasis role="bold">Trustor</emphasis>
            </term>
            <listitem>
              <para>The user delegating a limited set of their own rights to another user.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <emphasis role="bold">Trustee</emphasis>
            </term>
            <listitem>
              <para>The user trust is being delegated to, for a limited time.</para>
              <para>The trust can eventually allow the trustee to impersonate the trustor.
                        For security reasons, some safeties are added. For example, if a trustor
                        loses a given role, any trusts the user issued with that role, and the
                        related tokens, are automatically revoked.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>The delegation parameters are:</para>
        <variablelist>
          <varlistentry>
            <term>
              <emphasis role="bold">User ID</emphasis>
            </term>
            <listitem>
              <para>The user IDs for the trustor and trustee.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <emphasis role="bold">Privileges</emphasis>
            </term>
            <listitem>
              <para>The delegated privileges are a combination of a project ID and a
                        number of roles that must be a subset of the roles assigned to the
                        trustor.</para>
              <para>If you omit all privileges, nothing is delegated. You cannot
                        delegate everything.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <emphasis role="bold">Delegation depth</emphasis>
            </term>
            <listitem>
              <para>Defines whether or not the delegation is recursive. If it is
                        recursive, defines the delegation chain length.</para>
              <para>Specify one of the following values:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>0</literal>. The delegate cannot delegate these permissions further.</para>
                </listitem>
                <listitem>
                  <para><literal>1</literal>. The delegate can delegate the permissions to any set of
                                delegates but the latter cannot delegate further.</para>
                </listitem>
                <listitem>
                  <para><literal>inf</literal>. The delegation is infinitely recursive.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <emphasis role="bold">Endpoints</emphasis>
            </term>
            <listitem>
              <para>A list of endpoints associated with the delegation.</para>
              <para>This parameter further restricts the delegation to the specified
                        endpoints only. If you omit the endpoints, the delegation is
                        useless. A special value of <literal>all_endpoints</literal> allows the trust to be
                        used by all endpoints associated with the delegated project.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <emphasis role="bold">Duration</emphasis>
            </term>
            <listitem>
              <para>(Optional) Comprised of the start time and end time for the trust.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section xml:id="caching-layer" xml:base="identity-caching-layer">
        <title>Caching layer</title>
        <para>OpenStack Identity supports a caching layer that is above the configurable
            subsystems (for example, token). This gives you the flexibility to setup
            caching for all or some subsystems. OpenStack Identity uses the <link xlink:href="https://docs.openstack.org/oslo.cache/pike/">oslo.cache</link> library which allows
            flexible cache back ends. The majority of the caching configuration options are
            set in the <literal>[cache]</literal> section of the <literal>/etc/keystone/keystone.conf</literal> file. The
            <literal>enabled</literal> option of the <literal>[cache]</literal> section must be set to <literal>True</literal> in order
            for any subsystem to cache responses. Each section that has the capability to
            be cached will have a <literal>caching</literal> boolean value that toggles caching behavior
            of that particular subsystem.</para>
        <para>So to enable only the token back end caching, set the values as follows:</para>
        <screen language="ini">[cache]
enabled=true

[catalog]
caching=false

[domain_config]
caching=false

[federation]
caching=false

[resource]
caching=false

[revoke]
caching=false

[role]
caching=false

[token]
caching=true</screen>
        <note>
          <para>Each subsystem is configured to cache by default. However, the global
                toggle for caching defaults to <literal>False</literal>. A subsystem is only able to cache
                responses if the global toggle is enabled.</para>
        </note>
        <para>Current functional back ends are:</para>
        <variablelist>
          <varlistentry>
            <term>
              <literal>dogpile.cache.memcached</literal>
            </term>
            <listitem>
              <para>Memcached back end using the standard <literal>python-memcached</literal> library.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>dogpile.cache.pylibmc</literal>
            </term>
            <listitem>
              <para>Memcached back end using the <literal>pylibmc</literal> library.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>dogpile.cache.bmemcached</literal>
            </term>
            <listitem>
              <para>Memcached using the <literal>python-binary-memcached</literal> library.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>dogpile.cache.redis</literal>
            </term>
            <listitem>
              <para>Redis back end.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>dogpile.cache.dbm</literal>
            </term>
            <listitem>
              <para>Local DBM file back end.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>dogpile.cache.memory</literal>
            </term>
            <listitem>
              <para>In-memory cache, not suitable for use outside of testing as it does not
                        cleanup its internal cache on cache expiration and does not share cache
                        between processes. This means that caching and cache invalidation will not
                        be consistent or reliable.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>dogpile.cache.mongo</literal>
            </term>
            <listitem>
              <para>MongoDB as caching back end.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <section xml:id="caching-for-tokens-and-tokens-validation">
          <title>Caching for tokens and tokens validation</title>
          <para>The token subsystem is OpenStack Identity’s most heavily used API. As a result,
                all types of tokens benefit from caching, including Fernet tokens. Although
                Fernet tokens do not need to be persisted, they should still be cached for
                optimal token validation performance.</para>
          <para>The token system has a separate <literal>cache_time</literal> configuration option,
                that can be set to a value above or below the global <literal>expiration_time</literal>
                default, allowing for different caching behavior from the other systems
                in OpenStack Identity. This option is set in the <literal>[token]</literal> section of
                the configuration file.</para>
          <para>The token revocation list cache time is handled by the configuration
                option <literal>revocation_cache_time</literal> in the <literal>[token]</literal> section. The
                revocation list is refreshed whenever a token is revoked. It typically
                sees significantly more requests than specific token retrievals or token
                validation calls.</para>
          <para>Here is a list of actions that are affected by the cached time: getting
                a new token, revoking tokens, validating tokens, checking v2 tokens, and
                checking v3 tokens.</para>
          <para>The delete token API calls invalidate the cache for the tokens being
                acted upon, as well as invalidating the cache for the revoked token list
                and the validate and check token calls.</para>
          <para>Token caching is configurable independently of the <literal>revocation_list</literal>
                caching. Lifted expiration checks from the token drivers to the token
                manager. This ensures that cached tokens will still raise a
                <literal>TokenNotFound</literal> flag when expired.</para>
          <para>For cache consistency, all token IDs are transformed into the short
                token hash at the provider and token driver level. Some methods have
                access to the full ID (PKI Tokens), and some methods do not. Cache
                invalidation is inconsistent without token ID normalization.</para>
        </section>
        <section xml:id="caching-for-non-token-resources">
          <title>Caching for non-token resources</title>
          <para>Various other keystone components have a separate <literal>cache_time</literal> configuration
                option, that can be set to a value above or below the global
                <literal>expiration_time</literal> default, allowing for different caching behavior
                from the other systems in Identity service. This option can be set in various
                sections (for example, <literal>[role]</literal> and <literal>[resource]</literal>) of the configuration
                file.
                The create, update, and delete actions for domains, projects and roles
                will perform proper invalidations of the cached methods listed above.</para>
          <para>For more information about the different back ends (and configuration
                options), see:</para>
          <itemizedlist>
            <listitem>
              <para>
                <link xlink:href="https://dogpilecache.sqlalchemy.org/en/latest/api.html#memory-backends">dogpile.cache.memory</link>
              </para>
            </listitem>
            <listitem>
              <para>
                <link xlink:href="https://dogpilecache.sqlalchemy.org/en/latest/api.html#memcached-backends">dogpile.cache.memcached</link>
              </para>
              <note>
                <para>The memory back end is not suitable for use in a production
                            environment.</para>
              </note>
            </listitem>
            <listitem>
              <para>
                <link xlink:href="https://dogpilecache.sqlalchemy.org/en/latest/api.html#redis-backends">dogpile.cache.redis</link>
              </para>
            </listitem>
            <listitem>
              <para>
                <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://dogpilecache.sqlalchemy.org/en/latest/api.html#file-backends">dogpile.cache.dbm</link>
              </para>
            </listitem>
          </itemizedlist>
        </section>
        <section xml:id="cache-invalidation">
          <title>Cache invalidation</title>
          <para>A common concern with caching is relaying inaccurate information after updating
                or deleting a resource. Most subsystems within OpenStack Identity invalidate
                specific cache entries once they have changed. In cases where a specific cache
                entry cannot be invalidated from the cache, the cache region will be
                invalidated instead. This invalidates all entries within the cache to prevent
                returning stale or misleading data. A subsequent request for the resource will
                be fully processed and cached.</para>
          <warning>
            <para>Be aware that if a read-only back end is in use for a particular subsystem,
                    the cache will not immediately reflect changes performed through the back
                    end. Any given change may take up to the <literal>cache_time</literal> (if set in the
                    subsystem section of the configuration) or the global <literal>expiration_time</literal>
                    (set in the <literal>[cache]</literal> section of the configuration) before it is
                    reflected. If this type of delay is an issue, we recommend disabling
                    caching for that particular subsystem.</para>
          </warning>
        </section>
        <section xml:id="configure-the-memcached-back-end-example">
          <title>Configure the Memcached back end example</title>
          <para>The following example shows how to configure the memcached back end:</para>
          <screen language="ini">[cache]

enabled = true
backend = dogpile.cache.memcached
backend_argument = url:127.0.0.1:11211</screen>
          <para>You need to specify the URL to reach the <literal>memcached</literal> instance with the
                <literal>backend_argument</literal> parameter.</para>
        </section>
      </section>
      <section xml:id="identity-security-compliance" xml:base="identity-security-compliance">
        <title>Security compliance and PCI-DSS</title>
        <para>As of the Newton release, the Identity service contains additional security
            compliance features, specifically to satisfy Payment Card Industry -
            Data Security Standard (PCI-DSS) v3.1 requirements. See
            <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://specs.openstack.org/openstack/keystone-specs/specs/keystone/newton/pci-dss.html">Security Hardening PCI-DSS</link> for more information on PCI-DSS.</para>
        <para>Security compliance features are disabled by default and most of the features
            only apply to the SQL backend for the identity driver. Other identity backends,
            such as LDAP, should implement their own security controls.</para>
        <para>Enable these features by changing the configuration settings under the
            <literal>[security_compliance]</literal> section in <literal>keystone.conf</literal>.</para>
        <section xml:id="setting-an-account-lockout-threshold">
          <title>Setting an account lockout threshold</title>
          <para>The account lockout feature limits the number of incorrect password attempts.
                If a user fails to authenticate after the maximum number of attempts, the
                service disables the user. Users can be re-enabled by explicitly setting the
                enable user attribute with the update user API call, either
               <link xlink:href="https://developer.openstack.org/api-ref/identity/v2-ext/index.html">v2.0</link> or <link xlink:href="https://developer.openstack.org/api-ref/identity/v3/index.html#update-user">v3</link>.</para>
          <para>You set the maximum number of failed authentication attempts by setting
                the <literal>lockout_failure_attempts</literal>:</para>
          <screen language="ini">[security_compliance]
lockout_failure_attempts = 6</screen>
          <para>You set the number of minutes a user would be locked out by setting
                the <literal>lockout_duration</literal> in seconds:</para>
          <screen language="ini">[security_compliance]
lockout_duration = 1800</screen>
          <para>If you do not set the <literal>lockout_duration</literal>, users will be locked out
                indefinitely until the user is explicitly enabled via the API.</para>
          <para>You can ensure specific users are never locked out. This can be useful for
                service accounts or administrative users. You can do this by setting
                <literal>ignore_lockout_failure_attempts</literal> to <literal>true</literal> via a user update API
                (<literal>PATCH /v3/users/{user_id}</literal>):</para>
          <screen language="json">{
    "user": {
        "options": {
            "ignore_lockout_failure_attempts": true
        }
    }
}</screen>
        </section>
        <section xml:id="disabling-inactive-users">
          <title>Disabling inactive users</title>
          <para>PCI-DSS 8.1.4 requires that inactive user accounts be removed or disabled
                within 90 days. You can achieve this by setting the
                <literal>disable_user_account_days_inactive</literal>:</para>
          <screen language="ini">[security_compliance]
disable_user_account_days_inactive = 90</screen>
          <para>This above example means that users that have not authenticated (inactive) for
                the past 90 days are automatically disabled. Users can be re-enabled by
                explicitly setting the enable user attribute via the API.</para>
        </section>
        <section xml:id="force-users-to-change-password-upon-first-use">
          <title>Force users to change password upon first use</title>
          <para>PCI-DSS 8.2.6 requires users to change their password for first time use and
                upon an administrative password reset. Within the identity <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="http://developer.openstack.org/api-ref/identity/v3/index.html#users">user API</link>,
                <literal>create user</literal> and <literal>update user</literal> are considered administrative password
                changes. Whereas, <literal>change password for user</literal> is a self-service password
                change. Once this feature is enabled, new users, and users that have had their
                password reset, will be required to change their password upon next
                authentication (first use), before being able to access any services.</para>
          <para>Prior to enabling this feature, you may want to exempt some users that you do
                not wish to be required to change their password. You can mark a user as
                exempt by setting the user options attribute
                <literal>ignore_change_password_upon_first_use</literal> to <literal>true</literal> via a user update API
                (<literal>PATCH /v3/users/{user_id}</literal>):</para>
          <screen language="json">{
    "user": {
        "options": {
            "ignore_change_password_upon_first_use": true
        }
    }
}</screen>
          <warning>
            <para>Failure to mark service users as exempt from this requirement will result
                    in your service account passwords becoming expired after being reset.</para>
          </warning>
          <para>When ready, you can configure it so that users are forced to change their
                password upon first use by setting <literal>change_password_upon_first_use</literal>:</para>
          <screen language="ini">[security_compliance]
change_password_upon_first_use = True</screen>
        </section>
        <section xml:id="configuring-password-expiration">
          <title>Configuring password expiration</title>
          <para>Passwords can be configured to expire within a certain number of days by
                setting the <literal>password_expires_days</literal>:</para>
          <screen language="ini">[security_compliance]
password_expires_days = 90</screen>
          <para>Once set, any new password changes have an expiration date based on the
                date and time of the password change plus the number of days defined here. Existing
                passwords will not be impacted. If you want existing passwords to have an
                expiration date, you would need to run a SQL script against the password table
                in the database to update the <literal>expires_at</literal> column.</para>
          <para>If there exists a user whose password you do not want to expire, keystone
                supports setting that user’s option <literal>ignore_password_expiry</literal> to <literal>true</literal>
                via user update API (<literal>PATCH /v3/users/{user_id}</literal>):</para>
          <screen language="json">{
    "user": {
        "options": {
            "ignore_password_expiry": true
        }
    }
}</screen>
        </section>
        <section xml:id="configuring-password-strength-requirements">
          <title>Configuring password strength requirements</title>
          <para>You can set password strength requirements, such as requiring numbers in
                passwords or setting a minimum password length, by adding a regular
                expression to the <literal>password_regex</literal> setting:</para>
          <screen language="ini">[security_compliance]
password_regex = ^(?=.*\d)(?=.*[a-zA-Z]).{7,}$</screen>
          <para>The above example is a regular expression that requires a password to have:</para>
          <itemizedlist>
            <listitem>
              <para>One letter</para>
            </listitem>
            <listitem>
              <para>One digit</para>
            </listitem>
            <listitem>
              <para>Minimum length of seven characters</para>
            </listitem>
          </itemizedlist>
          <para>If you do set the <literal>password_regex</literal>, you should provide text that
                describes your password strength requirements. You can do this by setting the
                <literal>password_regex_description</literal>:</para>
          <screen language="ini">[security_compliance]
password_regex_description = Passwords must contain at least 1 letter, 1
                             digit, and be a minimum length of 7
                             characters.</screen>
          <para>It is imperative that the <literal>password_regex_description</literal> matches the actual
                regex. If the <literal>password_regex</literal> and the <literal>password_regex_description</literal> do
                not match, it will cause user experience to suffer since this description
                will be returned to users to explain why their requested password was
                insufficient.</para>
          <note>
            <para>You must ensure the <literal>password_regex_description</literal> accurately and
                    completely describes the <literal>password_regex</literal>. If the two options are out of
                    sync, the help text could inaccurately describe the password requirements
                    being applied to the password. This would lead to a poor user experience.</para>
          </note>
        </section>
        <section xml:id="requiring-a-unique-password-history">
          <title>Requiring a unique password history</title>
          <para>The password history requirements controls the number of passwords for a user
                that must be unique before an old password can be reused. You can enforce this
                by setting the <literal>unique_last_password_count</literal>:</para>
          <screen language="ini">[security_compliance]
unique_last_password_count= 5</screen>
          <para>The above example does not allow a user to create a new password that is the
                same as any of their last four previous passwords.</para>
          <para>Similarly, you can set the number of days that a password must be used before
                the user can change it by setting the <literal>minimum_password_age</literal>:</para>
          <screen language="ini">[security_compliance]
minimum_password_age = 1</screen>
          <para>In the above example, once a user changes their password, they would not be
                able to change it again for one day. This prevents users from changing their
                passwords immediately in order to wipe out their password history and reuse an
                old password.</para>
          <note>
            <para>When you set <literal>password_expires_days</literal>, the value for the
                    <literal>minimum_password_age</literal> should be less than the <literal>password_expires_days</literal>.
                    Otherwise, users would not be able to change their passwords before they
                    expire.</para>
          </note>
        </section>
      </section>
      <section xml:id="performance-and-scaling" xml:base="identity-performance">
        <title>Performance and scaling</title>
        <para>Before you begin tuning Keystone for performance and scalability, you should
            first know that Keystone is just a two tier horizontally-scalable web
            application, and the most effective methods for scaling it are going to be the
            same as for any other similarly designed web application: give it more
            processes, more memory, scale horizontally, and load balance the result.</para>
        <para>With that said, there are many opportunities for tuning the performance of
            Keystone, many of which are actually trade-offs between performance and
            security that you need to judge for yourself, and tune accordingly.</para>
        <section xml:id="pruning-expired-tokens-from-backend-storage">
          <title>Pruning expired tokens from backend storage</title>
          <para>Using a persistent token format will result in an ever-growing backend store.
                Keystone will not remove, or prune, tokens from the backend even after they are
                expired. This can be managed manually using <literal>keystone-manage token_flush</literal>,
                which will purge expired tokens from the data store in batches. Diligently
                pruning expired tokens will prevent token bloat.</para>
          <note>
            <para>This optimization is not necessary for deployments leveraging Fernet
                    tokens, which are non-persistent in nature.</para>
          </note>
        </section>
        <section xml:id="keystone-configuration-options-that-affect-performance">
          <title>Keystone configuration options that affect performance</title>
          <para>These are all of the options in <literal>keystone.conf</literal> that have a direct impact on
                performance. See the help descriptions for these options for more specific
                details on how and why you might want to tune these options for yourself.</para>
          <itemizedlist>
            <listitem>
              <para><literal>[DEFAULT] crypt_strength</literal>: Reduce this number to increase performance,
                        increase this number to make SQL managed password checking more secure.</para>
            </listitem>
            <listitem>
              <para><literal>[DEFAULT] max_project_tree_depth</literal>: Reduce this number to increase
                        performance, increase this number to cater to more complicated hierarchical
                        multitenancy use cases.</para>
            </listitem>
            <listitem>
              <para><literal>[DEFAULT] max_password_length</literal>: Reduce this number to increase
                        performance, increase this number to allow for more secure passwords.</para>
            </listitem>
            <listitem>
              <para><literal>[cache] enable</literal>: Enable this option to increase performance, but you also
                        need to configure other options in the <literal>[cache]</literal> section to actually
                        utilize caching.</para>
            </listitem>
            <listitem>
              <para><literal>[token] provider</literal>: All supported token providers have been primarily
                        driven by performance considerations. UUID and Fernet both require online
                        validation (cacheable HTTP calls back to keystone to validate tokens).
                        Fernet has the highest scalability characteristics overall, but requires more
                        work to validate, and therefore enabling caching (<literal>[cache] enable</literal>) is
                        absolutely critical.</para>
            </listitem>
            <listitem>
              <para><literal>[fernet] max_active_keys</literal>: If you’re using Fernet tokens, decrease this
                        option to improve performance, increase this option to support more advanced
                        key rotation strategies.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section xml:id="keystonemiddleware-configuration-options-that-affect-performance">
          <title>Keystone middleware configuration options that affect performance</title>
    <para>This configuration resides in the paste pipelines of the services consuming
                token validation from keystone. For example, the nova, cinder, and swift services.</para>
          <itemizedlist>
            <listitem>
              <para><literal>cache</literal>: When keystone’s <literal>auth_token</literal> middleware is deployed with a
                        swift cache, use this option to have <literal>auth_token</literal> middleware share a caching
                        backend with swift. Otherwise, use the <literal>memcached_servers</literal> option instead.</para>
            </listitem>
            <listitem>
              <para><literal>memcached_servers</literal>: Set this option to share a cache across
                        <literal>keystonemiddleware.auth_token</literal> processes.</para>
            </listitem>
            <listitem>
              <para><literal>token_cache_time</literal>: Increase this option to improve performance, decrease
                        this option to respond to token revocation events more quickly (thereby
                        increasing security).</para>
            </listitem>
            <listitem>
              <para><literal>revocation_cache_time</literal>: Increase this option to improve performance,
                        decrease this option to respond to token revocation events more quickly
                        (thereby increasing security).</para>
            </listitem>
            <listitem>
              <para><literal>memcache_security_strategy</literal>: Do not set this option to improve
                        performance, but set it to improve security where you’re sharing memcached
                        with other processes.</para>
            </listitem>
            <listitem>
              <para><literal>include_service_catalog</literal>: Disable this option to improve performance, if
                        the protected service does not require a service catalog.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
      <section xml:id="example-usage-and-identity-features" xml:base="identity-keystone-usage-and-features">
        <title>Example usage and Identity features</title>
        <para>The <literal>openstack</literal> CLI is used to interact with the Identity service.
            It is set up to expect commands in the general
            form of <literal>openstack command argument</literal>, followed by flag-like keyword
            arguments to provide additional (often optional) information. For
            example, the <command>openstack user list</command> and
            <command>openstack project create</command> commands can be invoked as follows:</para>
        <screen language="bash"># Using token auth env variables
export OS_SERVICE_ENDPOINT=http://127.0.0.1:5000/v2.0/
export OS_SERVICE_TOKEN=secrete_token
openstack user list
openstack project create demo --domain default

# Using token auth flags
openstack --os-token secrete --os-endpoint http://127.0.0.1:5000/v2.0/ user list
openstack --os-token secrete --os-endpoint http://127.0.0.1:5000/v2.0/ project create demo

# Using user + password + project_name env variables
export OS_USERNAME=admin
export OS_PASSWORD=secrete
export OS_PROJECT_NAME=admin
openstack user list
openstack project create demo --domain default

# Using user + password + project-name flags
openstack --os-username admin --os-password secrete --os-project-name admin user list
openstack --os-username admin --os-password secrete --os-project-name admin project create demo</screen>
        <section xml:id="logging">
          <title>Logging</title>
          <para>You configure logging externally to the rest of Identity. The name of
                the file specifying the logging configuration is set using the
                <literal>log_config_append</literal> option in the <literal>[DEFAULT]</literal> section of the
                <literal>/etc/keystone/keystone.conf</literal> file. To route logging through syslog,
                set <literal>use_syslog=true</literal> in the <literal>[DEFAULT]</literal> section.</para>
          <para>A sample logging configuration file is available with the project in
                <literal>etc/logging.conf.sample</literal>. Like other OpenStack projects, Identity
                uses the <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://docs.python.org/library/logging.html">Python logging module</link>, which provides extensive configuration
                options that let you define the output levels and formats.</para>
        </section>
        <section xml:id="user-crud">
          <title>User CRUD</title>
          <para>Identity provides a user CRUD (Create, Read, Update, and Delete) filter that
                Administrators can add to the <literal>public_api</literal> pipeline. The user CRUD filter
                enables users to use a HTTP PATCH to change their own password. To enable
                this extension you should define a <literal>user_crud_extension</literal> filter, insert
                it after the <literal>*_body</literal> middleware and before the <literal>public_service</literal>
                application in the <literal>public_api</literal> WSGI pipeline in
                <literal>keystone-paste.ini</literal>. For example:</para>
          <screen language="ini">[filter:user_crud_extension]
paste.filter_factory = keystone.contrib.user_crud:CrudExtension.factory

[pipeline:public_api]
pipeline = sizelimit url_normalize request_id build_auth_context token_auth admin_token_auth json_body ec2_extension user_crud_extension public_service</screen>
          <para>Each user can then change their own password with a HTTP PATCH.</para>
          <screen language="console">$ curl -X PATCH http://localhost:5000/v2.0/OS-KSCRUD/users/USERID -H "Content-type: application/json"  \
  -H "X_Auth_Token: AUTHTOKENID" -d '{"user": {"password": "ABCD", "original_password": "DCBA"}}'</screen>
          <para>In addition to changing their password, all current tokens for the user
                are invalidated.</para>
        </section>
      </section>
      <section xml:id="authentication-middleware-with-user-name-and-password" xml:base="identity-auth-token-middleware">
        <title>Authentication middleware with user name and password</title>
        <para>You can also configure Identity authentication middleware using the
            <literal>admin_user</literal> and <literal>admin_password</literal> options.</para>
        <note>
          <para>The <literal>admin_token</literal> option is deprecated and no longer used for
                configuring auth_token middleware.</para>
        </note>
        <para>For services that have a separate paste-deploy <literal>.ini</literal> file, you can
            configure the authentication middleware in the <literal>[keystone_authtoken]</literal>
            section of the main configuration file, such as <literal>nova.conf</literal>. In
            Compute, for example, you can remove the middleware parameters from
            <literal>api-paste.ini</literal>, as follows:</para>
        <screen language="ini">[filter:authtoken]
paste.filter_factory = keystonemiddleware.auth_token:filter_factory</screen>
        <para>And set the following values in <literal>nova.conf</literal> as follows:</para>
        <screen language="ini">[DEFAULT]
# ...
auth_strategy=keystone

[keystone_authtoken]
auth_uri = http://controller:5000/v2.0
identity_uri = http://controller:35357
admin_user = admin
admin_password = SuperSekretPassword
admin_tenant_name = service</screen>
        <note>
          <para>The middleware parameters in the paste config take priority. You
                must remove them to use the values in the <literal>[keystone_authtoken]</literal>
                section.</para>
        </note>
        <note>
          <para>Comment out any <literal>auth_host</literal>, <literal>auth_port</literal>, and
                <literal>auth_protocol</literal> options because the <literal>identity_uri</literal> option
                replaces them.</para>
        </note>
        <para>This sample paste config filter makes use of the <literal>admin_user</literal> and
            <literal>admin_password</literal> options:</para>
        <screen language="ini">[filter:authtoken]
paste.filter_factory = keystonemiddleware.auth_token:filter_factory
auth_uri = http://controller:5000/v2.0
identity_uri = http://controller:35357
auth_token = 012345SECRET99TOKEN012345
admin_user = admin
admin_password = keystone123</screen>
        <note>
          <para>Using this option requires an admin project and role relationship. The
                admin user is granted access to the admin role on the admin project.</para>
        </note>
        <note>
          <para>Comment out any <literal>auth_host</literal>, <literal>auth_port</literal>, and
                <literal>auth_protocol</literal> options because the <literal>identity_uri</literal> option
                replaces them.</para>
        </note>
      </section>
      <section xml:id="identity-api-protection-with-role-based-access-control-rbac" xml:base="identity-service-api-protection">
        <title>Identity API protection with role-based access control (RBAC)</title>
        <para>Like most OpenStack projects, Identity supports the protection of its
            APIs by defining policy rules based on an RBAC approach. Identity stores
            a reference to a policy JSON file in the main Identity configuration
            file, <literal>/etc/keystone/keystone.conf</literal>. Typically this file is named
            <literal>policy.json</literal>, and contains the rules for which roles have access to
            certain actions in defined services.</para>
        <para>Each Identity API v3 call has a line in the policy file that dictates
            which level of governance of access applies.</para>
        <screen language="none">API_NAME: RULE_STATEMENT or MATCH_STATEMENT</screen>
        <para>Where:</para>
        <para><literal>RULE_STATEMENT</literal> can contain <literal>RULE_STATEMENT</literal> or
            <literal>MATCH_STATEMENT</literal>.</para>
        <para><literal>MATCH_STATEMENT</literal> is a set of identifiers that must match between the
            token provided by the caller of the API and the parameters or target
            entities of the API call in question. For example:</para>
        <screen language="none">"identity:create_user": "role:admin and domain_id:%(user.domain_id)s"</screen>
        <para>Indicates that to create a user, you must have the admin role in your
            token. The <literal>domain_id</literal> in your token must match the
            <literal>domain_id</literal> in the user object that you are trying
            to create, which implies this must be a domain-scoped token.
            In other words, you must have the admin role on the domain
            in which you are creating the user, and the token that you use
            must be scoped to that domain.</para>
        <para>Each component of a match statement uses this format:</para>
        <screen language="none">ATTRIB_FROM_TOKEN:CONSTANT or ATTRIB_RELATED_TO_API_CALL</screen>
        <para>The Identity service expects these attributes:</para>
        <para>Attributes from token:</para>
        <itemizedlist>
          <listitem>
            <para>
              <literal>user_id</literal>
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>domain_id</literal>
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>project_id</literal>
            </para>
          </listitem>
        </itemizedlist>
        <para>The <literal>project_id</literal> attribute requirement depends on the scope, and the
            list of roles you have within that scope.</para>
        <para>Attributes related to API call:</para>
        <itemizedlist>
          <listitem>
            <para>
              <literal>user.domain_id</literal>
            </para>
          </listitem>
          <listitem>
            <para>Any parameters passed into the API call</para>
          </listitem>
          <listitem>
            <para>Any filters specified in the query string</para>
          </listitem>
        </itemizedlist>
        <para>Objects are referenced with the <literal>object.attribute</literal>
            syntax (such as, <literal>user.domain_id</literal>). The target objects of an API are
            also available using the <literal>target.object.attribute</literal> syntax. For instance:</para>
        <screen language="none">"identity:delete_user": "role:admin and domain_id:%(target.user.domain_id)s"</screen>
        <para>Ensures that Identity only deletes the user object in the same
            domain as the provided token.</para>
        <para>Every target object has an <literal>id</literal> and a <literal>name</literal> available as
            <literal>target.OBJECT.id</literal> and <literal>target.OBJECT.name</literal>. Identity retrieves
            other attributes from the database, and the attributes vary between
            object types. The Identity service filters out some database fields,
            such as user passwords.</para>
        <para>List of object attributes:</para>
        <screen language="yaml">role:
     target.role.id
     target.role.name

user:
     target.user.default_project_id
     target.user.description
     target.user.domain_id
     target.user.enabled
     target.user.id
     target.user.name

group:
     target.group.description
     target.group.domain_id
     target.group.id
     target.group.name

domain:
     target.domain.enabled
     target.domain.id
     target.domain.name

project:
     target.project.description
     target.project.domain_id
     target.project.enabled
     target.project.id
     target.project.name</screen>
        <para>The default <literal>policy.json</literal> file supplied provides a somewhat
            basic example of API protection, and does not assume any particular
            use of domains. Refer to <literal>policy.v3cloudsample.json</literal> as an
            example of multi-domain configuration installations where a cloud
            provider wants to delegate administration of the contents of a domain
            to a particular <literal>admin domain</literal>. This example policy file also
            shows the use of an <literal>admin_domain</literal> to allow a cloud provider to
            enable administrators to have wider access across the APIs.</para>
        <para>A clean installation could start with the standard policy file, to
            allow creation of the <literal>admin_domain</literal> with the first users within
            it. You could then obtain the <literal>domain_id</literal> of the admin domain,
            paste the ID into a modified version of
            <literal>policy.v3cloudsample.json</literal>, and then enable it as the main
            <literal>policy file</literal>.</para>
      </section>
      <section xml:id="troubleshoot-the-identity-service" xml:base="identity-troubleshoot">
        <title>Troubleshoot the Identity service</title>
        <para>To troubleshoot the Identity service, review the logs in the
            <literal>/var/log/keystone/keystone.log</literal> file.</para>
        <para>Use the <literal>/etc/keystone/logging.conf</literal> file to configure the
            location of log files.</para>
        <note>
          <para>The <literal>insecure_debug</literal> flag is unique to the Identity service.
                If you enable <literal>insecure_debug</literal>, error messages from the API change
                to return security-sensitive information. For example, the error message
                on failed authentication includes information on why your authentication
                failed.</para>
        </note>
        <para>The logs show the components that have come in to the WSGI request, and
            ideally show an error that explains why an authorization request failed.
            If you do not see the request in the logs, run keystone with the
            <literal>--debug</literal> parameter. Pass the <literal>--debug</literal> parameter before the
            command parameters.</para>
        <section xml:id="debug-pki-middleware">
          <title>Debug PKI middleware</title>
          <section xml:id="problem">
            <title>Problem</title>
            <para>If you receive an <literal>Invalid OpenStack Identity Credentials</literal> message when
                    you accessing and reaching an OpenStack service, it might be caused by
                    the changeover from UUID tokens to PKI tokens in the Grizzly release.</para>
            <para>The PKI-based token validation scheme relies on certificates from
                    Identity that are fetched through HTTP and stored in a local directory.
                    The location for this directory is specified by the <literal>signing_dir</literal>
                    configuration option.</para>
          </section>
          <section xml:id="solution">
            <title>Solution</title>
            <para>In your services configuration file, look for a section like this:</para>
            <screen language="ini">[keystone_authtoken]
signing_dir = /var/cache/glance/api
auth_uri = http://controller:5000/v2.0
identity_uri = http://controller:35357
admin_tenant_name = service
admin_user = glance</screen>
            <para>The first thing to check is that the <literal>signing_dir</literal> does, in fact,
                    exist. If it does, check for certificate files:</para>
            <screen language="console">$ ls -la /var/cache/glance/api/

total 24
drwx------. 2 ayoung root 4096 Jul 22 10:58 .
drwxr-xr-x. 4 root root 4096 Nov 7 2012 ..
-rw-r-----. 1 ayoung ayoung 1424 Jul 22 10:58 cacert.pem
-rw-r-----. 1 ayoung ayoung 15 Jul 22 10:58 revoked.pem
-rw-r-----. 1 ayoung ayoung 4518 Jul 22 10:58 signing_cert.pem</screen>
            <para>This directory contains two certificates and the token revocation list.
                    If these files are not present, your service cannot fetch them from
                    Identity. To troubleshoot, try to talk to Identity to make sure it
                    correctly serves files, as follows:</para>
            <screen language="console">$ curl http://localhost:35357/v2.0/certificates/signing</screen>
            <para>This command fetches the signing certificate:</para>
            <screen language="yaml">Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1 (0x1)
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: C=US, ST=Unset, L=Unset, O=Unset, CN=www.example.com
        Validity
            Not Before: Jul 22 14:57:31 2013 GMT
            Not After : Jul 20 14:57:31 2023 GMT
        Subject: C=US, ST=Unset, O=Unset, CN=www.example.com</screen>
            <para>Note the expiration dates of the certificate:</para>
            <screen language="console">Not Before: Jul 22 14:57:31 2013 GMT
Not After : Jul 20 14:57:31 2023 GMT</screen>
            <para>The token revocation list is updated once a minute, but the certificates
                    are not. One possible problem is that the certificates are the wrong
                    files or garbage. You can remove these files and run another command
                    against your server; they are fetched on demand.</para>
            <para>The Identity service log should show the access of the certificate files. You
                    might have to turn up your logging levels. Set <literal>debug = True</literal> in your
                    Identity configuration file and restart the Identity server.</para>
            <screen language="console">(keystone.common.wsgi): 2013-07-24 12:18:11,461 DEBUG wsgi __call__
arg_dict: {}
(access): 2013-07-24 12:18:11,462 INFO core __call__ 127.0.0.1 - - [24/Jul/2013:16:18:11 +0000]
"GET http://localhost:35357/v2.0/certificates/signing HTTP/1.0" 200 4518</screen>
            <para>If the files do not appear in your directory after this, it is likely
                    one of the following issues:</para>
            <itemizedlist>
              <listitem>
                <para>Your service is configured incorrectly and cannot talk to Identity.
                            Check the <literal>auth_port</literal> and <literal>auth_host</literal> values and make sure that
                            you can talk to that service through cURL, as shown previously.</para>
              </listitem>
              <listitem>
                <para>Your signing directory is not writable. Use the <literal>chmod</literal> command to
                            change its permissions so that the service (POSIX) user can write to
                            it. Verify the change through <literal>su</literal> and <literal>touch</literal> commands.</para>
              </listitem>
              <listitem>
                <para>The SELinux policy is denying access to the directory.</para>
              </listitem>
            </itemizedlist>
            <para>If you are not using a <literal>/var/cache</literal> sub-directory, you should. Modify
                    the <literal>signing_dir</literal> configuration option for your service and restart.</para>
            <para>Set back to <literal>setenforce enforcing</literal> to confirm that your changes solve
                    the problem.</para>
            <para>If your certificates are fetched on demand, the PKI validation is
                    working properly. Most likely, the token from Identity is not valid for
                    the operation you are attempting to perform, and your user needs a
                    different role for the operation.</para>
          </section>
        </section>
        <section xml:id="debug-signing-key-file-errors">
          <title>Debug signing key file errors</title>
          <section>
            <title>Problem</title>
            <para>If an error occurs when the signing key file opens, it is possible that
                    the person who ran the <command>keystone-manage pki_setup</command> command to
                    generate certificates and keys did not use the correct user.</para>
          </section>
          <section xml:id="keystone-id2">
            <title>Solution</title>
            <para>When you run the <command>keystone-manage pki_setup</command> command, Identity
                    generates a set of certificates and keys in <literal>/etc/keystone/ssl*</literal>, which
                    is owned by <literal>root:root</literal>. This can present a problem when you run the
                    Identity daemon under the keystone user account (nologin) when you try
                    to run PKI. Unless you run the <command>chown</command> command against the
                    files <literal>keystone:keystone</literal>, or run the <command>keystone-manage pki_setup</command>
                    command with the <literal>--keystone-user</literal> and
                    <literal>--keystone-group</literal> parameters, you will get an error.
                    For example:</para>
            <screen language="console">2012-07-31 11:10:53 ERROR [keystone.common.cms] Error opening signing key file
/etc/keystone/ssl/private/signing_key.pem
140380567730016:error:0200100D:system library:fopen:Permission
denied:bss_file.c:398:fopen('/etc/keystone/ssl/private/signing_key.pem','r')
140380567730016:error:20074002:BIO routines:FILE_CTRL:system lib:bss_file.c:400:
unable to load signing key file</screen>
          </section>
        </section>
        <section xml:id="flush-expired-tokens-from-the-token-database-table">
          <title>Flush expired tokens from the token database table</title>
          <section xml:id="id3">
            <title>Problem</title>
            <para>As you generate tokens, the token database table on the Identity server
                    grows.</para>
          </section>
          <section xml:id="id4">
            <title>Solution</title>
            <para>To clear the token table, an administrative user must run the
                    <command>keystone-manage token_flush</command> command to flush the tokens. When you
                    flush tokens, expired tokens are deleted and traceability is eliminated.</para>
            <para>Use <literal>cron</literal> to schedule this command to run frequently based on your
                    workload. For large workloads, we recommend running it every minute.</para>
          </section>
        </section>
      </section>
      <section xml:id="token-provider" xml:base="token-provider">
        <title>Token provider</title>
        <para>OpenStack Identity supports customizable token providers. This is specified
            in the <literal>[token]</literal> section of the configuration file. The token provider
            controls the token construction, validation, and revocation operations.</para>
        <para>You can register your own token provider by configuring the following property:</para>
        <note>
          <para>More commonly, you can use this option to change the token provider to one
                of the ones built in. Alternatively, you can use it to configure your own
                token provider.</para>
        </note>
        <itemizedlist>
          <listitem>
            <para><literal>provider</literal> - token provider driver.
                    Defaults to <literal>uuid</literal>.
                    Implemented by <literal>keystone.token.providers.uuid.Provider</literal>. This is the
                    entry point for the token provider in the <literal>keystone.token.provider</literal>
                    namespace.</para>
          </listitem>
        </itemizedlist>
        <para>Each token format uses different technologies to achieve various performance,
            scaling, and architectural requirements. The Identity service includes
            <literal>fernet</literal>, <literal>pkiz</literal>, <literal>pki</literal>, and <literal>uuid</literal> token providers.</para>
        <para>Below is the detailed list of the token formats:</para>
        <variablelist>
          <varlistentry>
            <term>UUID</term>
            <listitem>
              <para><literal>uuid</literal> tokens must be persisted (using the back end specified in the
                        <literal>[token] driver</literal> option), but do not require any extra configuration
                        or setup.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>PKI and PKIZ</term>
            <listitem>
              <para><literal>pki</literal> and <literal>pkiz</literal> tokens can be validated offline, without making HTTP
                        calls to keystone. However, this format requires that certificates be
                        installed and distributed to facilitate signing tokens and later validating
                        those signatures.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Fernet</term>
            <listitem>
              <para><literal>fernet</literal> tokens do not need to be persisted at all, but require that you run
                        <literal>keystone-manage fernet_setup</literal> (also see the
                        <literal>keystone-manage fernet_rotate</literal> command).</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <warning>
          <para>UUID, PKI, PKIZ, and Fernet tokens are all bearer tokens. They
                must be protected from unnecessary disclosure to prevent unauthorized
                access.</para>
        </warning>
      </section>
      <section xml:id="federated-identity" xml:base="federated-identity">
        <title>Federated Identity</title>
        <para>You can use federation for keystone in two ways:</para>
        <itemizedlist>
          <listitem>
            <para>Supporting keystone as a SP (service provider) consuming identity
                    assertions issued by an external Identity Provider, such as SAML
                    assertions or OpenID Connect claims.</para>
          </listitem>
          <listitem>
            <para>Supporting keystone as an IdP (Identity Provider) fulfilling
                    authentication requests on behalf of Service Providers.</para>
            <note>
              <para>It is also possible to have one keystone act as an SP that
                        consumes Identity from another keystone acting as an IdP.</para>
            </note>
          </listitem>
        </itemizedlist>
        <para>There is currently support for two major federation protocols:</para>
        <itemizedlist>
          <listitem>
            <para>
              <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://en.wikipedia.org/wiki/SAML_2.0">SAML</link>
            </para>
          </listitem>
          <listitem>
            <para>
              <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://en.wikipedia.org/wiki/OpenID_Connect">OpenID Connect</link>
            </para>
          </listitem>
        </itemizedlist>
        <figure>
          <title>Keystone federation</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="keystone-federation.png" width="100%"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="keystone-federation.png" width="100%"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>To enable federation:</para>
        <procedure>
          <step>
            <para>Run keystone under Apache. See <link xlink:href="https://docs.openstack.org/ocata/install-guide-obs/keystone-install.html#configure-the-apache-http-server">Configure the Apache HTTP server</link></para>
            <note>
              <para>Other application servers, such as <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://www.nginx.com/resources/wiki">nginx</link>,
                        have support for federation extensions that may work but are not tested
                        by the community.</para>
            </note>
          </step>
          <step>
            <para>Configure Apache to use a federation capable module.
                    We recommend Shibboleth, see <link xlink:href="https://docs.openstack.org/keystone/pike/advanced-topics/federation/shibboleth.html">the Shibboleth documentation</link>
                    for more information.</para>
            <note>
              <para>Another option is <literal>mod_auth_melon</literal>, see <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="https://github.com/UNINETT/mod_auth_mellon">the mod’s github repo</link>
                        for more information.</para>
            </note>
          </step>
          <step>
            <para>Configure federation in keystone.</para>
          </step>
        </procedure>
        <note>
          <para>The external IdP is responsible for authenticating users and communicates
                the result of authentication to keystone using authentication assertions.
                Keystone maps these values to keystone user groups and assignments
                created in keystone.</para>
        </note>
        <section xml:id="supporting-keystone-as-a-sp">
          <title>Supporting keystone as a SP</title>
          <para>To have keystone as an SP, you will need to configure
                keystone to accept assertions from external IdPs. Examples of external
                IdPs are:</para>
          <itemizedlist>
            <listitem>
              <para>ADFS (Active Directory Federation Services)</para>
            </listitem>
            <listitem>
              <para>FreeIPA</para>
            </listitem>
            <listitem>
              <para>Tivoli Access Manager</para>
            </listitem>
            <listitem>
              <para>Keystone</para>
            </listitem>
          </itemizedlist>
          <section xml:id="configuring-federation-in-keystone">
            <title>Configuring federation in keystone</title>
            <procedure>
              <step>
                <para>Configure authentication drivers in <literal>keystone.conf</literal> by adding the
                            authentication methods to the <literal>[auth]</literal> section in <literal>keystone.conf</literal>.
                            Ensure the names are the same as to the protocol names added via Identity
                            API v3.</para>
                <para>For example:</para>
                <screen language="ini">[auth]
methods = external,password,token,mapped,openid</screen>
                <note>
                  <para><literal>mapped</literal> and <literal>openid</literal> are the federation specific drivers.
                                The other names in the example are not related to federation.</para>
                </note>
              </step>
              <step>
                <para>Create local keystone groups and assign roles.</para>
                <important>
                  <para>The keystone requires group-based role assignments to authorize
                                federated users. The federation mapping engine maps federated users into
                                local user groups, which are the actors in keystone’s role assignments.</para>
                </important>
              </step>
              <step>
                <para>Create an IdP object in keystone. The object must represent the
                            IdP you will use to authenticate end users:</para>
                <screen>PUT /OS-FEDERATION/identity_providers/{idp_id}</screen>
                <para>More configuration information for IdPs can be found <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#register-an-identity-provider">Register an Identity Provider</link>.</para>
              </step>
              <step>
                <para>Add mapping rules:</para>
                <screen>PUT /OS-FEDERATION/mappings/{mapping_id}</screen>
                <para>More configuration information for mapping rules can be found <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#create-a-mapping">Create a mapping</link>.</para>
                <note>
                  <para>The only keystone API objects that support mapping are groups and users.</para>
                </note>
              </step>
              <step>
                <para>Add a protocol object and specify the mapping ID you want to use with the
                            combination of the IdP and protocol:</para>
                <screen>PUT /OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}</screen>
                <para>More configuration information for protocols can be found <link xlink:href="https://developer.openstack.org/api-ref/identity/v3-ext/#add-protocol-to-identity-provider">Add a protocol and attribute mapping to an identity provider</link>.</para>
              </step>
            </procedure>
          </section>
          <section xml:id="performing-federated-authentication">
            <title>Performing federated authentication</title>
            <procedure>
              <step>
                <para>Authenticate externally and generate an unscoped token in keystone:</para>
                <note>
                  <para>Unlike other authentication methods in keystone, the user does
                                not issue an HTTP POST request with authentication data in the request body.
                                To start federated authentication a user must access the dedicated URL with
                                IdP’s and orotocol’s identifiers stored within a protected URL.
                                The URL has a format of:
                                <literal>/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth</literal>.</para>
                </note>
                <screen>GET/POST /OS-FEDERATION/identity_providers/{identity_provider}/protocols/{protocol}/auth</screen>
              </step>
              <step>
                <para>Determine accessible resources. By using the previously returned token, the
                            user can issue requests to the list projects and domains that are
                            accessible.</para>
                <itemizedlist>
                  <listitem>
                    <para>List projects a federated user can access: <literal>GET /OS-FEDERATION/projects</literal></para>
                  </listitem>
                  <listitem>
                    <para>List domains a federated user can access: <literal>GET /OS-FEDERATION/domains</literal></para>
                  </listitem>
                </itemizedlist>
                <screen>GET /OS-FEDERATION/projects</screen>
              </step>
              <step>
                <para>Get a scoped token. A federated user can request a scoped token using
                            the unscoped token. A project or domain can be specified by either ID or
                            name. An ID is sufficient to uniquely identify a project or domain.</para>
                <screen>POST /auth/tokens</screen>
              </step>
            </procedure>
          </section>
        </section>
        <section xml:id="supporting-keystone-as-an-idp">
          <title>Supporting keystone as an IdP</title>
          <para>When acting as an IdP, the primary role of keystone is
                to issue assertions about users owned by keystone. This is done using PySAML2.</para>
          <section>
            <title>Configuring federation in keystone</title>
            <para>There are certain settings in <literal>keystone.conf</literal> that must be set up, prior
                    to attempting to federate multiple keystone deployments.</para>
            <procedure>
              <step>
                <para>Within <literal>keystone.conf</literal>, assign values to the <literal>[saml]</literal>
                            related fields, for example:</para>
                <screen>[saml]certfile=/etc/keystone/ssl/certs/ca.pemkeyfile=/etc/keystone/ssl/private/cakey.pemidp_entity_id=https://keystone.example.com/v3/OS-FEDERATION/saml2/idpidp_sso_endpoint=https://keystone.example.com/v3/OS-FEDERATION/saml2/ssoidp_metadata_path=/etc/keystone/saml2_idp_metadata.xml</screen>
              </step>
              <step>
                <para>We recommend the following <literal>Organization</literal> configuration options.
                            Ensure these values contain not special characters that may cause
                            problems as part of a URL:</para>
                <screen>idp_organization_name=example_companyidp_organization_display_name=Example Corp.idp_organization_url=example.com</screen>
              </step>
              <step>
                <para>As with the <literal>Organization</literal> options, the <literal>Contact</literal> options are not
                            necessary, but it is advisable to set these values:</para>
                <screen>idp_contact_company=example_companyidp_contact_name=Johnidp_contact_surname=Smithidp_contact_email=jsmith@example.comidp_contact_telephone=555-55-5555idp_contact_type=technical</screen>
              </step>
            </procedure>
          </section>
          <section xml:id="generate-metadata">
            <title>Generate metadata</title>
            <para>Metadata must be exchanged to create a trust between the IdP and the SP.</para>
            <procedure>
              <step>
                <para>Create metadata for your keystone IdP, run the <literal>keystone-manage</literal> command
                            and pipe the output to a file. For example:</para>
                <screen>$ keystone-manage saml_idp_metadata &gt; /etc/keystone/saml2_idp_metadata.xml</screen>
                <note>
                  <para>The file location must match the value of the <literal>idp_metadata_path</literal>
                                configuration option assigned previously.</para>
                </note>
              </step>
            </procedure>
          </section>
          <section xml:id="create-a-sp">
            <title>Create a SP</title>
            <para>To setup keystone-as-a-Service-Provider properly, you will need to
                    understand what protocols are supported by external IdPs.
                    For example, keystone as an SP can allow identities to federate in from a
                    ADFS IdP but it must be configured to understand the SAML v2.0 protocol.
                    ADFS issues assertions using SAML v2.0. Some examples
                    of federated protocols include:</para>
            <itemizedlist>
              <listitem>
                <para>SAML v2.0</para>
              </listitem>
              <listitem>
                <para>OpenID Connect</para>
              </listitem>
            </itemizedlist>
            <para>The following instructions are an example of how you can configure
                    keystone as an SP.</para>
            <procedure>
              <step>
                <para>Create a new SP with an ID of BETA.</para>
              </step>
              <step>
                <para>Create a <literal>sp_url</literal> of <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="http://beta.example.com/Shibboleth.sso/SAML2/ECP"/>.</para>
              </step>
              <step>
                <para>Create a <literal>auth_url</literal> of <link xmlns:xl="http://www.w3.org/1999/xlink" xl:href="http://beta.example.com:5000/v3/OS-FEDERATION/identity_providers/beta/protocols/saml2/auth"/>.</para>
                <note>
                  <para>Use the <literal>sp_url</literal> when creating a SAML assertion for BETA and signed by
                                the current keystone IdP. Use the <literal>auth_url</literal> when retrieving the token
                                for BETA once the SAML assertion is sent.</para>
                </note>
              </step>
              <step>
                <para>Set the <literal>enabled</literal> field to <literal>true</literal>. It is set to
                            <literal>false</literal> by default.</para>
              </step>
              <step>
                <para>Your output should reflect the following example:</para>
                <screen> $ curl -s -X PUT \
-H "X-Auth-Token: $OS_TOKEN"\
-H "Content-Type: application/json"\
-d '{"service_provider": {"auth_url": "http://beta.example.com:5000/v3/OS-FEDERATION/identity_providers/beta/protocols/saml2/auth", "sp_url": "https://example.com:5000/Shibboleth.sso/SAML2/ECP", "enabled": true}}'\
http://localhost:5000/v3/OS-FEDERATION/service_providers/BETA | python -mjson.tool</screen>
              </step>
            </procedure>
          </section>
        </section>
        <section xml:id="keystone-to-keystone">
          <title>keystone-to-keystone</title>
          <para>Keystone acting as an IdP is known as or k2k federation, where a keystone somewhere is acting as the SP
                and another keystone is acting as the IdP. All IdPs issue
                assertions about the identities it owns using a <literal>Protocol</literal>.</para>
        </section>
        <section xml:id="mapping-rules">
          <title>Mapping rules</title>
          <para>Mapping adds a set of rules to map federation attributes to keystone users
                or groups. An IdP has exactly one mapping specified per protocol.</para>
          <para>A mapping is a translation between assertions provided from an IdP and
                the permission and roles applied by an SP. Given an assertion from an IdP, an
                SP applies a mapping to translate attributes from the
                IdP to known roles. A mapping is typically
                owned by an SP.</para>
          <para>Mapping objects can be used multiple times by different combinations
                of IdP and protocol.</para>
          <para>A rule hierarchy is as follows:</para>
              <screen>
        {
         "rules": [
            {
                "local": [
                   {
                        "<replaceable>USER</replaceable> or <replaceable>GROUP</replaceable>"
                    }
                ],
                "remote": [
                    {
                        "<replaceable>CONDITION</replaceable>"
                    }
                ]
            }
        ]
    }
    </screen>
          <itemizedlist>
            <listitem>
              <para><literal>rules</literal>: top-level list of rules.</para>
            </listitem>
            <listitem>
              <para><literal>local</literal>: a rule containing information on what local attributes
                        will be mapped.</para>
            </listitem>
            <listitem>
              <para><literal>remote</literal>: a rule containing information on what remote attributes will
                        be mapped.</para>
            </listitem>
            <listitem>
              <para><literal>condition</literal>: contains information on conditions that allow a rule, can
                        only be set in a remote rule.</para>
            </listitem>
          </itemizedlist>
          <para>For more information on mapping rules, see <link xlink:href="https://docs.openstack.org/keystone/pike/advanced-topics/federation/mapping_combinations.html#mapping-rules">Mapping Rules</link>.</para>
          <section xml:id="mapping-creation">
            <title>Mapping creation</title>
            <para>Mapping creation starts with the communication between the IdP and SP.
                    The IdP usually provides a set of assertions that their users
                    have in their assertion document. The SP will have to map
                    those assertions to known groups and roles.
                    For example:</para>
       <screen>
          Identity Provider 1:
            name: jsmith
            groups: hacker
            other: <replaceable>ASSERTION INFORMATION</replaceable>
          The Service Provider may have 3 groups:
            Admin Group
            Developer Group
            User Group

          The mapping created by the Service Provider might look like:
            Local:
            Group: Developer Group
          Remote:
            Groups: hackers
      </screen>
            <para>The <literal>Developer Group</literal> may have a role assignment on the
                    <literal>Developer Project</literal>. When <literal>jsmith</literal> authenticates against IdP 1, it
                    presents that assertion to the SP.The SP maps the <literal>jsmith</literal> user to the
                    <literal>Developer Group</literal> because the assertion says <literal>jsmith</literal> is a member of
                    the <literal>hacker</literal> group.</para>
          </section>
          <section xml:id="mapping-examples">
            <title>Mapping examples</title>
            <para>A bare bones mapping is sufficient if you would like all federated users to
                    have the same authorization in the SP cloud. However, mapping is
                    quite powerful and flexible. You can map different remote
                    users into different user groups in keystone, limited only by the number of
                    assertions your IdP makes about each user.</para>
            <para>A mapping is composed of a list of rules, and each rule is further composed of
                    a list of remote attributes and a list of local attributes. If a rule is
                    matched, all of the local attributes are applied in the SP. For a
                    rule to match, all of the remote attributes it defines must match.</para>
            <para>In the base case, a federated user simply needs an assertion containing
                    an email address to be identified in the SP cloud. To achieve that, only
                    one rule is needed that requires the presence of one remote attribute:</para>
                                <screen>
                            {
                        "rules": [
                            {
                                "remote": [
                                    {
                                        "type": "Email"
                                    }
                                ],
                                "local": [
                                    {
                                        "user": {
                                            "name": "{0}"
                                        }
                                    }
                                ]
                            }
                        ]
                    }
                    </screen>
            <para>However, that is not particularly useful as the federated user would receive no
                    authorization. To rectify it, you can map all federated users with email
                    addresses into a <literal>federated-users</literal> group in the <literal>default</literal> domain. All
                    federated users will then be able to consume whatever role assignments that
                    user group has already received in keystone:</para>
            <note>
              <para>In this example, there is only one rule requiring one remote attribute.</para>
            </note>
                  <screen>
                {
        "rules": [
          {
              "remote": [
                  {
                      "type": "Email"
                  }
              ],
              "local": [
                  {
                      "user": {
                          "name": "{0}"
                      }
                  },
                  {
                      "group": {
                          "domain": {
                              "id": "0cd5e9"
                          },
                          "name": "federated-users"
                      }
                  }
              ]
          }
        ]
        }
      </screen>
            <para>This example can be expanded by adding a second rule that conveys
                    additional authorization to only a subset of federated users. Federated users
                    with a <literal>title</literal> attribute that matches either <literal>Manager</literal> or
                    <literal>Supervisor</literal> are granted the hypothetical <literal>observer</literal> role, which would
                    allow them to perform any read-only API call in the cloud:</para>
                  <screen>
        {
    "rules": [
        {
            "remote": [
                {
                    "type": "Email"
                },
            ],
            "local": [
                {
                    "user": {
                        "name": "{0}"
                    }
                },
                {
                    "group": {
                        "domain": {
                            "id": "default"
                        },
                        "name": "federated-users"
                    }
                }
            ]
        },
        {
            "remote": [
                {
                    "type": "Title",
                    "any_one_of": [".*Manager$", "Supervisor"],
                    "regex": "true"
                },
            ],
            "local": [
                {
                    "group": {
                        "domain": {
                            "id": "default"
                        },
                        "name": "observers"
                    }
                }
            ]
        }
    ]
}
      </screen>
            <note>
              <para><literal>any_one_of</literal> and <literal>regex</literal> in the rule above map federated users into
                        the <literal>observers</literal> group when a user’s <literal>Title</literal> assertion matches any of
                        the regular expressions specified in the <literal>any_one_of</literal> attribute.</para>
            </note>
            <para>Keystone also supports the following:</para>
            <itemizedlist>
              <listitem>
                <para><literal>not_any_of</literal>, matches any assertion that does not include one of
                            the specified values.</para>
              </listitem>
              <listitem>
                <para><literal>blacklist</literal>, matches all assertions of the specified type except
                            those included in the specified value.</para>
              </listitem>
              <listitem>
                <para><literal>whitelist</literal> does not match any assertion except those listed in the
                            specified value.</para>
              </listitem>
            </itemizedlist>
          </section>
        </section>
      </section>
      <section xml:id="credential-encryption" xml:base="identity-credential-encryption">
        <title>Credential Encryption</title>
        <para>As of the Newton release, keystone encrypts all credentials stored in the
            default <literal>sql</literal> backend. Credentials are encrypted with the same mechanism used
            to encrypt Fernet tokens, <literal>fernet</literal>. Keystone provides only one type of
            credential encryption but the encryption provider is pluggable in the event
            you wish to supply a custom implementation.</para>
        <para>This document details how credential encryption works, how to migrate existing
            credentials in a deployment, and how to manage encryption keys for credentials.</para>
        <section xml:id="configuring-credential-encryption">
          <title>Configuring credential encryption</title>
          <para>The configuration for credential encryption is straightforward. There are only
                two configuration options needed:</para>
          <screen language="ini">[credential]
provider = fernet
key_repository = /etc/keystone/credential-keys/</screen>
          <para><literal>[credential] provider</literal> defaults to the only option supplied by keystone,
                <literal>fernet</literal>. There is no reason to change this option unless you wish to provide
                a custom credential encryption implementation. The <literal>[credential]
key_repository</literal> location is a requirement of using <literal>fernet</literal> but will default
                to the <literal>/etc/keystone/credential-keys/</literal> directory. Both <literal>[credential]
key_repository</literal> and <literal>[fernet_tokens] key_repository</literal> define locations for
                keys used to encrypt things. One holds the keys to encrypt and decrypt
                credentials and the other holds keys to encrypt and decrypt tokens. It is
                imperative that these repositories are managed separately and they must not
                share keys. Meaning they cannot share the same directory path. The
                <literal>[credential] key_repository</literal> is only allowed to have three keys. This is not
                configurable and allows for credentials to be re-encrypted periodically with a
                new encryption key for the sake of security.</para>
        </section>
        <section xml:id="how-credential-encryption-works">
          <title>How credential encryption works</title>
          <para>The implementation of this feature did not change any existing credential API
                contracts. All changes are transparent to the user unless you’re inspecting the
                credential backend directly.</para>
          <para>When creating a credential, keystone will encrypt the <literal>blob</literal> attribute before
                persisting it to the backend. Keystone will also store a hash of the key that
                was used to encrypt the information in that credential. Since Fernet is used to
                encrypt credentials, a key repository consists of multiple keys. Keeping track
                of which key was used to encrypt each credential is an important part of
                encryption key management. Why this is important is detailed later in the
                <literal>Encryption key management</literal> section.</para>
          <para>When updating an existing credential’s <literal>blob</literal> attribute, keystone will encrypt
                the new <literal>blob</literal> and update the key hash.</para>
          <para>When listing or showing credentials, all <literal>blob</literal> attributes are decrypted in
                the response. Neither the cipher text, nor the hash of the key used to encrypt
                the <literal>blob</literal> are exposed through the API. Furthermore, the key is only used
                internally to keystone.</para>
        </section>
        <section xml:id="encrypting-existing-credentials">
          <title>Encrypting existing credentials</title>
          <para>When upgrading a Mitaka deployment to Newton, three database migrations will
                ensure all credentials are encrypted. The process is as follows:</para>
          <procedure>
            <step>
              <para>An additive schema change is made to create the new <literal>encrypted_blob</literal> and
                        <literal>key_hash</literal> columns in the existing <literal>credential</literal> table using
                        <literal>keystone-manage db_sync --expand</literal>.</para>
            </step>
            <step>
              <para>A data migration will loop through all existing credentials, encrypt each
                        <literal>blob</literal> and store the result in the new <literal>encrypted_blob</literal> column. The hash
                        of the key used is also written to the <literal>key_hash</literal> column for that specific
                        credential. This step is done using <literal>keystone-manage db_sync --migrate</literal>.</para>
            </step>
            <step>
              <para>A contractive schema will remove the <literal>blob</literal> column that held the plain
                        text representations of the credential using <literal>keystone-manage db_sync
--contract</literal>. This should only be done after all nodes in the deployment are
                        running Newton. If any Mitaka nodes are running after the database is
                        contracted, they won’t be able to read credentials since they are looking
                        for the <literal>blob</literal> column that no longer exists.</para>
            </step>
          </procedure>
          <note>
            <para>You may also use <literal>keystone-manage db_sync --check</literal> in order to check the
                    current status of your rolling upgrades.</para>
          </note>
          <para>If performing a rolling upgrade, please note that a limited service outage will
                take affect during this migration. When the migration is in place, credentials
                will become read-only until the database is contracted. After the contract
                phase is complete, credentials will be writeable to the backend. A
                <literal>[credential] key_repository</literal> location must be specified through
                configuration and bootstrapped with keys using <literal>keystone-manage
credential_setup</literal> prior to migrating any existing credentials. If a new key
                repository isn’t setup using <literal>keystone-manage credential_setup</literal> keystone will
                assume a null key to encrypt and decrypt credentials until a proper key
                repository is present. The null key is a key consisting of all null bytes and
                its only purpose is to ease the upgrade process from Mitaka to Newton. It is
                highly recommended that the null key isn’t used. It is no more secure than
                storing credentials in plain text. If the null key is used, you should migrate
                to a proper key repository using <literal>keystone-manage credential_setup</literal> and
                <literal>keystone-manage credential_migrate</literal>.</para>
        </section>
        <section xml:id="encryption-key-management">
          <title>Encryption key management</title>
          <para>Key management of <literal>[credential] key_repository</literal> is handled with three
                <literal>keystone-manage</literal> commands:</para>
          <procedure>
            <step>
              <para>
                <literal>keystone-manage credential_setup</literal>
              </para>
            </step>
            <step>
              <para>
                <literal>keystone-manage credential_rotate</literal>
              </para>
            </step>
            <step>
              <para>
                <literal>keystone-manage credential_migrate</literal>
              </para>
            </step>
          </procedure>
          <para><literal>keystone-manage credential_setup</literal> will populate <literal>[credential]
key_repository</literal> with new encryption keys. This must be done in order for
                proper credential encryption to work, with the exception of the null key. This
                step should only be done once.</para>
          <para><literal>keystone-manage credential_rotate</literal> will create and rotate a new encryption
                key in the <literal>[credential] key_repository</literal>. This will only be done if all
                credential key hashes match the hash of the current primary key. If any
                credential has been encrypted with an older key, or secondary key, the rotation
                will fail. Failing the rotation is necessary to prevent overrotation, which
                would leave some credentials indecipherable since the key used to encrypt it
                no longer exists. If this step fails, it is possible to forcibly re-key all
                credentials using the same primary key with <literal>keystone-manage
credential_migrate</literal>.</para>
          <para><literal>keystone-manage credential_migrate</literal> will check the backend for credentials
                whose key hash doesn’t match the hash of the current primary key. Any
                credentials with a key hash mismatching the current primary key will be
                re-encrypted with the current primary key. The new cipher text and key hash
                will be updated in the backend.</para>
        </section>
      </section>
    </section>
</chapter>
