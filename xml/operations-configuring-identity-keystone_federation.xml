<?xml version="1.0"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook51-profile.xsl"
 type="text/xml"
 title="Profiling step"?>
<!DOCTYPE section [
 <!ENTITY % entities SYSTEM "entities.ent"> %entities;
]>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="k2kfed">
 <title>Keystone-to-Keystone Federation</title>
 <para>
  This topic explains how you can use one instance of Keystone as an identity
  provider and one as a service provider.
 </para>
 <section>
  <title>What Is Keystone-to-Keystone Federation?</title>
  <para>
   Identity federation lets you configure &kw-hos; using existing identity
   management systems such as an LDAP directory as the source of user access
   authentication. The Keystone-to-Keystone federation (K2K) function extends
   this concept for accessing resources in multiple, separate &kw-hos; clouds.
   You can configure each cloud to trust the authentication credentials of
   other clouds to provide the ability for users to authenticate with their
   home cloud and to access authorized resources in another cloud without
   having to reauthenticate with the remote cloud. This function is sometimes
   referred to as "single sign-on" or SSO.
  </para>
  <para>
   The &kw-hos; cloud that provides the initial user authentication is called
   the identity provider (IdP). The identity provider cloud can support
   domain-based authentication against external authentication sources
   including LDAP-based directories such as Microsoft Active Directory. The
   identity provider creates the user attributes, known as assertions, which
   are used to automatically authenticate users with other &kw-hos; clouds.
  </para>
  <para>
   An &kw-hos; cloud that provides resources is called a service provider (SP).
   A service provider cloud accepts user authentication assertions from the
   identity provider and provides access to project resources based on the
   mapping file settings developed for each service provider cloud. The
   following are characteristics of a service provider:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Each service provider cloud has a unique set of projects, groups, and
     group role assignments that are created and managed locally.
    </para>
   </listitem>
   <listitem>
    <para>
     The mapping file consists a set of rules that define user group
     membership.
    </para>
   </listitem>
   <listitem>
    <para>
     The mapping file enables the ability to auto-assign incoming users to a
     specific group. Project membership and access are defined by group
     membership.
    </para>
   </listitem>
   <listitem>
    <para>
     Project quotas are defined locally by each service provider cloud.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Keystone-to-Keystone federation is supported and enabled in &kw-hos-phrase;
   using configuration parameters in specific Ansible files. Instructions are
   provided to define and enable the required configurations.
  </para>
  <para>
   Support for Keystone-to-Keystone federation happens on the API level, and
   you must implement it using your own client code by calling the supported
   APIs. Python-keystoneclient has supported APIs to access the K2K APIs.
  </para>
  <example xml:id="ex.k2kclient">
   <title>k2kclient.py</title>
   <para>
    The following k2kclient.py file is an example, and the request diagram
    <xref linkend="fig.keystone.authentication-flow"/> explains the flow of
    client requests.
   </para>
<screen language="python">import json
import os
import requests

import xml.dom.minidom

from keystoneclient.auth.identity import v3
from keystoneclient import session

class K2KClient(object):

    def __init__(self):
        # IdP auth URL
        self.auth_url = "http://192.168.245.9:35357/v3/"
        self.project_name = "admin"
        self.project_domain_name = "Default"
        self.username = "admin"
        self.password = "vvaQIZ1S"
        self.user_domain_name = "Default"
        self.session = requests.Session()
        self.verify = False
        # identity provider Id
        self.idp_id = "z420_idp"
        # service provider Id
        self.sp_id = "z620_sp"
        #self.sp_ecp_url = "https://16.103.149.44:8443/Shibboleth.sso/SAML2/ECP"
        #self.sp_auth_url = "https://16.103.149.44:8443/v3"

    def v3_authenticate(self):
        auth = v3.Password(auth_url=self.auth_url,
                           username=self.username,
                           password=self.password,
                           user_domain_name=self.user_domain_name,
                           project_name=self.project_name,
                           project_domain_name=self.project_domain_name)

        self.auth_session = session.Session(session=requests.session(),
                                       auth=auth, verify=self.verify)
        auth_ref = self.auth_session.auth.get_auth_ref(self.auth_session)
        self.token = self.auth_session.auth.get_token(self.auth_session)

    def _generate_token_json(self):
        return {
            "auth": {
                "identity": {
                    "methods": [
                        "token"
                    ],
                    "token": {
                        "id": self.token
                    }
                },
                "scope": {
                    "service_provider": {
                        "id": self.sp_id
                    }
                }
            }
        }

    def get_saml2_ecp_assertion(self):
        token = json.dumps(self._generate_token_json())
        url = self.auth_url + 'auth/OS-FEDERATION/saml2/ecp'
        r = self.session.post(url=url,
                              data=token,
                              verify=self.verify)
        if not r.ok:
            raise Exception("Something went wrong, %s" % r.__dict__)
        self.ecp_assertion = r.text

    def _get_sp_url(self):
        url = self.auth_url + 'OS-FEDERATION/service_providers/' + self.sp_id
        r = self.auth_session.get(
           url=url,
           verify=self.verify)
        if not r.ok:
            raise Exception("Something went wrong, %s" % r.__dict__)

        sp = json.loads(r.text)[u'service_provider']
        self.sp_ecp_url = sp[u'sp_url']
        self.sp_auth_url = sp[u'auth_url']

    def _handle_http_302_ecp_redirect(self, response, method, **kwargs):
        location = self.sp_auth_url + '/OS-FEDERATION/identity_providers/' + self.idp_id + '/protocols/saml2/auth'
        return self.auth_session.request(location, method, authenticated=False, **kwargs)

    def exchange_assertion(self):
        """Send assertion to a Keystone SP and get token."""
        self._get_sp_url()
        print("SP ECP Url:%s" % self.sp_ecp_url)
        print("SP Auth Url:%s" % self.sp_auth_url)
        #self.sp_ecp_url = 'https://16.103.149.44:8443/Shibboleth.sso/SAML2/ECP'
        r = self.auth_session.post(
            self.sp_ecp_url,
            headers={'Content-Type': 'application/vnd.paos+xml'},
            data=self.ecp_assertion,
            authenticated=False, redirect=False)
        r = self._handle_http_302_ecp_redirect(r, 'GET',
            headers={'Content-Type': 'application/vnd.paos+xml'})
        self.fed_token_id = r.headers['X-Subject-Token']
        self.fed_token = r.text

if __name__ == "__main__":
    client = K2KClient()
    client.v3_authenticate()
    client.get_saml2_ecp_assertion()
    client.exchange_assertion()
    print('Unscoped token_id: %s' % client.fed_token_id)
    print('Unscoped token body:
%s' % client.fed_token)</screen>
  </example>
 </section>
 <section>
  <title>Setting Up a &o_ident; Provider</title>
  <para>
   To set up Keystone as a service provider, follow these steps.
  </para>
  <orderedlist>
   <listitem>
    <para>
     Create a config file called <literal>k2k.yml</literal> with the following
     parameters and place it in any directory on your &lcm;, such
     as /tmp.
    </para>
<screen>keystone_trusted_idp: k2k
keystone_sp_conf:
  shib_sso_idp_entity_id: &lt;protocol&gt;://&lt;idp_host&gt;:&lt;port&gt;/v3/OS-FEDERATION/saml2/idp
  shib_sso_application_entity_id: http://service_provider_uri_entityId
  target_domain:
    name: domain1
    description: my domain
  target_project:
    name: project1
    description: my project
  target_group:
    name: group1
    description: my group
  role:
    name: service
  idp_metadata_file: /tmp/idp_metadata.xml
  identity_provider:
    id: my_idp_id
    description: This is the identity service provider.
  mapping:
    id: mapping1
    <emphasis role="bold">rules_file: /tmp/k2k_sp_mapping.json</emphasis>
  protocol:
    id: saml2
  attribute_map:
    -
      name: name1
      id: id1</screen>
    <para>
     The following are descriptions of each of the attributes.
    </para>
    <informaltable colsep="1" rowsep="1">
     <tgroup cols="2">
      <colspec colname="c1" colnum="1" colwidth="1.0*"/>
      <colspec colname="c2" colnum="2" colwidth="1.0*"/>
      <thead>
       <row>
        <entry> Attribute</entry>
        <entry>Definition</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>keystone_trusted_idp</entry>
        <entry>
         <para>
          A flag to indicate if this configuration is used for
          Keystone-to-Keystone or WebSSO. The value can be either k2k or adfs.
         </para>
        </entry>
       </row>
       <row>
        <entry><emphasis role="bold">keystone_sp_conf</emphasis>
        </entry>
        <entry/>
       </row>
       <row>
        <entry>shib_sso_idp_entity_id</entry>
        <entry>
         <para>
          The identity provider URI used as an entity Id to identity the IdP.
          You shoud use the following value:
          &lt;protocol&gt;://&lt;idp_host&gt;:&lt;port&gt;/v3/OS-FEDERATION/saml2/idp.
         </para>
        </entry>
       </row>
       <row>
        <entry>shib_sso_application_entity_id</entry>
        <entry>
         <para>
          The service provider URI used as an entity Id. It can be any URI here
          for Keystone-to-Keystone.
         </para>
        </entry>
       </row>
       <row>
        <entry>target_domain</entry>
        <entry>
         <para>
          A domain where the group will be created.
         </para>
        </entry>
       </row>
       <row>
        <entry>name</entry>
        <entry>
         <para>
          Any domain name. If it does not exist, it will be created or updated.
         </para>
        </entry>
       </row>
       <row>
        <entry>description</entry>
        <entry>
         <para>
          Any description.
         </para>
        </entry>
       </row>
       <row>
        <entry>target_project</entry>
        <entry>
         <para>
          A project scope of the group.
         </para>
        </entry>
       </row>
       <row>
        <entry>name</entry>
        <entry>
         <para>
          Any project name. If it does not exist, it will be created or
          updated.
         </para>
        </entry>
       </row>
       <row>
        <entry>description</entry>
        <entry>Any description. </entry>
       </row>
       <row>
        <entry>target_group</entry>
        <entry>
         <para>
          A group will be created from target_domain.
         </para>
        </entry>
       </row>
       <row>
        <entry>name</entry>
        <entry>
         <para>
          Any group name. If it does not exist, it will be created or updated.
         </para>
        </entry>
       </row>
       <row>
        <entry>description</entry>
        <entry>Any description. </entry>
       </row>
       <row>
        <entry>role</entry>
        <entry>
         <para>
          A role will be assigned on target_project. This role impacts the IdP
          user scoped token permission on the service provider side.
         </para>
        </entry>
       </row>
       <row>
        <entry>name</entry>
        <entry>Must be an existing role. </entry>
       </row>
       <row>
        <entry>idp_metadata_file</entry>
        <entry>
         <para>
          A reference to the IdP metadata file that validates the SAML2
          assertion.
         </para>
        </entry>
       </row>
       <row>
        <entry>identity_provider</entry>
        <entry>A supported IdP.</entry>
       </row>
       <row>
        <entry>id</entry>
        <entry>
         <para>
          Any Id. If it does not exist, it will be created or updated. This Id
          needs to be shared with the client so that the right mapping will be
          selected.
         </para>
        </entry>
       </row>
       <row>
        <entry>description</entry>
        <entry>Any description.</entry>
       </row>
       <row>
        <entry>mapping</entry>
        <entry>
         <para>
          A mapping in JSON format that maps a federated user to a
          corresponding group.
         </para>
        </entry>
       </row>
       <row>
        <entry>id</entry>
        <entry>
         <para>
          Any Id. If it does not exist, it will be created or updated.
         </para>
        </entry>
       </row>
       <row>
        <entry>rules_file</entry>
        <entry>
         <para>
          A reference to the file that has the mapping in JSON.
         </para>
        </entry>
       </row>
       <row>
        <entry>protocol</entry>
        <entry>
         <para>
          The supported federation protocol.
         </para>
        </entry>
       </row>
       <row>
        <entry>id</entry>
        <entry>
         <para>
          Security Assertion Markup Language 2.0 (SAML2) is the only supported
          protocol for K2K.
         </para>
        </entry>
       </row>
       <row>
        <entry>attribute_map</entry>
        <entry>
         <para>
          A shibboleth mapping that defines additional attributes to map the
          attributes from the SAML2 assertion to the K2K mapping that the
          service provider understands. K2K does not require any additional
          attribute mapping.
         </para>
        </entry>
       </row>
       <row>
        <entry>name</entry>
        <entry>An attribute name from the SAML2 assertion.</entry>
       </row>
       <row>
        <entry>id</entry>
        <entry>An Id that the preceding name will be mapped to.</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </listitem>
   <listitem>
    <para>
     Create a metadata file that is referenced from <literal>k2k.yml</literal>,
     such as <literal>/tmp/idp_metadata.xml</literal>. The content of the
     metadata file comes from the identity provider and can be found in
     <literal> /etc/keystone/idp_metadata.xml</literal>.
    </para>
    <orderedlist>
     <listitem>
      <para>
       Create a mapping file that is referenced in k2k.yml, shown previously.
       An example is <literal>/tmp/k2k_sp_mapping.json</literal>. You can see
       the reference in bold in the preceding k2k.yml example. The following is
       an example of the mapping file.
      </para>
<screen>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group1",
           "domain":{
             "name": "domain1"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://idp_host:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]           </screen>
      <para>
       You can find more information on how the K2K mapping works at
       <link xlink:href="http://docs.openstack.org"/>.
      </para>
     </listitem>
    </orderedlist>
   </listitem>
   <listitem>
    <para>
     Go to <literal>~/stack/scratch/ansible/next/ardana/ansible</literal> and
     run the following playbook to enable the service provider:
    </para>
<screen>&prompt.ardana;ansible-playbook -i hosts/verb_hosts keystone-reconfigure.yml -e@/tmp/k2k.yml</screen>
   </listitem>
  </orderedlist>
  <para>
   <emphasis role="bold"><emphasis role="bold">Setting Up an Identity
   Provider</emphasis></emphasis>
  </para>
  <para>
   To set up Keystone as an identity provider, follow these steps:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Create a config file <literal>k2k.yml</literal> with the following
     parameters and place it in any directory on your &lcm;, such
     as <literal>/tmp</literal>. Note that the certificate and key here are
     excerpted for space.
    </para>
<screen>keystone_k2k_idp_conf:
    service_provider:
          -
            id: my_sp_id
            description: This is service provider.
            sp_url: https://sp_host:5000
            auth_url: https://sp_host:5000/v3
    signer_cert: -----BEGIN CERTIFICATE-----
MIIDmDCCAoACCQDS+ZDoUfr
    cIzANBgkqhkiG9w0BAQsFADCBjDELMAkGA1UEBhMC\ nVVMxEzARBgNVB
    AgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCVN1bm55dmFsZTEMMAoG\
   <!---->
            ...
    nOpKEvhlMsl5I/tle
-----END CERTIFICATE-----
    signer_key: -----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEA1gRiHiwSO6L5PrtroHi/f17DQBOpJ1KMnS9FOHS
            <!---->
            ...
          </screen>
    <para>
     The following are descriptions of each of the attributes under
     keystone_k2k_idp_conf
    </para>
    <variablelist>
     <varlistentry>
      <term>service_provider</term>
      <listitem>
       <para>
        One or more service providers can be defined. If it does not exist, it
        will be created or updated.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>id</term>
      <listitem>
       <para>
        Any Id. If it does not exist, it will be created or updated. This Id
        needs to be shared with the client so that it knows where the service
        provider is.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>description</term>
      <listitem>
       <para>
        Any description.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>sp_url</term>
      <listitem>
       <para>
        Service provider base URL.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>auth_url</term>
      <listitem>
       <para>
        Service provider auth URL.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>signer_cert</term>
      <listitem>
       <para>
        Content of self-signed certificate that is embedded in the metadata
        file. We recommend setting the validity for a longer period of time,
        such as 3650 days (10 years).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>signer_key</term>
      <listitem>
       <para>
        A private key that has a key size of 2048 bits.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </listitem>
   <listitem>
    <para>
     Create a private key and a self-signed certificate. The command-line tool,
     openssl, is required to generate the keys and certificates. If the system
     does not have it, you must install it.
    </para>
    <orderedlist>
     <listitem>
      <para>
       Create a private key of size 2048.
      </para>
<screen>&prompt.ardana;openssl genrsa -out myidp.key 2048</screen>
     </listitem>
     <listitem>
      <para>
       Generate a certificate request named myidp.csr. When prompted, choose
       CommonName for the server's hostname.
      </para>
<screen>&prompt.ardana;openssl req -new -key myidp.key -out myidp.csr</screen>
     </listitem>
     <listitem>
      <para>
       Generate a self-signed certificate named myidp.cer.
      </para>
<screen>&prompt.ardana;openssl x509 -req -days 3650 -in myidp.csr -signkey myidp.key -out myidp.cer</screen>
     </listitem>
    </orderedlist>
   </listitem>
   <listitem>
    <para>
     Go to <literal>~/scratch/ansible/next/ardana/ansible</literal> and
     run the following playbook to enable the service provider in Keystone:
    </para>
<screen>&prompt.ardana;ansible-playbook -i hosts/verb_hosts keystone-reconfigure.yml -e@/tmp/k2k.yml</screen>
   </listitem>
  </orderedlist>
 </section>
 <section>
  <title>Test It Out</title>
  <para>
   You can use the script listed earlier, <literal>k2kclient.py</literal>
   (<xref linkend="ex.k2kclient"/>), as an example for the end-to-end flows. To run
   <literal>k2kclient.py</literal>, follow these steps:
  </para>
  <orderedlist>
   <listitem>
    <para>
     A few parameters must be changed in the beginning of
     <literal>k2kclient.py</literal>. For example, enter your specific URL,
     project name, and user name, as follows:
    </para>
<screen># IdP auth URL
self.auth_url = "http://idp_host:5000/v3/"
self.project_name = "my_project_name"
self.project_domain_name = "my_project_domain_name"
self.username = "test"
self.password = "mypass"
self.user_domain_name = "my_domain"
# identity provider Id that is defined in the SP config
self.idp_id = "my_idp_id"
# service provider Id that is defined in the IdP config
self.sp_id = "my_sp_id"</screen>
   </listitem>
   <listitem>
    <para>
     Install python-keystoneclient along with its dependencies.
    </para>
   </listitem>
   <listitem>
    <para>
     Run the <literal>k2kclient.py</literal> script. An unscoped token will be
     returned from the service provider.
    </para>
   </listitem>
  </orderedlist>
  <para>
   At this point, the domain or project scope of the unscoped taken can be
   discovered by sending the following URLs:
  </para>
<screen>&prompt.ardana;curl -k -X GET -H "X-Auth-Token: <replaceable>unscoped token</replaceable>" \
 https://&lt;sp_public_endpoint&gt;:5000/v3/OS-FEDERATION/domains
&prompt.ardana;curl -k -X GET -H "X-Auth-Token: <replaceable>unscoped token</replaceable>" \
 https://&lt;sp_public_endpoint:5000/v3/OS-FEDERATION/projects</screen>
 </section>
 <section>
  <title>Inside Keystone-to-Keystone Federation</title>
  <para>
   K2K federation places a lot of responsibility with the user. The complexity
   is apparent from the following diagram.
  </para>
  <orderedlist>
   <listitem>
    <para>
     Users must first authenticate to their home or local cloud, or local
     identity provider Keystone instance to obtain a scoped token.
    </para>
   </listitem>
   <listitem>
    <para>
     Users must discover which service providers (or remote clouds) are
     available to them by querying their local cloud.
    </para>
   </listitem>
   <listitem>
    <para>
     For a given remote cloud, users must discover which resources are
     available to them by querying the remote cloud for the projects they can
     scope to.
    </para>
   </listitem>
   <listitem>
    <para>
     To talk to the remote cloud, users must first exchange, with the local
     cloud, their locally scoped token for a SAML2 assertion to present to the
     remote cloud.
    </para>
   </listitem>
   <listitem>
    <para>
     Users then present the SAML2 assertion to the remote cloud. The remote
     cloud applies its mapping for the incoming SAML2 assertion to map each
     user to a local ephemeral persona (such as groups) and issues an unscoped
     token.
    </para>
   </listitem>
   <listitem>
    <para>
     Users query the remote cloud for the list of projects they have access to.
    </para>
   </listitem>
   <listitem>
    <para>
     Users then rescope their token to a given project.
    </para>
   </listitem>
   <listitem>
    <para>
     Users now have access to the resources owned by the project.
    </para>
   </listitem>
  </orderedlist>
  <para>
   The following diagram illustrates the flow of authentication requests.
  </para>
  <figure xml:id="fig.keystone.authentication-flow">
   <title>Keystone Authentication Flow</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="media-keystone-Keystone-2-Keystone-Sequence-Generic.png" width="75%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="media-keystone-Keystone-2-Keystone-Sequence-Generic.png"/>
    </imageobject>
   </mediaobject>
  </figure>
 </section>
 <section>
  <title>Additional Testing Scenarios</title>
  <para>
   The following tests assume one identity provider and one service provider.
  </para>
  <para>
   <emphasis role="bold">Test Case 1: Any federated user in the identity
   provider maps to a single designated group in the service
   provider</emphasis>
  </para>
  <orderedlist>
   <listitem>
    <para>
     On the identity provider side:
    </para>
<screen>hostname=myidp.com
username=user1</screen>
   </listitem>
   <listitem>
    <para>
     On the service provider side:
    </para>
<screen>group=group1
group_domain_name=domain1
'group1' scopes to 'project1'</screen>
   </listitem>
   <listitem>
    <para>
     Mapping used:
    </para>
<screen>testcase1_1.json</screen>
    <para>
     testcase1_1.json
    </para>
<screen>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group1",
           "domain":{
             "name": "domain1"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]</screen>
   </listitem>
   <listitem>
    <para>
     Expected result: The federated user will scope to project1.
    </para>
   </listitem>
  </orderedlist>
  <para>
   <emphasis role="bold">Test Case 2: A federated user in a specific domain in
   the identity provider maps to two different groups in the service
   provider</emphasis>
  </para>
  <orderedlist>
   <listitem>
    <para>
     On the identity provider side:
    </para>
<screen>hostname=myidp.com
username=user1
user_domain_name=Default</screen>
   </listitem>
   <listitem>
    <para>
     On the service provider side:
    </para>
<screen>group=group1
group_domain_name=domain1
'group1' scopes to 'project1' group=group2
group_domain_name=domain2
'group2' scopes to 'project2'</screen>
   </listitem>
   <listitem>
    <para>
     Mapping used:
    </para>
<screen>testcase1_2.json</screen>
    <para>
     testcase1_2.json
    </para>
<screen>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group1",
           "domain":{
             "name": "domain1"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group2",
           "domain":{
             "name": "domain2"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "openstack_user_domain",
      "any_one_of": [
          "Default"
      ]
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]</screen>
   </listitem>
   <listitem>
    <para>
     Expected result: The federated user will scope to both project1 and
     project2.
    </para>
   </listitem>
  </orderedlist>
  <para>
   <emphasis role="bold">Test Case 3: A federated user with a specific project
   in the identity provider maps to a specific group in the service
   provider</emphasis>
  </para>
  <orderedlist>
   <listitem>
    <para>
     On the identity provider side:
    </para>
<screen>hostname=myidp.com
username=user4
user_project_name=test1</screen>
   </listitem>
   <listitem>
    <para>
     On the service provider side:
    </para>
<screen>group=group4
group_domain_name=domain4
'group4' scopes to 'project4'</screen>
   </listitem>
   <listitem>
    <para>
     Mapping used:
    </para>
<screen>testcase1_3.json</screen>
    <para>
     testcase1_3.json
    </para>
<screen>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group4",
           "domain":{
             "name": "domain4"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "openstack_project",
      "any_one_of": [
          "test1"
      ]
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   },
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group5",
           "domain":{
             "name": "domain5"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "openstack_roles",
      "not_any_of": [
          "_member_"
      ]
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]</screen>
   </listitem>
   <listitem>
    <para>
     Expected result: The federated user will scope to project4.
    </para>
   </listitem>
  </orderedlist>
  <para>
   <emphasis role="bold">Test Case 4: A federated user with a specific role in
   the identity provider maps to a specific group in the service
   provider</emphasis>
  </para>
  <orderedlist>
   <listitem>
    <para>
     On the identity provider side:
    </para>
<screen>hostname=myidp.com, username=user5, role_name=_member_</screen>
   </listitem>
   <listitem>
    <para>
     On the service provider side:
    </para>
<screen>group=group5, group_domain_name=domain5, 'group5' scopes to 'project5'</screen>
   </listitem>
   <listitem>
    <para>
     Mapping used:
    </para>
<screen>testcase1_3.json</screen>
    <para>
     testcase1_3.json
    </para>
<screen>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group4",
           "domain":{
             "name": "domain4"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "openstack_project",
      "any_one_of": [
          "test1"
      ]
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   },
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group5",
           "domain":{
             "name": "domain5"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "openstack_roles",
      "not_any_of": [
          "_member_"
      ]
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]</screen>
   </listitem>
   <listitem>
    <para>
     Expected result: The federated user will scope to project5.
    </para>
   </listitem>
  </orderedlist>
  <para>
   <emphasis role="bold">Test Case 5: Retain the previous scope for a federated
   user</emphasis>
  </para>
  <orderedlist>
   <listitem>
    <para>
     On the identity provider side:
    </para>
<screen>hostname=myidp.com, username=user1, user_domain_name=Default</screen>
   </listitem>
   <listitem>
    <para>
     On the service provider side:
    </para>
<screen>group=group1, group_domain_name=domain1, 'group1' scopes to 'project1'</screen>
   </listitem>
   <listitem>
    <para>
     Mapping used:
    </para>
<screen>testcase1_1.json</screen>
    <para>
     testcase1_1.json
    </para>
<screen>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group1",
           "domain":{
             "name": "domain1"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]</screen>
   </listitem>
   <listitem>
    <para>
     Expected result: The federated user will scope to project1. Later, we
     would like to scope federated users who have the default domain in the
     identity provider to project2 in addition to project1.
    </para>
   </listitem>
   <listitem>
    <para>
     On the identity provider side:
    </para>
<screen>hostname=myidp.com, username=user1, user_domain_name=Default</screen>
   </listitem>
   <listitem>
    <para>
     On the service provider side:
    </para>
<screen>group=group1
group_domain_name=domain1
'group1' scopes to 'project1' group=group2
group_domain_name=domain2
'group2' scopes to 'project2'</screen>
   </listitem>
   <listitem>
    <para>
     Mapping used:
    </para>
<screen>testcase1_2.json</screen>
    <para>
     testcase1_2.json
    </para>
<screen>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group1",
           "domain":{
             "name": "domain1"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group2",
           "domain":{
             "name": "domain2"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "openstack_user_domain",
      "any_one_of": [
          "Default"
      ]
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]</screen>
   </listitem>
   <listitem>
    <para>
     Expected result: The federated user will scope to project1 and project2.
    </para>
   </listitem>
  </orderedlist>
  <para>
   <emphasis role="bold">Test Case 6: Scope a federated user to a domain
   </emphasis>
  </para>
  <orderedlist>
   <listitem>
    <para>
     On the identity provider side:
    </para>
<screen>hostname=myidp.com, username=user1</screen>
   </listitem>
   <listitem>
    <para>
     On the service provider side:
    </para>
<screen>group=group1, group_domain_name=domain1, 'group1' scopes to 'project1'</screen>
   </listitem>
   <listitem>
    <para>
     Mapping used:
    </para>
<screen>testcase1_1.json</screen>
    <para>
     testcase1_1.json
    </para>
<screen>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group1",
           "domain":{
             "name": "domain1"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]</screen>
   </listitem>
   <listitem>
    <para>
     Expected result:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       The federated user will scope to project1.
      </para>
     </listitem>
     <listitem>
      <para>
       User uses CLI/Curl to assign any existing role to group1 on domain1.
      </para>
     </listitem>
     <listitem>
      <para>
       User uses CLI/Curl to remove project1 scope from group1.
      </para>
     </listitem>
    </itemizedlist>
   </listitem>
   <listitem>
    <para>
     Final result: The federated user will scope to domain1.
    </para>
   </listitem>
  </orderedlist>
  <para>
   <emphasis role="bold">Test Case 7: Test five remote attributes for mapping
   </emphasis>
  </para>
  <orderedlist>
   <listitem>
    <para>
     Test all five different remote attributes, as follows, with similar test
     cases as noted previously.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       openstack_user
      </para>
     </listitem>
     <listitem>
      <para>
       openstack_user_domain
      </para>
     </listitem>
     <listitem>
      <para>
       openstack_roles
      </para>
     </listitem>
     <listitem>
      <para>
       openstack_project
      </para>
     </listitem>
     <listitem>
      <para>
       openstack_project_domain
      </para>
     </listitem>
    </itemizedlist>
    <para>
     The attribute openstack_user does not make much sense for testing because
     it is mapped only to a specific username. The preceding test cases have
     already covered the attributes openstack_user_domain, openstack_roles, and
     openstack_project.
    </para>
   </listitem>
  </orderedlist>
  <para>
    Note that similar tests have also been run for two identity providers with
    one service provider, and for one identity provider with two service
    providers.
  </para>
 </section>
 <section>
  <title>Known Issues and Limitations</title>
  <para>
   Keep the following points in mind:
  </para>
  <itemizedlist xml:id="idg-all-operations-configuring-identity-keystone_federation-xml-14">
   <listitem>
    <para>
     When a user is disabled in the identity provider, the issued federated
     token from the service provider still remains valid until the token is
     expired based on the Keystone expiration setting.
    </para>
   </listitem>
   <listitem>
    <para>
     An already issued federated token will retain its scope until its
     expiration. Any changes in the mapping on the service provider will not
     impact the scope of an already issued federated token. For example, if an
     already issued federated token was mapped to group1 that has scope on
     project1, and mapping is changed to group2 that has scope on project2, the
     prevously issued federated token still has scope on project1.
    </para>
   </listitem>
   <listitem>
    <para>
     Access to service provider resources is provided only through the
     python-keystone CLI client or the Keystone API. No Horizon web interface
     support is currently available.
    </para>
   </listitem>
   <listitem>
    <para>
     Domains, projects, groups, roles, and quotas are created per the service
     provider cloud. Support for federated projects, groups, roles, and quotas
     is currently not available.
    </para>
   </listitem>
   <listitem>
    <para>
     Keystone-to-Keystone federation and WebSSO cannot be configured by putting
     both sets of configuration attributes in the same config file; they will
     overwrite each other. Consequently, they need to be configured
     individually.
    </para>
   </listitem>
   <listitem>
    <para>
     Scoping the federated user to a domain is not supported by default in the
     playbook. Please follow the steps at <xref linkend="scopeToDomain"/>.
    </para>
   </listitem>
  </itemizedlist>
 </section>
<section xml:id="scopeToDomain">
<!-- FIXME: Couldn't figure out a way to use the original orderedlist as xml:id
to create a title for the xref linkend. -->
<title>Scope Federated User to Domain</title>
<para>
Use the following steps to scope a federated user to a domain:
</para>
  <orderedlist>
   <listitem>
    <para>
     On the IdP side, set <literal>hostname=myidp.com</literal> and
     <literal>username=user1</literal>.
    </para>
   </listitem>
   <listitem>
    <para>
     On the service provider side, set: <literal>group=group1</literal>,
     <literal>group_domain_name=domain1</literal>, group1 scopes to project1.
    </para>
   </listitem>
   <listitem>
    <para>
     Mapping used: testcase1_1.json.
    </para>
    <para>
     testcase1_1.json
    </para>
<screen>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group1",
           "domain":{
             "name": "domain1"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://myidp.com:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]</screen>
   </listitem>
   <listitem>
    <para>
     Expected result: The federated user will scope to project1. Use CLI/Curl
     to assign any existing role to group1 on domain1. Use CLI/Curl to remove
     project1 scope from group1.
    </para>
   </listitem>
   <listitem>
    <para>
     Result: The federated user will scope to domain1.
    </para>
   </listitem>
  </orderedlist>
</section>
</section>
