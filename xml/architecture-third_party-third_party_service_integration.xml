<?xml version="1.0"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook51-profile.xsl"
 type="text/xml"
 title="Profiling step"?>
<!DOCTYPE section [
 <!ENTITY % entities SYSTEM "entity-decl.ent"> %entities;
]>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="third_party_service_integration">
 <title>Third-party Service Integration</title>
 <para>
  This documentation details the support &product; provides for the
  integration of 3rd-party components with a &productname; platform deployment,
  whether that is a completely separate service or a plugin/driver to an
  existing service in the &productname; stack. The 3rd-party mechanism supports
  the integration of a range of different types of content..
 </para>
 <section xml:id="d1e13">
  <title>Introduction</title>
  <para>
   &productname; provides great flexibility when deploying your cloud, including:
  </para>
  <orderedlist>
   <listitem>
    <para>
     The ability to subset the services or service components to be deployed.
    </para>
   </listitem>
   <listitem>
    <para>
     Control of the distribution of services across the control plane and the
     rest of the cloud.
    </para>
   </listitem>
   <listitem>
    <para>
     Network topology definition.
    </para>
   </listitem>
   <listitem>
    <para>
     Disk layout specification.
    </para>
   </listitem>
   <listitem>
    <para>
     Customization using configuration files.
    </para>
   </listitem>
  </orderedlist>
  <para>
   &product; extends this flexibility by supporting the integration of
   3rd-party components with a &productname; platform deployment, whether that is a
   completely separate service or a plugin/driver to an existing service in the
   &productname; stack. The 3rd-party mechanism supports the integration of a range
   of different types of content:
  </para>
  <orderedlist>
   <listitem>
    <para>
     <emphasis role="bold">Packages:</emphasis> Addition of 3rd-party packages
     not available in &productname; repos onto a separate repo on the
     &lcm; node. After import, these packages are automatically available for
     installation on any target cloud node.
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis role="bold">Python venv content:</emphasis> &productname; services
     are deployed as separate python virtual environments (venvs). The
     third-party mechanism supports the import of 3rd-party python code for two
     use cases:
    </para>
    <orderedlist>
     <listitem>
      <para>
       The patching of an existing &productname; venv, e.g. adding a plugin to the
       &productname; neutron venv.
      </para>
     </listitem>
     <listitem>
      <para>
       Creation of a new venv, where this venv can optionally be derived from
       an existing &productname; venv.
      </para>
     </listitem>
    </orderedlist>
   </listitem>
   <listitem>
    <para>
     <emphasis role="bold">Service Definitions:</emphasis> &productname; services
     and service components are defined in a series of yaml files, which
     describe various aspects of a service, such as endpoints (VIP and
     otherwise), relationships with other services (e.g. requires rabbitmq) and
     whether creds need to be allocated . This data is ultimately used to
     generate Ansible variables for consumption by the playbooks. The 3rd-party
     mechanism allows for the definition of new services or service components,
     where relationships between each other and with &productname;-supplied services
     can be defined. These service definitions will be processed along with the
     set of &productname; service definitions to produce Ansible vars, which can be
     utilised by imported 3rd-party Ansible playbooks.<emphasis role="bold">
     </emphasis>
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis role="bold">Ansible:</emphasis> Addition of third-party playbook
     and roles for the deployment and configuration of third-party components.
     These playbooks can be integrated with all of the standard &lcm;
     lifecycle operations, such as deployment, upgrade and
     reconfiguration.
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis role="bold">Other application content:</emphasis><phrase> A
     third-party service integration may require additional content to be
     deployed to a node, where that content is not packaged as a deb/rpm, or
     the content is not a python plugin to be patched in an existing &productname;
     service venv or python code for a new venv. &lcm;
     provides a generic mechanism for packaging such content and delivering it
     to target nodes (coupled with the use of &lcm; Ansible
     modules in the 3rd-party Ansible playbooks). For example, this mechanism
     can be used to deliver a Java-based application to target cloud
     nodes.</phrase><emphasis role="bold"> </emphasis>
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis role="bold">Centralized Logging profiles</emphasis>: Third-party
     services log files can be added to the centralised logging service
     provided by &productname;. This service also manages the logrorate policy for
     services that register with it. To configure your third-party service with
     centralised logging, a logging profile must be
     added.<emphasis role="bold"> </emphasis>
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis role="bold">&productname; service configuration:</emphasis> Some
     &productname; services (currently, just Neutron) provide an interface for
     injecting 3rd-party customisations of the deployment of that service,
     which includes the addition of configuration data to certain selected
     configuration files.
    </para>
   </listitem>
  </orderedlist>
  <para>
   The import of any combination of the above content types can be used in
   support of a particular 3rd-party integration. The remainder of this
   document details the main steps for using the import mechanism and how each
   of the content types is prepared in advance of running the import.
  </para>
 </section>
 <section xml:id="d1e112">
  <title>Using the 3rd-party Import mechanism</title>
  <para>
   The &lcm; 3rd-party import mechanism allows the import of
   various types of content into the &productname; platform in advance of a
   deployment. In the general use case, the 3rd-party content is imported after
   the &lcm; has been initialised (i.e. after
   <filename>hos-init.bash</filename> has been executed). The general procedure
   for importing 3rd-party content is as follows:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Ensure that the &lcm; has been initialised:
    </para>
<screen>~/hos-4.0.0/hos-init.bash</screen>
   </listitem>
   <listitem>
    <para>
     Prepare 3rd-party content for import on the deployer.
    </para>
    <orderedlist>
     <listitem>
      <para>
       Create a top-level directory on the &lcm; under
       <filename>~/third-party</filename> and create sub-directories under that,
       according to the different third-party content being imported, e.g.:
      </para>
<screen>third-party/
└── myservice
    ├── ansible
    ├── logging
    ├── other
    ├── pkgs
    ├── services
    └── venvs</screen>
     </listitem>
     <listitem>
      <para>
       Populate each sub-directory with your 3rd-party content; details on the
       layout for each content type are detailed below.Note that the
       third-party area can also be populated with &productname; extensions content
       shipped with &productname;, e.g. for a &productname;-DCN deployment:
      </para>
<screen>cp -r ~/openstack/ardana_extensions/dcn ~/third-party/</screen>
      <para>
       <emphasis role="bold">Note:</emphasis> Additional content (outside of
       that provided with &productname; extensions) must be added to the third-party
       area for a &productname;-DCN deployment. <phrase> </phrase>
      </para>
     </listitem>
    </orderedlist>
   </listitem>
   <listitem>
    <para>
     Run the 3rd-party import playbook:
    </para>
<screen>cd ~/openstack/ardana/ansible/
ansible-playbook -i hosts/localhost third-party-import.yml</screen>
    <orderedlist>
     <listitem>
      <para>
       Note that RHEL artefacts (rpms or any updates against RHEL venvs –
       &productname; provides a different set of service venvs for &slsa; and RHEL)
       are not imported by default. If this is required, run the
       third-party-import playbook as follows:
      </para>
<screen>cd ~/openstack/ardana/ansible/
ansible-playbook -i hosts/localhost third-party-import.yml -e third_party_rhel_enabled</screen>
     </listitem>
    </orderedlist>
   </listitem>
   <listitem>
    <para>
     Proceed with the cloud deployment as per normal:
    </para>
    <orderedlist>
     <listitem>
      <para>
       Prepare configuration input files to describe your target cloud (which
       may include references to imported 3rd-party services) and commit those
       changes via git.
      </para>
     </listitem>
     <listitem>
      <para>
       Provision your baremetal nodes.
      </para>
     </listitem>
     <listitem>
      <para>
       Run the configuration processor:
      </para>
<screen>cd ~/openstack/ardana/ansible/
ansible-playbook -i hosts/localhost config-processor-run.yml -e encrypt="" -e rekey=""</screen>
     </listitem>
     <listitem>
      <para>
       Ready the deployment:
      </para>
<screen>ansible-playbook -i hosts/localhost ready-deployment.yml</screen>
     </listitem>
     <listitem>
      <para>
       Deploy your cloud (which now includes 3rd-party components):
      </para>
<screen>cd ~/scratch/ansible/next/ardana/ansible
ansible-playbook -i hosts/verb_hosts site.yml</screen>
     </listitem>
    </orderedlist>
   </listitem>
  </orderedlist>
  <para>
   The following sections provide details on how to supply the different types
   of third-party content for import. The following assumes that you have
   created a top-level directory (named according to your particular 3rd-party
   integration) under the third-party area on the deployer, e.g. as follows:
  </para>
<screen>third-party
└── myservice</screen>
  <para>
   Further sub-directories are created under the directory specific to a
   third-party integration, e.g. <filename>third-party/myservice</filename>,
   according to different types of content required.
  </para>
  <section xml:id="d1e272">
   <title>Debian/RHEL packages</title>
   <para>
    The third-party import mechanism supports the import of both Debian
    packages and RHEL packages, as shown in the diagram below:
   </para>
   <informalfigure>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="media-third_party-debian_rhel_import.png" width="75%"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="media-third_party-debian_rhel_import.png"/>
     </imageobject>
    </mediaobject>
   </informalfigure>
   <para>
    To prepare third-party packages for import, the following steps are
    required:
   </para>
   <orderedlist>
    <listitem>
     <para>
      Create a <filename>pkgs</filename> directory under your specific top-level
      third-party import directory, with further sub-directories, depending on
      the OS support required: <literal>debian </literal>or
      <literal>rhel.</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Populate the debian sub-directory with the full set of debian packages
      required for the third-party service, including any dependencies.
     </para>
    </listitem>
    <listitem>
     <para>
      Populate the rhel sub-directory with the full set of RHEL packages
      required for the third-party service, including any dependencies.
     </para>
    </listitem>
   </orderedlist>
   <para>
    A sample layout of third-party packages ready for import is shown below:
   </para>
<screen>third-party/myservice/pkgs
├── debian
│   ├── pkg1.deb
│   └── pkg2.deb
└── rhel
    ├── pkg1.rpm
    └── pkg2.rpm</screen>
   <para>
    The third-party-import playbook will scan for packages under all
    directories matching the pattern <literal>~/third/*/pkgs/debian</literal>
    or <literal>~/third/*/pkgs/rhel</literal> and populate the 3rd-party apt
    repo (separate to the base &productname; apt repo) with deb packages and
    populate the 3rd-party yum repo (separate to the &productname; yum repo, if
    present) with rpm packages. The third-party apt and yum repo packages will
    then be available for installation in subsequent deployments of cloud
    nodes, typically carried out by imported 3rd-party Ansible playbooks.
   </para>
  </section>
  <section xml:id="d1e329">
   <title>Venvs</title>
   <para>
    The third-party import mechanism supports both the patching of existing
    &productname; venvs and the creation of new venvs. An example of the patching of
    an existing &productname; neutron venv is illustrated below:
   </para>
   <informalfigure>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="media-third_party-hos_neutron_venv.png" width="75%"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="media-third_party-hos_neutron_venv.png"/>
     </imageobject>
    </mediaobject>
   </informalfigure>
   <para>
    To prepare content for the update or creation of a new venv, the following
    steps are required:
   </para>
   <orderedlist>
    <listitem>
     <para>
      Create an appropriately-named sub-directory under the venvs directory for
      each separate set of python content to be imported, e.g.
      <literal>pluginA</literal> or <literal>serviceA</literal> in the example
      below.
     </para>
    </listitem>
    <listitem>
     <para>
      For each of these sub-directories:
     </para>
     <orderedlist>
      <listitem>
       <para>
        Populate one or all of the debs, src or whls directories with the
        source content.
       </para>
      </listitem>
      <listitem>
       <para>
        Populate the pip-deps directory with any pip requirements, arising from
        the above.
       </para>
      </listitem>
      <listitem>
       <para>
        Create <filename>services.yml</filename>
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </orderedlist>
   <para>
    A sample directory layout for the patching of an existing &productname; venv
    with plugin code and for the creation of a new venv is as follows:
   </para>
<screen>third-party/myservice/venvs
├── pluginA
│   ├── debs
│   ├── pip-deps
│   ├── services.yml
│   ├── src
│   └── whls
└── serviceA
    ├── debs
    ├── pip-deps
    ├── services.yml
    ├── src
    └── whls</screen>
   <para>
    For both cases, the content provided can be in three forms, each placed in
    specifically named sub-directories:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold">debs:</emphasis> A set ot Debian packages
      containing python code, which will be extracted, converted into a wheel
      and installed into the destination venv.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold">src:</emphasis> A set of source tarballs, which are
      installed directly into the destination venv.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold">whls:</emphasis> A set of wheels, which are
      installed directly into the destination venv.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Python wheels are the preferred format for this content as they lower
    install time and have no install-time dependencies.
   </para>
   <para>
    For the above installations, additional pip dependencies may be required.
    The third-party import mechanism will scan the pip-deps sub-directory to
    satisfy such requirements.
   </para>
   <para>
    The nature of the destination venv referred to above depends on the
    services.yml file, which must be present. To patch an existing &productname;
    venv, such as neutron, the services.yml is defined as follows:
   </para>
<screen>services:
  - name: neutron</screen>
   <para>
    The result of this is to create a new Neutron venv, updated with content
    from the debs, src or whls (and pip-deps) directories. After the
    third-party import has been completed, subsequent calls to install the
    Neutron venv will install this updated venv rather than the original venv
    supplied with &productname;.
   </para>
   <para>
    An example services.yml for the creation of a new venv is as follows:
   </para>
<screen>services:
  - name: myserviceA
    parent: nova-client</screen>
   <para>
    In this case a new venv is created called "myserviceA", which is based off
    an existing &productname; nova-client venv. This additionally has content
    installed into it from the debs, src or whls directories. After the
    third-party import has been completed, this new venv is available for
    installation. Additional third-party playbooks will be required to install
    this venv.
   </para>
  </section>
  <section xml:id="d1e439">
   <title>Service Definitions</title>
   <para>
    To deploy a cloud with &lcm;, the cloud operator must
    prepare an input model that describes the cloud configuration in terms of
    which services (OpenStack and supporting) run on which server nodes, how
    sets of server nodes are configured in terms of network configuration and
    disk layout, the overall network layout and much more (find an overview
    of the input model in <xref linkend="cha.input-model-intro-concept"/>).
    The input model refers to a <literal>service</literal>, where a service
    is defined a collection of <literal>service-components</literal> that
    provide a particular feature; for example nova provides the compute
    service and consists of the following service-components: nova-api,
    nova-scheduler, nova-conductor, nova-novncproxy, and nova-compute.
   </para>
   <para>
    A service may comprise of just one service-component, such as rabbitmq or
    mysql. A service-component represents the smallest unit of deployment for
    &lcm;. A cloud operator describes the desired cloud
    deployment in terms of the selection layout of service components across
    groups, known as <literal>clusters</literal>. A service and its constituent
    service components are typically defined in separate yaml files (Note: the
    convention is to use separate files for general readability and
    organization, but this is not strictly required); the full set of &productname;
    services and service components can be viewed on the &lcm; under the
    <filename>~/openstack/ardana/services</filename> directory. For example, the
    list of yaml files defining the nova service and its constituent
    service-components (in &product;) is as follows:
   </para>
<screen>~/openstack/ardana/services$ ls -l nova
total 60
-rw-r--r-- 1 stack stack 3301 Jul 13 07:41 api.yml
-rw-r--r-- 1 stack stack 1516 Jul 13 07:41 compute.yml
-rw-r--r-- 1 stack stack  767 Jul 13 07:41 conductor.yml
-rw-r--r-- 1 stack stack  716 Jul 13 07:41 console_auth.yml
-rw-r--r-- 1 stack stack  777 Jul 13 07:41 esx_compute_proxy.yml
-rw-r--r-- 1 stack stack  764 Jul 13 07:41 ironic_compute_proxy.yml
-rw-r--r-- 1 stack stack  809 Jul 13 07:41 ironic_compute.yml
-rw-r--r-- 1 stack stack  778 Jul 13 07:41 ironic_scheduler.yml
-rw-r--r-- 1 stack stack 1342 Jul 13 07:41 kvm_compute.yml
-rw-r--r-- 1 stack stack  769 Jul 13 07:41 new_esx_compute_proxy.yml
-rw-r--r-- 1 stack stack 1197 Jul 13 07:41 nova-client.yml
-rw-r--r-- 1 stack stack  813 Jul 13 07:41 nova-metadata.yml
-rw-r--r-- 1 stack stack 2907 Jul 13 07:41 nova.yml
-rw-r--r-- 1 stack stack 1002 Jul 13 07:41 novncproxy.yml
-rw-r--r-- 1 stack stack  767 Jul 13 07:41 scheduler.yml</screen>
   <para>
    The third-party import mechanism supports the import of third-party defined
    services and service components, as shown in the following diagram:
   </para>
   <informalfigure>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="media-third_party-import_mechanisms.png" width="75%"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="media-third_party-import_mechanisms.png"/>
     </imageobject>
    </mediaobject>
   </informalfigure>
   <para>
    To set up third-party services for import, place the set of yaml files
    under the services sub-directory, e.g.:
   </para>
<screen>third-party/myservice/services
└── serviceA
    ├── serviceA-client.yml
    ├── serviceA-plugin.yml
    ├── serviceA-server.yml
    └── serviceA.yml</screen>
   <para>
    When the third-party-import playbook has completed, the above third-party
    service definitions will have been added to the existing set of &productname;
    services under <filename>~/openstack/ardana/services</filelname> and committed to
    git (on the site branch). Here is a sample git log entry for the addition
    of a set of third-party service definitions:
   </para>
<screen>commit 21103bd725e3613b341d06dee9d3eed6ce0aafc7
Author: <replaceable>GIT_USER</replaceable> <replaceable>GIT_USER_EMAIL_ADDRESS</replaceable>
Date:   Wed Jul 13 09:46:19 2016 +0000
    Third-party services import</screen>
   <para>
    For details on the creation of the service definitions files, please refer
    to <xref linkend="third_party_integrations"/>.
   </para>
  </section>
  <section xml:id="d1e519">
   <title>Ansible Playbooks and Roles</title>
   <para>
    &lcm; supports the import of third-party Ansible
    playbooks roles, as illustrated in the following diagram:
   </para>
   <informalfigure>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="media-third_party-ansible_playbook_roles.png" width="75%"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="media-third_party-ansible_playbook_roles.png"/>
     </imageobject>
    </mediaobject>
   </informalfigure>
   <para>
    To prepare third-party Ansible content for import, carry out the following
    steps:
   </para>
   <orderedlist>
    <listitem>
     <!-- FIXME: Where is that guide? - sknorr, 2018-04-16 -->
     <para>
      Implement the set of playbooks and roles as described in
      <xref linkend="third_party_integrations"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <phrase>Add <literal>hooks</literal> for the integration third-party
      playbooks with &lcm; lifecycle operations.</phrase>
     </para>
    </listitem>
    <listitem>
     <para>
      <phrase>Create a symlinks yaml file to indicate which configuration files
      will be exposed for customer edit in the my_cloud/config area.</phrase>
     </para>
    </listitem>
    <listitem>
     <para>
      <phrase>Copy the full set of playbooks, roles, hooks and config dir to
      the <filename>ansible</filename> sub-directory for this particular
      integration. </phrase>
     </para>
    </listitem>
   </orderedlist>
   <para>
    <phrase>A sample layout of Ansible content ready for import is as
    follows:</phrase>
   </para>
<screen>.
├── config
│   └── myservice-symlinks.yml
├── hooks.d
│   └── myservice
│       ├── post-nova-deploy.yml
│       ├── post-nova-reconfigure.yml
│       ├── post-nova-stop.yml
│       └── pre-monasca-agent-deploy.yml
├── myservice-deploy.yml
├── myservice-reconfigure.yml
├── myservice-start.yml
├── myservice-stop.yml
└── roles
    ├── myservice-client
    │   ├── defaults
    │   │   └── main.yml
    │   └── tasks
    │       ├── configure.yml
    │       ├── install.yml
    │       ├── start.yml
    │       └── stop.yml
    ├── myservice-plugin
    │   ├── defaults
    │   │   └── main.yml
    │   └── tasks
    │       ├── configure.yml
    │       ├── install.yml
    │       ├── start.yml
    │       └── stop.yml
    └── myservice-server
        ├── defaults
        │   └── main.yml
        ├── tasks
        │   ├── configure.yml
        │   ├── install.yml
        │   ├── start.yml
        │   └── stop.yml
        └── templates
            └── server.conf.j2</screen>
   <para>
    <phrase>When the third-party-import playbook has completed, the above set
    of playbooks, roles and hooks are added to
    <filename>~/openstack/ardana/ansible</filename> on the &lcm; and
    committed to git (on the site branch).</phrase> Here is a sample git log
    entry representing the import of some third-party Ansible content:
   </para>
<screen>commit 9ca9b47f6d2840b48624ffa94fb6b8a072466811
Author: <replaceable>GIT_USER</replaceable> <replaceable>GIT_USER_EMAIL_ADDRESS</replaceable>
Date:   Wed Jul 13 09:46:21 2016 +0000
    Third-party Ansible import</screen>
   <para>
    For details on the implementation of ansible playbooks and roles for
    &lcm;, please refer to <xref linkend="third_party_integrations"/>.
   </para>
   <para>
    In addition to adding the set of third-party Ansible playbooks and roles,
    the third-party top-level playbooks must be integrated with top-level
    &lcm; playbooks for all supported lifecycle operations,
    such as deploy, upgrade and so on. The next section details how that is
    achieved. The final section on Ansible details how to set up symlinks for
    third-party configuration templates.
   </para>
   <section xml:id="d1e608">
    <title>&lcm; Ansible Hook Mechanism</title>
    <para>
     To fully integrate your third-party playbooks, you must use the
     &lcm; mechanism for <literal>hooking</literal> third-party
     playbooks into the major &lcm; lifecycle operations so
     that, for example, when a deployment is run, it includes your playbooks
     for deploying a third-party service. &lcm; supports the
     integration of third-party level playbooks with the following
     &lcm; lifecycle operations:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       deploy: ardana-deploy.yml (invoked via site.yml)
      </para>
     </listitem>
     <listitem>
      <para>
       reconfigure: ardana-reconfigure.yml
      </para>
     </listitem>
     <listitem>
      <para>
       upgrade: ardana-upgrade.yml
      </para>
     </listitem>
     <listitem>
      <para>
       start: ardana-start.yml
      </para>
     </listitem>
     <listitem>
      <para>
       status: ardana-status.yml
      </para>
     </listitem>
     <listitem>
      <para>
       stop: ardana-stop.yml
      </para>
     </listitem>
    </itemizedlist>
    <para>
     To hook into &lcm; lifecycle operations, you must
     define a set of hook playbooks under the hooks.d directory within your
     Ansible content, where those playbooks follow a specific naming
     convention:
    </para>
<screen>hooks.d/&lt;custom&gt;/pre-&lt;action&gt;.yml
hooks.d/&lt;custom&gt;/pre-&lt;service&gt;-&lt;action&gt;.yml
hooks.d/&lt;custom&gt;/post-&lt;service&gt;-&lt;action&gt;.yml
hooks.d/&lt;custom&gt;/post-&lt;action&gt;.yml</screen>
    <para>
     where:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <emphasis role="bold">custom: </emphasis> Any named directory under
       hooks.d for the placement of hook playbooks. Any duplicate hooks
       targeting the same action or service-action combination will be
       alphabetically sorted according to this name to determine the ultimate
       ordering.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis role="bold">action: </emphasis>Refers to the top-level
       operation that &lcm; is executing, e.g. deploy or
       reconfigure.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis role="bold">service: </emphasis>Refers to the name of a
       &productname; service as per its naming in the &lcm;
       top-level playbooks (ardana-deploy.yml, ardana-reconfigure.yml, etc.), e.g
       nova, glance, swift, etc.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     The set of hooks in the above sample Ansible content layout are:
    </para>
<screen>.
├── hooks.d
│   └── myservice
│       ├── post-nova-deploy.yml
│       ├── post-nova-reconfigure.yml
│       ├── post-nova-stop.yml
│       └── post-nova-start.yml</screen>
    <para>
     Based on the above, the <filename>post-nova-deploy.yml</filename> playbook
     will be invoked as part of a <filename>site.yml</filename> execution and is
     guaranteed to run after the <filename>nova-deploy.yml</filename> part of the
     overall run. Similarly, a run of <filename>ardana-reconfigure.yml</filename>
     will execute <filename>post-nova-reconfigure.yml</filename> after
     <filename>nova-reconfigure.yml</filename>.
    </para>
    <para>
     When the third-party-import playbook has completed, the full contents of
     the Ansible directory will be merged with the existing
     <filename>~/openstack/ardana/ansible</filename> area on the &lcm;. The
     Ansible hooks are not processed until the ready-deployment playbook has
     been run, after which the inclusion of the hooks will be apparent in the
     &lcm; playbooks in the scratch area, i.e. under
     <filename>/scratch/ansible/next/openstack/ardana</filename>. For example, from the
     above hooks specification, <filename>ardana-deploy.yml</filename> is rendered
     as follows:
    </para>
<screen># Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
# Top-level &lcm; deploy playbook
#
# Automatically managed by Ansible and will be overwritten on each
# deploy ready.
---
# Regather facts on all hosts in case of configuration changes that haven't
# been reflected in the fact cache
- include: ardana-refresh-facts.yml
- include: sosreport-deploy.yml
- include: upgrade-bootstrap.yml
# pre deploy Third party hooks
# deploy services and Third party hooks
# HLM-1259: when disabling the monasca part of the deployment,
# edit ~/.ansible.cfg and change the [default] / library setting
# as outlined in that file.
- include: monasca-agent-deploy.yml
- include: tls-deploy.yml
- include: clients-deploy.yml
- include: percona-deploy.yml
- include: rabbitmq-deploy.yml
- include: FND-CLU-deploy.yml
- include: FND-AP2-deploy.yml
- include: memcached-deploy.yml
- include: keystone-deploy.yml
- include: barbican-deploy.yml
- include: zookeeper-deploy.yml
- include: monasca-deploy.yml
- include: ardana-ux-services-deploy.yml
# ops console depends on kafka, installed by monasca
- include: ops-console-deploy.yml
- include: spark-deploy.yml
- include: monasca-transform-deploy.yml
- include: swift-deploy.yml
- include: glance-deploy.yml
- include: neutron-deploy.yml
- include: ironic-deploy.yml
- include: cmc-deploy.yml
- include: nova-deploy.yml
- include: hooks.d/myservice/post-nova-deploy.yml
- include: cinder-deploy.yml
- include: octavia-deploy.yml
- include: designate-deploy.yml
...</screen>
    <para>
     where the inclusion of
     <filename>hooks.d/myservice/post-nova-deploy.yml</filename> is after
     <filename>nova-deploy.yml</filename> Typically, these hook playbooks
     call out to other third-party playbooks, for example:
    </para>
<screen>&prompt.ardana;cd ~/scratch/ansible/next/ardana/ansible
&prompt.ardana;cat hooks.d/myservice/post-nova-deploy.yml
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# Post nova-deploy logic goes here, can include anothe playbook.

- include: "{{ playbook_dir }}/myservice-deploy.yml"</screen>
    <para>
     The net result is that the <literal>myservice</literal> deployment is
     carried out after nova has been deployed. Similarly, ardana-reconfigure.yml,
     ardana-upgrade.yml, ardana-start.yml and ardana-stop.yml are generated to contain
     any hooks, if they have been defined.
    </para>
   </section>
   <section xml:id="d1e719">
    <title>Configuration file symlinks</title>
    <para>
     In deploying &productname;, customers may want to modify some of the
     configuration files supplied by &productname;. To facilitate this, the
     <filename>~/openstack/my_cloud/config</filename> area on the &lcm;
     contains a set of symlinks to configuration file templates for the various
     services in &productname;. To customise, the customer edits these files
     directly and commits to git (see <xref linkend="using_git"/>) and those
     configuration changes will be persisted and used for all future
     deployments and upgrades.
    </para>
    <para>
     If you have third-party configuration templates that you would like to
     expose for customer modification in the same way, you must create a
     symlinks yaml definition and place it in a config directory in your
     ansible area, e.g. <filename>config/myservice-symlinks.yml</filename> as
     shown in the sample Ansible layout above. This yaml file is simply a list
     of paths to configuration templates to be mapped to the name that each
     will appear as in the <filename>~/openstack/my_cloud/config</filename> area.
     Configuration templates are typically grouped by service under
     <filename>~/openstack/my_cloud/config</filename>. A sample symlinks
     specification is as follows:
    </para>
<screen># (c) Copyright 2017 Hewlett Packard Enterprise Development LP
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
# The following relative symlinks are created under the
# my_cloud/config directory.
---
symlinks:
  "myservice/server.conf.j2": "roles/myservice-server/templates/server.conf.j2"</screen>
    <para>
     When the above file is parsed by the third-party-import playbook, a
     <filename>~/openstack/my_cloud/myservice/server.conf.j2</filename> symlink will
     be added to point to the configuration template under the myservice-server
     role.
    </para>
   </section>
  </section>
  <section xml:id="d1e741">
   <title>Other Application Content</title>
   <para>
    It is not uncommon for a third-party service integration to require
    additional content to be deployed to a node, where that content is not
    packaged as a deb/rpm or is a python application that could be deployed
    into a venv. &lcm; provides a generic mechanism for
    packaging such content and delivering it to target nodes (coupled with the
    use of &lcm; Ansible modules in the 3rd-party Ansible
    playbooks). For example, this mechanism can be used to deliver a Java-based
    application to target Cloud nodes. &lcm; packages this
    content and makes it available in the same repo used for serving out python
    venvs, as shown in the diagram below:
   </para>
   <informalfigure>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="media-third_party-other_application_content.png" width="75%"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="media-third_party-other_application_content.png"/>
     </imageobject>
    </mediaobject>
   </informalfigure>
   <para>
    To prepare such content to be packaged, you should follow these
    steps:
   </para>
   <orderedlist>
    <listitem>
     <para>
      Create an appropriately-named sub-directory under the
      <literal>other</literal> directory for each separate set of application
      content to be imported.
     </para>
    </listitem>
    <listitem>
     <para>
      For each of these sub-directories, populate with the set of application
      content; this does not need to confirm to any particular layout.
     </para>
    </listitem>
   </orderedlist>
   <para>
    A sample layout for other application content that is be imported is as
    follows:
   </para>
<screen>third-party/myservice/other
└── serviceA
    ├── serviceA-part1.tgz
    └── serviceA-part2.tgz</screen>
   <para>
    When the third-party-import playbook has been completed, the above content
    is bundled into a single package and made available on the venv repo of the
    &lcm; node. An example playbook task for delivering this
    bundled package to a target cloud node is as follows:
   </para>
<screen>- name: serviceA-server | install | Install myserviceA package
  become: yes
  install_package:
    name: serviceA
    service: serviceA
    state: present
    activate: act_on
  register: serviceA_install_result</screen>
  </section>
  <section xml:id="d1e800">
   <title>Centralized Logging Profiles</title>
   <para>
    &productname; provides a centralized logging service, which collects log files
    for all &productname; services and stores them in a centralized elasticsearch
    store, where they can then be viewed, searched and analyzed via a Kibana
    interface. To configure a third-party service for this centralized logging
    service, you must add a logging profile yaml file under the logging
    directory, e.g.:
   </para>
<screen>third-party/myservice/logging/
└── myservice-clr.yml</screen>
   <para>
    Note that in addition to configuring a service for centralized logging, the
    above profile also defines the logrotate policy for the service. For
    details on creating a logging profile and general info on the centralized
    logging service, see <xref linkend="centralized_logging"/>.
<!-- Commented in DITA: -->
<!--TODO REF
    (centralized logging docs supplied by Logging team, see <xref format="html" scope="external"
     href="http://jira.hpcloud.net/browse/LOG-791">LOG-791</xref>).-->
   </para>
  </section>
  <section xml:id="d1e825">
   <title>&productname; Service Configuration</title>
   <para>
    Some &productname; services provide an interface for injecting
    third-party customizations of the deployment of that service, which
    includes the addition of configuration data to certain selected
    configuration files. The specifics of what can be customized depends on the
    service. The general model is that a third-party service definition can
    declare that it provides data (<literal>provides-data</literal>
    relationship) to another service or service-component, where that data
    could be the name of one or more plugins/drivers, a chunk of additional
    configuration content or any other settings that exposed by the peer
    service/service-component. Currently, only the &productname; neutron service
    provides such an interface.
    <!-- Commented in DITA: -->
    <!--Details on what can be configured and how it is used can be found
    <xref href="../../networking/DCN-integration.dita">here</xref>.-->
   </para>
  </section>
 </section>
 <section xml:id="d1e839">
  <title>Upgrade</title>
  <para>
   After deploying &productname; integrated with a third-party service, there are
   two main upgrade scenarios:
  </para>
  <orderedlist>
   <listitem>
    <para>
     &productname; upgrade (major, minor, patch or hotfix)
    </para>
   </listitem>
   <listitem>
    <para>
     Upgrade of third-party content independent of a &productname; upgrade.
    </para>
   </listitem>
  </orderedlist>
  <section xml:id="d1e861">
   <title>&productname; Upgrade</title>
   <para>
    <phrase>After deploying &productname; integrated with a third-party service, the
    </phrase>following steps must be carried for any upgrade of &productname;
    (major, minor, patch, hotfix):
   </para>
   <orderedlist>
    <listitem>
     <para>
      Update the &lcm;:
     </para>
<screen>~/hos-4.x.y/hos-init.bash</screen>
    </listitem>
    <listitem>
     <para>
      If required, update third-party content, e.g. contents under
      <filename>~/third-party/myservice</filename>. If the third-party
      integration involves the patching of a venv and the upgrade involves a
      change in OpenStack release (e.g. Mitaka to Newton), then an update of
      the plugin code used to patch the venv may be required.
     </para>
    </listitem>
    <listitem>
     <para>
      Run the 3rd-party import playbook:
     </para>
<screen>cd ~/openstack/ardana/ansible/
ansible-playbook -i hosts/localhost third-party-import.yml</screen>
     <para>
      If the third-party integration involves the patching of a Neutron venv
      (and Neutron has since changed in this upgrade), then the import playbook
      step will reapply that plugin to the latest &productname; Neutron venv
      supplied in the upgrade kit.
     </para>
    </listitem>
    <listitem>
     <para>
      Proceed with a cloud upgrade as per normal:
     </para>
     <orderedlist>
      <listitem>
       <para>
        Run the configuration processor:
       </para>
<screen>cd ~/openstack/ardana/ansible/
ansible-playbook -i hosts/localhost config-processor-run.yml -e encrypt="" -e rekey=""</screen>
      </listitem>
      <listitem>
       <para>
        Ready the deployment:
       </para>
<screen>cd ~/openstack/ardana/ansible/
ansible-playbook -i hosts/localhost ready-deployment.yml</screen>
      </listitem>
      <listitem>
       <para>
        Upgrade the cloud.
       </para>
<screen>cd ~/scratch/ansible/next/hos/ansible
ansible-playbook -i hosts/verb_hosts ardana-upgrade.yml</screen>
      </listitem>
     </orderedlist>
    </listitem>
   </orderedlist>
   <para>
    It is critical to re-run a third-party import after the hos-init step and
    before an upgrade is started. Omitting the import leaves you in danger of
    overwriting a previously patched and deployed venv with the latest one
    supplied in the &productname; upgrade kit. For this reason,
    <filename>ardana-init.bash</filename> will display a warning message when it
    detects that third-party content has been previously supplied.
   </para>
  </section>
  <section xml:id="d1e951">
   <title>Third-party Content Upgrade</title>
   <para>
    It is also possible to update third-party content independently of a
    &productname; upgrade, e.g. update the plugin used to patch the &productname; Neutron
    venv. To update third-party content, the following steps apply:
   </para>
   <orderedlist>
    <listitem>
     <para>
      Update the relevant third-party content under
      <filename>~/third-party</filename>, e.g.
      <filename>~/third-party/myservice</filename>
     </para>
    </listitem>
    <listitem>
     <para>
      Run the 3rd-party import playbook:
     </para>
<screen>cd ~/openstack/ardana/ansible/
ansible-playbook -i hosts/localhost third-party-import.yml</screen>
     <para>
      If the third-party update involves the change of a Neutron plugin, the
      latest &productname; Neutron venv will be selected and patched with the latest
      third-party content. This is guaranteed to be selected over the previous
      patched venv in a subsequent upgrade.
     </para>
    </listitem>
    <listitem>
     <para>
      Proceed with a cloud upgrade as per normal:
     </para>
     <orderedlist>
      <listitem>
       <para>
        Run the configuration processor:
       </para>
<screen>cd ~/openstack/ardana/ansible/
ansible-playbook -i hosts/localhost config-processor-run.yml -e encrypt="" -e rekey=""</screen>
      </listitem>
      <listitem>
       <para>
        Ready the deployment:
       </para>
<screen>cd ~/openstack/ardana/ansible/
ansible-playbook -i hosts/localhost ready-deployment.yml</screen>
      </listitem>
      <listitem>
       <para>
        Upgrade the cloud.
       </para>
<screen>cd ~/scratch/ansible/next/hos/ansible
ansible-playbook -i hosts/verb_hosts ardana-upgrade.yml</screen>
      </listitem>
     </orderedlist>
     <para>
      Note that the above steps includes running the config-processor and a
      ready-deployment step. While this is not specifically required for all
      types of third-party update (e.g. only changing a venv), it is safest to
      run the full set of steps to guarantee that all third-party changes are
      pulled into the next deployment/upgrade.
     </para>
    </listitem>
   </orderedlist>
  </section>
 </section>
</section>
